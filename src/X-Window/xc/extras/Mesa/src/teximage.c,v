head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.28.21;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.01.02;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.01.02;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.20.04;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.29.04;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.04.48;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@
/*
 * Mesa 3-D graphics library
 * Version:  3.4
 *
 * Copyright (C) 1999-2000  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


#ifdef PC_HEADER
#include "all.h"
#else
#include "glheader.h"
#include "context.h"
#include "image.h"
#include "mem.h"
#include "mmath.h"
#include "span.h"
#include "texformat.h"
#include "teximage.h"
#include "texstate.h"
#include "types.h"
#endif


/*
 * NOTES:
 *
 * Mesa's native texture datatype is GLubyte.  Native formats are
 * GL_ALPHA, GL_LUMINANCE, GL_LUMANCE_ALPHA, GL_INTENSITY, GL_RGB, GL_RGBA,
 * and GL_COLOR_INDEX.
 * Device drivers are free to implement any internal format they want.
 */


#ifdef DEBUG
static void PrintTexture(const struct gl_texture_image *img)
{
   GLuint i, j, c;
   GLubyte *data = img->Data;

   if (!data) {
      printf("No texture data\n");
      return;
   }

   switch (img->Format) {
      case GL_ALPHA:
      case GL_LUMINANCE:
      case GL_INTENSITY:
      case GL_COLOR_INDEX:
         c = 1;
         break;
      case GL_LUMINANCE_ALPHA:
         c = 2;
         break;
      case GL_RGB:
         c = 3;
         break;
      case GL_RGBA:
         c = 4;
         break;
      default:
         gl_problem(NULL, "error in PrintTexture\n");
         return;
   }


   for (i = 0; i < img->Height; i++) {
      for (j = 0; j < img->Width; j++) {
         if (c==1)
            printf("%02x  ", data[0]);
         else if (c==2)
            printf("%02x%02x  ", data[0], data[1]);
         else if (c==3)
            printf("%02x%02x%02x  ", data[0], data[1], data[2]);
         else if (c==4)
            printf("%02x%02x%02x%02x  ", data[0], data[1], data[2], data[3]);
         data += c;
      }
      printf("\n");
   }
}
#endif



/*
 * Compute log base 2 of n.
 * If n isn't an exact power of two return -1.
 * If n<0 return -1.
 */
static int
logbase2( int n )
{
   GLint i = 1;
   GLint log2 = 0;

   if (n<0) {
      return -1;
   }

   while ( n > i ) {
      i *= 2;
      log2++;
   }
   if (i != n) {
      return -1;
   }
   else {
      return log2;
   }
}



/*
 * Given an internal texture format enum or 1, 2, 3, 4 return the
 * corresponding _base_ internal format:  GL_ALPHA, GL_LUMINANCE,
 * GL_LUMANCE_ALPHA, GL_INTENSITY, GL_RGB, or GL_RGBA.
 * Return -1 if invalid enum.
 */
GLint
_mesa_base_tex_format( GLcontext *ctx, GLint format )
{
  /*
   * Ask the driver for the base format, if it doesn't
   * know, it will return -1;
   */
   if (ctx->Driver.BaseCompressedTexFormat) {
      GLint ifmt = (*ctx->Driver.BaseCompressedTexFormat)(ctx, format);
      if (ifmt >= 0) {
         return ifmt;
      }
   }
   switch (format) {
      case GL_ALPHA:
      case GL_ALPHA4:
      case GL_ALPHA8:
      case GL_ALPHA12:
      case GL_ALPHA16:
         return GL_ALPHA;
      case 1:
      case GL_LUMINANCE:
      case GL_LUMINANCE4:
      case GL_LUMINANCE8:
      case GL_LUMINANCE12:
      case GL_LUMINANCE16:
         return GL_LUMINANCE;
      case 2:
      case GL_LUMINANCE_ALPHA:
      case GL_LUMINANCE4_ALPHA4:
      case GL_LUMINANCE6_ALPHA2:
      case GL_LUMINANCE8_ALPHA8:
      case GL_LUMINANCE12_ALPHA4:
      case GL_LUMINANCE12_ALPHA12:
      case GL_LUMINANCE16_ALPHA16:
         return GL_LUMINANCE_ALPHA;
      case GL_INTENSITY:
      case GL_INTENSITY4:
      case GL_INTENSITY8:
      case GL_INTENSITY12:
      case GL_INTENSITY16:
         return GL_INTENSITY;
      case 3:
      case GL_RGB:
      case GL_R3_G3_B2:
      case GL_RGB4:
      case GL_RGB5:
      case GL_RGB8:
      case GL_RGB10:
      case GL_RGB12:
      case GL_RGB16:
         return GL_RGB;
      case 4:
      case GL_RGBA:
      case GL_RGBA2:
      case GL_RGBA4:
      case GL_RGB5_A1:
      case GL_RGBA8:
      case GL_RGB10_A2:
      case GL_RGBA12:
      case GL_RGBA16:
         return GL_RGBA;
      case GL_COLOR_INDEX:
      case GL_COLOR_INDEX1_EXT:
      case GL_COLOR_INDEX2_EXT:
      case GL_COLOR_INDEX4_EXT:
      case GL_COLOR_INDEX8_EXT:
      case GL_COLOR_INDEX12_EXT:
      case GL_COLOR_INDEX16_EXT:
         return GL_COLOR_INDEX;
      default:
         return -1;  /* error */
   }
}



/*
 * Given an internal texture format enum or 1, 2, 3, 4 return the
 * corresponding _base_ internal format:  GL_ALPHA, GL_LUMINANCE,
 * GL_LUMANCE_ALPHA, GL_INTENSITY, GL_RGB, or GL_RGBA.  Return the
 * number of components for the format.  Return -1 if invalid enum.
 */
static GLint
components_in_intformat( GLint format )
{
   switch (format) {
      case GL_ALPHA:
      case GL_ALPHA4:
      case GL_ALPHA8:
      case GL_ALPHA12:
      case GL_ALPHA16:
         return 1;
      case 1:
      case GL_LUMINANCE:
      case GL_LUMINANCE4:
      case GL_LUMINANCE8:
      case GL_LUMINANCE12:
      case GL_LUMINANCE16:
         return 1;
      case 2:
      case GL_LUMINANCE_ALPHA:
      case GL_LUMINANCE4_ALPHA4:
      case GL_LUMINANCE6_ALPHA2:
      case GL_LUMINANCE8_ALPHA8:
      case GL_LUMINANCE12_ALPHA4:
      case GL_LUMINANCE12_ALPHA12:
      case GL_LUMINANCE16_ALPHA16:
         return 2;
      case GL_INTENSITY:
      case GL_INTENSITY4:
      case GL_INTENSITY8:
      case GL_INTENSITY12:
      case GL_INTENSITY16:
         return 1;
      case 3:
      case GL_RGB:
      case GL_R3_G3_B2:
      case GL_RGB4:
      case GL_RGB5:
      case GL_RGB8:
      case GL_RGB10:
      case GL_RGB12:
      case GL_RGB16:
         return 3;
      case 4:
      case GL_RGBA:
      case GL_RGBA2:
      case GL_RGBA4:
      case GL_RGB5_A1:
      case GL_RGBA8:
      case GL_RGB10_A2:
      case GL_RGBA12:
      case GL_RGBA16:
         return 4;
      case GL_COLOR_INDEX:
      case GL_COLOR_INDEX1_EXT:
      case GL_COLOR_INDEX2_EXT:
      case GL_COLOR_INDEX4_EXT:
      case GL_COLOR_INDEX8_EXT:
      case GL_COLOR_INDEX12_EXT:
      case GL_COLOR_INDEX16_EXT:
         return 1;
      default:
         return -1;  /* error */
   }
}


/*
 * Return GL_TRUE if internalFormat is a compressed format, return GL_FALSE
 * otherwise.
 */
static GLboolean
is_compressed_format(GLcontext *ctx, GLenum internalFormat)
{
    if (ctx->Driver.IsCompressedFormat) {
        return (*ctx->Driver.IsCompressedFormat)(ctx, internalFormat);
    }
    return GL_FALSE;
}



static void
set_tex_image(struct gl_texture_object *tObj,
              GLenum target, GLint level,
              struct gl_texture_image *texImage)
{
   ASSERT(tObj);
   ASSERT(texImage);
   switch (target) {
      case GL_TEXTURE_2D:
         tObj->Image[level] = texImage;
         return;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
         tObj->Image[level] = texImage;
         return;
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
         tObj->NegX[level] = texImage;
         return;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
         tObj->PosY[level] = texImage;
         return;
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
         tObj->NegY[level] = texImage;
         return;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
         tObj->PosZ[level] = texImage;
         return;
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
         tObj->NegZ[level] = texImage;
         return;
      default:
         gl_problem(NULL, "bad target in set_tex_image()");
         return;
   }
}


/*
 * Return new gl_texture_image struct with all fields initialized to zero.
 */
struct gl_texture_image *
_mesa_alloc_texture_image( void )
{
   return CALLOC_STRUCT(gl_texture_image);
}



/*
 * Initialize most fields of a gl_texture_image struct.
 */
static void
init_texture_image( GLcontext *ctx,
                    struct gl_texture_image *img,
                    GLsizei width, GLsizei height, GLsizei depth,
                    GLint border, GLenum internalFormat )
{
   ASSERT(img);
   ASSERT(!img->Data);
   _mesa_init_texture_format( ctx, img, internalFormat );
   img->Border = border;
   img->Width = width;
   img->Height = height;
   img->Depth = depth;
   img->WidthLog2 = logbase2(width - 2 * border);
   if (height == 1)  /* 1-D texture */
      img->HeightLog2 = 0;
   else
      img->HeightLog2 = logbase2(height - 2 * border);
   if (depth == 1)   /* 2-D texture */
      img->DepthLog2 = 0;
   else
      img->DepthLog2 = logbase2(depth - 2 * border);
   img->Width2 = 1 << img->WidthLog2;
   img->Height2 = 1 << img->HeightLog2;
   img->Depth2 = 1 << img->DepthLog2;
   img->MaxLog2 = MAX2(img->WidthLog2, img->HeightLog2);
   img->IsCompressed = is_compressed_format(ctx, internalFormat);
}



void
_mesa_free_texture_image( struct gl_texture_image *teximage )
{
   if (teximage->Data) {
      FREE( teximage->Data );
      teximage->Data = NULL;
   }
   FREE( teximage );
}



/*
 * Return number of bytes of storage needed to store a compressed texture
 * image.  Only the driver knows for sure.  If the driver can't help us,
 * we must return 0.
 */
GLuint
_mesa_compressed_image_size(GLcontext *ctx,
                            GLenum internalFormat,
                            GLint numDimensions,
                            GLint width,
                            GLint height,
                            GLint depth)
{
   if (ctx->Driver.CompressedImageSize) {
      return (*ctx->Driver.CompressedImageSize)(ctx, internalFormat,
                                                numDimensions,
                                                width, height, depth);
   }
   else {
      /* Shouldn't this be an internal error of some sort? */
      return 0;
   }
}



/*
 * Given a texture unit and a texture target, return the corresponding
 * texture object.
 */
struct gl_texture_object *
_mesa_select_tex_object(GLcontext *ctx, struct gl_texture_unit *texUnit,
                        GLenum target)
{
   switch (target) {
      case GL_TEXTURE_1D:
         return texUnit->CurrentD[1];
      case GL_PROXY_TEXTURE_1D:
         return ctx->Texture.Proxy1D;
      case GL_TEXTURE_2D:
         return texUnit->CurrentD[2];
      case GL_PROXY_TEXTURE_2D:
         return ctx->Texture.Proxy2D;
      case GL_TEXTURE_3D:
         return texUnit->CurrentD[3];
      case GL_PROXY_TEXTURE_3D:
         return ctx->Texture.Proxy3D;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
      case GL_TEXTURE_CUBE_MAP_ARB:
         return ctx->Extensions.HaveTextureCubeMap
                ? texUnit->CurrentCubeMap : NULL;
      case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
         return ctx->Extensions.HaveTextureCubeMap
                ? ctx->Texture.ProxyCubeMap : NULL;
      default:
         gl_problem(NULL, "bad target in _mesa_select_tex_object()");
         return NULL;
   }
}


/*
 * Return the texture image struct which corresponds to target and level
 * for the given texture unit.
 */
struct gl_texture_image *
_mesa_select_tex_image(GLcontext *ctx, const struct gl_texture_unit *texUnit,
                       GLenum target, GLint level)
{
   ASSERT(texUnit);
   switch (target) {
      case GL_TEXTURE_1D:
         return texUnit->CurrentD[1]->Image[level];
      case GL_PROXY_TEXTURE_1D:
         return ctx->Texture.Proxy1D->Image[level];
      case GL_TEXTURE_2D:
         return texUnit->CurrentD[2]->Image[level];
      case GL_PROXY_TEXTURE_2D:
         return ctx->Texture.Proxy2D->Image[level];
      case GL_TEXTURE_3D:
         return texUnit->CurrentD[3]->Image[level];
      case GL_PROXY_TEXTURE_3D:
         return ctx->Texture.Proxy3D->Image[level];
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            return texUnit->CurrentCubeMap->Image[level];
         else
            return NULL;
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            return texUnit->CurrentCubeMap->NegX[level];
         else
            return NULL;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            return texUnit->CurrentCubeMap->PosY[level];
         else
            return NULL;
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            return texUnit->CurrentCubeMap->NegY[level];
         else
            return NULL;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            return texUnit->CurrentCubeMap->PosZ[level];
         else
            return NULL;
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            return texUnit->CurrentCubeMap->NegZ[level];
         else
            return NULL;
      case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            return ctx->Texture.ProxyCubeMap->Image[level];
         else
            return NULL;
      default:
         gl_problem(ctx, "bad target in _mesa_select_tex_image()");
         return NULL;
   }
}



/* Need this to prevent an out-of-bounds memory access when using
 * X86 optimized code.
 */
#ifdef USE_X86_ASM
#  define EXTRA_BYTE 1
#else
#  define EXTRA_BYTE 0
#endif



/*
 * Called by glTexImage[123]D.  Fill in a texture image with data given
 * by the client.  All pixel transfer and unpack modes are handled here.
 * NOTE: All texture image parameters should have already been error checked.
 */
static void
make_texture_image( GLcontext *ctx,
                    struct gl_texture_image *texImage,
                    GLenum srcFormat, GLenum srcType, const GLvoid *pixels,
                    const struct gl_pixelstore_attrib *unpacking)
{
   GLint components, numPixels;
   GLint internalFormat, width, height, depth, border;

   ASSERT(ctx);
   ASSERT(texImage);
   ASSERT(!texImage->Data);
   ASSERT(pixels);
   ASSERT(unpacking);

   internalFormat = texImage->IntFormat;
   width = texImage->Width;
   height = texImage->Height;
   depth = texImage->Depth;
   border = texImage->Border;
   components = components_in_intformat(internalFormat);

   ASSERT(width > 0);
   ASSERT(height > 0);
   ASSERT(depth > 0);
   ASSERT(border == 0 || border == 1);
   ASSERT(pixels);
   ASSERT(unpacking);
   ASSERT(components);

   numPixels = width * height * depth;

   texImage->Data = (GLubyte *) MALLOC(numPixels * components + EXTRA_BYTE);
   if (!texImage->Data)
      return;      /* out of memory */

   /*
    * OK, the texture image struct has been initialized and the texture
    * image memory has been allocated.
    * Now fill in the texture image from the source data.
    * This includes applying the pixel transfer operations.
    */

   /* try common 2D texture cases first */
   if (!ctx->Pixel.ScaleOrBiasRGBA && !ctx->Pixel.MapColorFlag
       && !ctx->Pixel.IndexOffset && !ctx->Pixel.IndexShift
       && srcType == GL_UNSIGNED_BYTE && depth == 1) {

      if ((GLint) srcFormat == internalFormat ||
          (srcFormat == GL_LUMINANCE && internalFormat == 1) ||
          (srcFormat == GL_LUMINANCE_ALPHA && internalFormat == 2) ||
          (srcFormat == GL_RGB && internalFormat == 3) ||
          (srcFormat == GL_RGBA && internalFormat == 4)) {
         /* This will cover the common GL_RGB, GL_RGBA, GL_ALPHA,
          * GL_LUMINANCE_ALPHA, etc. texture formats.
          */
         const GLubyte *src = (const GLubyte *) _mesa_image_address(
            unpacking, pixels, width, height, srcFormat, srcType, 0, 0, 0);
         const GLint srcStride = _mesa_image_row_stride(unpacking, width,
                                                        srcFormat, srcType);
         GLubyte *dst = texImage->Data;
         GLint dstBytesPerRow = width * components * sizeof(GLubyte);
         if (srcStride == dstBytesPerRow) {
            MEMCPY(dst, src, height * dstBytesPerRow);
         }
         else {
            GLint i;
            for (i = 0; i < height; i++) {
               MEMCPY(dst, src, dstBytesPerRow);
               src += srcStride;
               dst += dstBytesPerRow;
            }
         }
         return;  /* all done */
      }
      else if (srcFormat == GL_RGBA && internalFormat == GL_RGB) {
         /* commonly used by Quake */
         const GLubyte *src = (const GLubyte *) _mesa_image_address(
            unpacking, pixels, width, height, srcFormat, srcType, 0, 0, 0);
         const GLint srcStride = _mesa_image_row_stride(unpacking, width,
                                                        srcFormat, srcType);
         GLubyte *dst = texImage->Data;
         GLint i, j;
         for (i = 0; i < height; i++) {
            const GLubyte *s = src;
            for (j = 0; j < width; j++) {
               *dst++ = *s++;  /*red*/
               *dst++ = *s++;  /*green*/
               *dst++ = *s++;  /*blue*/
               s++;            /*alpha*/
            }
            src += srcStride;
         }
         return;  /* all done */
      }
   }


   /*
    * General case solutions
    */
   if (texImage->Format == GL_COLOR_INDEX) {
      /* color index texture */
      const GLint destBytesPerRow = width * components * sizeof(GLubyte);
      const GLenum dstType = GL_UNSIGNED_BYTE;
      GLubyte *dest = texImage->Data;
      GLint img, row;
      for (img = 0; img < depth; img++) {
         for (row = 0; row < height; row++) {
            const GLvoid *source = _mesa_image_address(unpacking,
                pixels, width, height, srcFormat, srcType, img, row, 0);
            _mesa_unpack_index_span(ctx, width, dstType, dest,
                                    srcType, source, unpacking, GL_TRUE);
            dest += destBytesPerRow;
         }
      }
   }
   else {
      /* regular, color texture */
      const GLint destBytesPerRow = width * components * sizeof(GLubyte);
      const GLenum dstFormat = texImage->Format;
      GLubyte *dest = texImage->Data;
      GLint img, row;
      for (img = 0; img < depth; img++) {
         for (row = 0; row < height; row++) {
            const GLvoid *source = _mesa_image_address(unpacking,
                   pixels, width, height, srcFormat, srcType, img, row, 0);
            _mesa_unpack_ubyte_color_span(ctx, width, dstFormat, dest,
                   srcFormat, srcType, source, unpacking, GL_TRUE);
            dest += destBytesPerRow;
         }
      }
   }
}



/*
 * glTexImage[123]D can accept a NULL image pointer.  In this case we
 * create a texture image with unspecified image contents per the OpenGL
 * spec.  This function creates an empty image for the given texture image.
 */
static void
make_null_texture( struct gl_texture_image *texImage )
{
   GLint components;
   GLint numPixels;

   ASSERT(texImage);
   ASSERT(!texImage->Data);

   components = components_in_intformat(texImage->IntFormat);
   numPixels = texImage->Width * texImage->Height * texImage->Depth;

   texImage->Data = (GLubyte *) MALLOC( numPixels * components + EXTRA_BYTE );

   /*
    * Let's see if anyone finds this.  If glTexImage2D() is called with
    * a NULL image pointer then load the texture image with something
    * interesting instead of leaving it indeterminate.
    */
   if (texImage->Data) {
      static const char message[8][32] = {
         "   X   X  XXXXX   XXX     X    ",
         "   XX XX  X      X   X   X X   ",
         "   X X X  X      X      X   X  ",
         "   X   X  XXXX    XXX   XXXXX  ",
         "   X   X  X          X  X   X  ",
         "   X   X  X      X   X  X   X  ",
         "   X   X  XXXXX   XXX   X   X  ",
         "                               "
      };

      GLubyte *imgPtr = texImage->Data;
      GLuint i, j;
      GLint k;
      for (i = 0; i < texImage->Height; i++) {
         GLint srcRow = 7 - i % 8;
         for (j = 0; j < texImage->Width; j++) {
            GLint srcCol = j % 32;
            GLint texel = (message[srcRow][srcCol]=='X') ? 255 : 70;
            for (k = 0; k < components; k++) {
               *imgPtr++ = (GLubyte) texel;
            }
         }
      }
   }
}



/*
 * This is called when a proxy texture test fails, we set all the
 * image members (except DriverData) to zero.
 */
static void
clear_proxy_teximage(struct gl_texture_image *img)
{
   ASSERT(img);
   img->Format = 0;
   img->IntFormat = 0;
   img->Border = 0;
   img->Width = 0;
   img->Height = 0;
   img->Depth = 0;
   img->Width2 = 0;
   img->Height2 = 0;
   img->Depth2 = 0;
   img->WidthLog2 = 0;
   img->HeightLog2 = 0;
   img->DepthLog2 = 0;
   img->Data = NULL;
   img->IsCompressed = 0;
   img->CompressedSize = 0;
   img->TexFormat = &_mesa_null_texformat;
}



/*
 * Test glTexImage[123]D() parameters for errors.
 * Input:
 *         dimensions - must be 1 or 2 or 3
 * Return:  GL_TRUE = an error was detected, GL_FALSE = no errors
 */
static GLboolean
texture_error_check( GLcontext *ctx, GLenum target,
                     GLint level, GLint internalFormat,
                     GLenum format, GLenum type,
                     GLuint dimensions,
                     GLint width, GLint height,
                     GLint depth, GLint border )
{
   GLboolean isProxy;
   GLint iformat;

   if (dimensions == 1) {
      isProxy = (GLboolean) (target == GL_PROXY_TEXTURE_1D);
      if (target != GL_TEXTURE_1D && !isProxy) {
         gl_error( ctx, GL_INVALID_ENUM, "glTexImage1D(target)" );
         return GL_TRUE;
      }
   }
   else if (dimensions == 2) {
      isProxy = (GLboolean) (target == GL_PROXY_TEXTURE_2D);
      if (target != GL_TEXTURE_2D && !isProxy &&
          !(ctx->Extensions.HaveTextureCubeMap &&
            target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
            target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB)) {
          gl_error( ctx, GL_INVALID_ENUM, "glTexImage2D(target)" );
          return GL_TRUE;
      }
   }
   else if (dimensions == 3) {
      isProxy = (GLboolean) (target == GL_PROXY_TEXTURE_3D);
      if (target != GL_TEXTURE_3D && !isProxy) {
         gl_error( ctx, GL_INVALID_ENUM, "glTexImage3D(target)" );
         return GL_TRUE;
      }
   }
   else {
      gl_problem( ctx, "bad dims in texture_error_check" );
      return GL_TRUE;
   }

   /* Border */
   if (border != 0 && border != 1) {
      if (!isProxy) {
         char message[100];
         sprintf(message, "glTexImage%dD(border)", dimensions);
         gl_error(ctx, GL_INVALID_VALUE, message);
      }
      return GL_TRUE;
   }

   /* Width */
   if (width < 2 * border || width > 2 + ctx->Const.MaxTextureSize
       || logbase2( width - 2 * border ) < 0) {
      if (!isProxy) {
         char message[100];
         sprintf(message, "glTexImage%dD(width)", dimensions);
         gl_error(ctx, GL_INVALID_VALUE, message);
      }
      return GL_TRUE;
   }

   /* Height */
   if (dimensions >= 2) {
      if (height < 2 * border || height > 2 + ctx->Const.MaxTextureSize
          || logbase2( height - 2 * border ) < 0) {
         if (!isProxy) {
            char message[100];
            sprintf(message, "glTexImage%dD(height)", dimensions);
            gl_error(ctx, GL_INVALID_VALUE, message);
         }
         return GL_TRUE;
      }
   }

   /* For cube map, width must equal height */
   if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
       target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
      if (width != height) {
         if (!isProxy) {
            gl_error(ctx, GL_INVALID_VALUE, "glTexImage2D(width != height)");
         }
         return GL_TRUE;
      }
   }

   /* Depth */
   if (dimensions >= 3) {
      if (depth < 2 * border || depth > 2 + ctx->Const.MaxTextureSize
          || logbase2( depth - 2 * border ) < 0) {
         if (!isProxy) {
            gl_error( ctx, GL_INVALID_VALUE, "glTexImage3D(depth)" );
         }
         return GL_TRUE;
      }
   }

   /* Level */
   if (level < 0 || level >= ctx->Const.MaxTextureLevels) {
      if (!isProxy) {
         char message[100];
         sprintf(message, "glTexImage%dD(level)", dimensions);
         gl_error(ctx, GL_INVALID_VALUE, message);
      }
      return GL_TRUE;
   }

   iformat = _mesa_base_tex_format( ctx, internalFormat );
   if (iformat < 0) {
      if (!isProxy) {
         char message[100];
         sprintf(message, "glTexImage%dD(internalFormat)", dimensions);
         gl_error(ctx, GL_INVALID_VALUE, message);
      }
      return GL_TRUE;
   }

   if (!is_compressed_format(ctx, internalFormat)) {
      if (!_mesa_is_legal_format_and_type( format, type )) {
         /* Yes, generate GL_INVALID_OPERATION, not GL_INVALID_ENUM, if there
          * is a type/format mismatch.  See 1.2 spec page 94, sec 3.6.4.
          */
         if (!isProxy) {
            char message[100];
            sprintf(message, "glTexImage%dD(format or type)", dimensions);
            gl_error(ctx, GL_INVALID_OPERATION, message);
         }
         return GL_TRUE;
      }
   }

   /* if we get here, the parameters are OK */
   return GL_FALSE;
}



/*
 * Test glTexSubImage[123]D() parameters for errors.
 * Input:
 *         dimensions - must be 1 or 2 or 3
 * Return:  GL_TRUE = an error was detected, GL_FALSE = no errors
 */
static GLboolean
subtexture_error_check( GLcontext *ctx, GLuint dimensions,
                        GLenum target, GLint level,
                        GLint xoffset, GLint yoffset, GLint zoffset,
                        GLint width, GLint height, GLint depth,
                        GLenum format, GLenum type )
{
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   struct gl_texture_image *destTex;

   if (dimensions == 1) {
      if (target != GL_TEXTURE_1D) {
         gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage1D(target)" );
         return GL_TRUE;
      }
   }
   else if (dimensions == 2) {
      if (ctx->Extensions.HaveTextureCubeMap) {
         if ((target < GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB ||
              target > GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) &&
             target != GL_TEXTURE_2D) {
            gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage2D(target)" );
            return GL_TRUE;
         }
      }
      else if (target != GL_TEXTURE_2D) {
         gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage2D(target)" );
         return GL_TRUE;
      }
   }
   else if (dimensions == 3) {
      if (target != GL_TEXTURE_3D) {
         gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage3D(target)" );
         return GL_TRUE;
      }
   }
   else {
      gl_problem( ctx, "bad dims in texture_error_check" );
      return GL_TRUE;
   }

   if (level < 0 || level >= ctx->Const.MaxTextureLevels) {
      gl_error(ctx, GL_INVALID_ENUM, "glTexSubImage2D(level)");
      return GL_TRUE;
   }

   if (width < 0) {
      char message[100];
      sprintf(message, "glTexSubImage%dD(width)", dimensions);
      gl_error(ctx, GL_INVALID_VALUE, message);
      return GL_TRUE;
   }
   if (height < 0 && dimensions > 1) {
      char message[100];
      sprintf(message, "glTexSubImage%dD(height)", dimensions);
      gl_error(ctx, GL_INVALID_VALUE, message);
      return GL_TRUE;
   }
   if (depth < 0 && dimensions > 2) {
      char message[100];
      sprintf(message, "glTexSubImage%dD(depth)", dimensions);
      gl_error(ctx, GL_INVALID_VALUE, message);
      return GL_TRUE;
   }

   destTex = texUnit->CurrentD[dimensions]->Image[level];
   if (!destTex) {
      gl_error(ctx, GL_INVALID_OPERATION, "glTexSubImage1/2/3D");
      return GL_TRUE;
   }

   if (xoffset < -((GLint)destTex->Border)) {
      gl_error(ctx, GL_INVALID_VALUE, "glTexSubImage1/2/3D(xoffset)");
      return GL_TRUE;
   }
   if (xoffset + width > (GLint) (destTex->Width + destTex->Border)) {
      gl_error(ctx, GL_INVALID_VALUE, "glTexSubImage1/2/3D(xoffset+width)");
      return GL_TRUE;
   }
   if (dimensions > 1) {
      if (yoffset < -((GLint)destTex->Border)) {
         gl_error(ctx, GL_INVALID_VALUE, "glTexSubImage2/3D(yoffset)");
         return GL_TRUE;
      }
      if (yoffset + height > (GLint) (destTex->Height + destTex->Border)) {
         gl_error(ctx, GL_INVALID_VALUE, "glTexSubImage2/3D(yoffset+height)");
         return GL_TRUE;
      }
   }
   if (dimensions > 2) {
      if (zoffset < -((GLint)destTex->Border)) {
         gl_error(ctx, GL_INVALID_VALUE, "glTexSubImage3D(zoffset)");
         return GL_TRUE;
      }
      if (zoffset + depth  > (GLint) (destTex->Depth+destTex->Border)) {
         gl_error(ctx, GL_INVALID_VALUE, "glTexSubImage3D(zoffset+depth)");
         return GL_TRUE;
      }
   }

   if (!is_compressed_format(ctx, destTex->IntFormat)) {
      if (!_mesa_is_legal_format_and_type(format, type)) {
         char message[100];
         sprintf(message, "glTexSubImage%dD(format or type)", dimensions);
         gl_error(ctx, GL_INVALID_ENUM, message);
         return GL_TRUE;
      }
   }

   return GL_FALSE;
}


/*
 * Test glCopyTexImage[12]D() parameters for errors.
 * Input:  dimensions - must be 1 or 2 or 3
 * Return:  GL_TRUE = an error was detected, GL_FALSE = no errors
 */
static GLboolean
copytexture_error_check( GLcontext *ctx, GLuint dimensions,
                         GLenum target, GLint level, GLint internalFormat,
                         GLint width, GLint height, GLint border )
{
   GLint iformat;

   if (dimensions == 1) {
      if (target != GL_TEXTURE_1D) {
         gl_error( ctx, GL_INVALID_ENUM, "glCopyTexImage1D(target)" );
         return GL_TRUE;
      }
   }
   else if (dimensions == 2) {
      if (ctx->Extensions.HaveTextureCubeMap) {
         if ((target < GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB ||
              target > GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) &&
             target != GL_TEXTURE_2D) {
            gl_error( ctx, GL_INVALID_ENUM, "glCopyTexImage2D(target)" );
            return GL_TRUE;
         }
      }
      else if (target != GL_TEXTURE_2D) {
         gl_error( ctx, GL_INVALID_ENUM, "glCopyTexImage2D(target)" );
         return GL_TRUE;
      }
   }

   /* Border */
   if (border!=0 && border!=1) {
      char message[100];
      sprintf(message, "glCopyTexImage%dD(border)", dimensions);
      gl_error(ctx, GL_INVALID_VALUE, message);
      return GL_TRUE;
   }

   /* Width */
   if (width < 2 * border || width > 2 + ctx->Const.MaxTextureSize
       || logbase2( width - 2 * border ) < 0) {
      char message[100];
      sprintf(message, "glCopyTexImage%dD(width)", dimensions);
      gl_error(ctx, GL_INVALID_VALUE, message);
      return GL_TRUE;
   }

   /* Height */
   if (dimensions >= 2) {
      if (height < 2 * border || height > 2 + ctx->Const.MaxTextureSize
          || logbase2( height - 2 * border ) < 0) {
         char message[100];
         sprintf(message, "glCopyTexImage%dD(height)", dimensions);
         gl_error(ctx, GL_INVALID_VALUE, message);
         return GL_TRUE;
      }
   }

   /* For cube map, width must equal height */
   if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
       target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
      if (width != height) {
         gl_error(ctx, GL_INVALID_VALUE, "glCopyTexImage2D(width != height)");
         return GL_TRUE;
      }
   }

   /* Level */
   if (level<0 || level>=ctx->Const.MaxTextureLevels) {
      char message[100];
      sprintf(message, "glCopyTexImage%dD(level)", dimensions);
      gl_error(ctx, GL_INVALID_VALUE, message);
      return GL_TRUE;
   }

   iformat = _mesa_base_tex_format( ctx, internalFormat );
   if (iformat < 0) {
      char message[100];
      sprintf(message, "glCopyTexImage%dD(internalFormat)", dimensions);
      gl_error(ctx, GL_INVALID_VALUE, message);
      return GL_TRUE;
   }

   /* if we get here, the parameters are OK */
   return GL_FALSE;
}


static GLboolean
copytexsubimage_error_check( GLcontext *ctx, GLuint dimensions,
                             GLenum target, GLint level,
                             GLint xoffset, GLint yoffset, GLint zoffset,
                             GLsizei width, GLsizei height )
{
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   struct gl_texture_image *teximage;

   if (dimensions == 1) {
      if (target != GL_TEXTURE_1D) {
         gl_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage1D(target)" );
         return GL_TRUE;
      }
   }
   else if (dimensions == 2) {
      if (ctx->Extensions.HaveTextureCubeMap) {
         if ((target < GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB ||
              target > GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) &&
             target != GL_TEXTURE_2D) {
            gl_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage2D(target)" );
            return GL_TRUE;
         }
      }
      else if (target != GL_TEXTURE_2D) {
         gl_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage2D(target)" );
         return GL_TRUE;
      }
   }
   else if (dimensions == 3) {
      if (target != GL_TEXTURE_3D) {
         gl_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage3D(target)" );
         return GL_TRUE;
      }
   }

   if (level < 0 || level >= ctx->Const.MaxTextureLevels) {
      char message[100];
      sprintf(message, "glCopyTexSubImage%dD(level)", dimensions);
      gl_error(ctx, GL_INVALID_VALUE, message);
      return GL_TRUE;
   }

   if (width < 0) {
      char message[100];
      sprintf(message, "glCopyTexSubImage%dD(width)", dimensions );
      gl_error(ctx, GL_INVALID_VALUE, message);
      return GL_TRUE;
   }
   if (dimensions > 1 && height < 0) {
      char message[100];
      sprintf(message, "glCopyTexSubImage%dD(height)", dimensions );
      gl_error(ctx, GL_INVALID_VALUE, message);
      return GL_TRUE;
   }

   teximage = texUnit->CurrentD[dimensions]->Image[level];
   if (!teximage) {
      char message[100];
      sprintf(message, "glCopyTexSubImage%dD(undefined texture)", dimensions);
      gl_error(ctx, GL_INVALID_OPERATION, message);
      return GL_TRUE;
   }

   if (xoffset < -((GLint)teximage->Border)) {
      char message[100];
      sprintf(message, "glCopyTexSubImage%dD(xoffset)", dimensions);
      gl_error(ctx, GL_INVALID_VALUE, message);
      return GL_TRUE;
   }
   if (xoffset+width > (GLint) (teximage->Width+teximage->Border)) {
      char message[100];
      sprintf(message, "glCopyTexSubImage%dD(xoffset+width)", dimensions);
      gl_error(ctx, GL_INVALID_VALUE, message);
      return GL_TRUE;
   }
   if (dimensions > 1) {
      if (yoffset < -((GLint)teximage->Border)) {
         char message[100];
         sprintf(message, "glCopyTexSubImage%dD(yoffset)", dimensions);
         gl_error(ctx, GL_INVALID_VALUE, message);
         return GL_TRUE;
      }
      /* NOTE: we're adding the border here, not subtracting! */
      if (yoffset+height > (GLint) (teximage->Height+teximage->Border)) {
         char message[100];
         sprintf(message, "glCopyTexSubImage%dD(yoffset+height)", dimensions);
         gl_error(ctx, GL_INVALID_VALUE, message);
         return GL_TRUE;
      }
   }

   if (dimensions > 2) {
      if (zoffset < -((GLint)teximage->Border)) {
         char message[100];
         sprintf(message, "glCopyTexSubImage%dD(zoffset)", dimensions);
         gl_error(ctx, GL_INVALID_VALUE, message);
         return GL_TRUE;
      }
      if (zoffset > (GLint) (teximage->Depth+teximage->Border)) {
         char message[100];
         sprintf(message, "glCopyTexSubImage%dD(zoffset+depth)", dimensions);
         gl_error(ctx, GL_INVALID_VALUE, message);
         return GL_TRUE;
      }
   }

   /* if we get here, the parameters are OK */
   return GL_FALSE;
}




/*
 * Turn generic compressed formats into specific compressed format.
 * Some of the compressed formats we don't support, so we
 * fall back to the uncompressed format.  (See issue 15 of
 * the GL_ARB_texture_compression specification.)
 */
static GLint
get_specific_compressed_tex_format(GLcontext *ctx,
                                   GLint ifmt, GLint numDimensions,
                                   GLint     *levelp,
                                   GLsizei   *widthp,
                                   GLsizei   *heightp,
                                   GLsizei   *depthp,
                                   GLint     *borderp,
                                   GLenum    *formatp,
                                   GLenum    *typep)
{
   char message[100];
   GLint internalFormat = ifmt;

   if (ctx->Extensions.HaveTextureCompression
       && ctx->Driver.SpecificCompressedTexFormat) {
      /*
       * First, ask the driver for the specific format.
       * We do this for all formats, since we may want to
       * fake one compressed format for another.
       */
       internalFormat = (*ctx->Driver.SpecificCompressedTexFormat)
                               (ctx, internalFormat, numDimensions,
                                levelp,
                                widthp, heightp, depthp,
                                borderp, formatp, typep);
   }

   /*
    * Now, convert any generic format left to an uncompressed
    * specific format.  If the driver does not support compression
    * of the format, we must drop back to the uncompressed format.
    * See issue 15 of the GL_ARB_texture_compression specification.
    */
   switch (internalFormat) {
      case GL_COMPRESSED_ALPHA_ARB:
         if (ctx && !ctx->Extensions.HaveTextureCompression) {
            sprintf(message, "glTexImage%dD(internalFormat)", numDimensions);
            gl_error(ctx, GL_INVALID_VALUE, message);
            return -1;
         }
         internalFormat = GL_ALPHA;
         break;
      case GL_COMPRESSED_LUMINANCE_ARB:
         if (ctx && !ctx->Extensions.HaveTextureCompression) {
            sprintf(message, "glTexImage%dD(internalFormat)", numDimensions);
            gl_error(ctx, GL_INVALID_VALUE, message);
            return -1;
         }
         internalFormat = GL_LUMINANCE;
         break;
      case GL_COMPRESSED_LUMINANCE_ALPHA_ARB:
         if (ctx && !ctx->Extensions.HaveTextureCompression) {
            sprintf(message, "glTexImage%dD(internalFormat)", numDimensions);
            gl_error(ctx, GL_INVALID_VALUE, message);
            return -1;
         }
         internalFormat = GL_LUMINANCE_ALPHA;
         break;
      case GL_COMPRESSED_INTENSITY_ARB:
         if (ctx && !ctx->Extensions.HaveTextureCompression) {
            sprintf(message, "glTexImage%dD(internalFormat)", numDimensions);
            gl_error(ctx, GL_INVALID_VALUE, message);
            return -1;
         }
         internalFormat = GL_INTENSITY;
         break;
      case GL_COMPRESSED_RGB_ARB:
         if (ctx && !ctx->Extensions.HaveTextureCompression) {
            sprintf(message, "glTexImage%dD(internalFormat)", numDimensions);
            gl_error(ctx, GL_INVALID_VALUE, message);
            return -1;
         }
         internalFormat = GL_RGB;
         break;
      case GL_COMPRESSED_RGBA_ARB:
         if (ctx && !ctx->Extensions.HaveTextureCompression) {
            sprintf(message, "glTexImage%dD(internalFormat)", numDimensions);
            gl_error(ctx, GL_INVALID_VALUE, message);
            return -1;
         }
         internalFormat = GL_RGBA;
         break;
      default:
         /* silence compiler warning */
         ;
   }
   return internalFormat;
}


/*
 * Called from the API.  Note that width includes the border.
 */
void
_mesa_TexImage1D( GLenum target, GLint level, GLint internalFormat,
                  GLsizei width, GLint border, GLenum format,
                  GLenum type, const GLvoid *pixels )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glTexImage1D");

   if (target==GL_TEXTURE_1D) {
      struct gl_texture_unit *texUnit;
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImage;
      GLint ifmt;

      ifmt = get_specific_compressed_tex_format(ctx, internalFormat, 1,
                                                &level,
                                                &width, 0, 0,
                                                &border, &format, &type);
      if (ifmt < 0) {
         /*
          * The error here is that we were sent a generic compressed
          * format, but the extension is not supported.
          */
         return;
      }
      else {
         internalFormat = ifmt;
      }

      if (texture_error_check(ctx, target, level, internalFormat,
                              format, type, 1, width, 1, 1, border)) {
         return;   /* error in texture image was detected */
      }

      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texObj = texUnit->CurrentD[1];
      texImage = texObj->Image[level];

      if (!texImage) {
         texImage = _mesa_alloc_texture_image();
         texObj->Image[level] = texImage;
         if (!texImage) {
            gl_error(ctx, GL_OUT_OF_MEMORY, "glTexImage1D");
            return;
         }
      }
      else if (texImage->Data) {
         FREE(texImage->Data);
         texImage->Data = NULL;
      }

      /* setup the teximage struct's fields */
      init_texture_image(ctx, texImage, width, 1, 1, border, internalFormat);

      /* process the texture image */
      if (pixels) {
         GLboolean retain = GL_TRUE;
         GLboolean success = GL_FALSE;
         if (!ctx->Pixel.MapColorFlag && !ctx->Pixel.ScaleOrBiasRGBA
             && ctx->Driver.TexImage1D) {
            /* let device driver try to use raw image */
            success = (*ctx->Driver.TexImage1D)( ctx, target, level, format,
                                                 type, pixels, &ctx->Unpack,
                                                 texObj, texImage, &retain);
         }
         if (retain || !success) {
            /* make internal copy of the texture image */
            make_texture_image(ctx, texImage, format, type,
                               pixels, &ctx->Unpack);
            if (!success && ctx->Driver.TexImage1D) {
               /* let device driver try to use unpacked image */
               (*ctx->Driver.TexImage1D)( ctx, target, level, texImage->Format,
                                          GL_UNSIGNED_BYTE, texImage->Data,
                                          &_mesa_native_packing,
                                          texObj, texImage, &retain);
            }
         }
         if (!retain && texImage->Data) {
            FREE(texImage->Data);
            texImage->Data = NULL;
         }
      }
      else {
         make_null_texture(texImage);
         if (ctx->Driver.TexImage1D) {
            GLboolean retain;
            (*ctx->Driver.TexImage1D)( ctx, target, level, texImage->Format,
                                       GL_UNSIGNED_BYTE, texImage->Data,
                                       &_mesa_native_packing,
                                       texObj, texImage, &retain);
         }
      }

      /* state update */
      gl_put_texobj_on_dirty_list( ctx, texObj );
      ctx->NewState |= NEW_TEXTURING;
   }
   else if (target == GL_PROXY_TEXTURE_1D) {
      /* Proxy texture: check for errors and update proxy state */
      GLenum error = texture_error_check(ctx, target, level, internalFormat,
                                         format, type, 1, width, 1, 1, border);
      if (!error && ctx->Driver.TestProxyTexImage) {
         error = !(*ctx->Driver.TestProxyTexImage)(ctx, target, level,
                                                  internalFormat, format, type,
                                                  width, 1, 1, border);
      }
      if (error) {
         /* if error, clear all proxy texture image parameters */
         if (level>=0 && level<ctx->Const.MaxTextureLevels) {
            clear_proxy_teximage(ctx->Texture.Proxy1D->Image[level]);
         }
      }
      else {
         /* if no error, update proxy texture image parameters */
         init_texture_image(ctx, ctx->Texture.Proxy1D->Image[level],
                            width, 1, 1, border, internalFormat);
      }
   }
   else {
      gl_error( ctx, GL_INVALID_ENUM, "glTexImage1D(target)" );
      return;
   }
}


void
_mesa_TexImage2D( GLenum target, GLint level, GLint internalFormat,
                  GLsizei width, GLsizei height, GLint border,
                  GLenum format, GLenum type,
                  const GLvoid *pixels )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glTexImage2D");

   if (target==GL_TEXTURE_2D ||
       (ctx->Extensions.HaveTextureCubeMap &&
        target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
        target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB)) {
      struct gl_texture_unit *texUnit;
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImage;
      GLint ifmt;

      ifmt = get_specific_compressed_tex_format(ctx, internalFormat, 2,
                                                &level,
                                                &width, &height, 0,
                                                &border, &format, &type);
      if (ifmt < 0) {
         /*
          * The error here is that we were sent a generic compressed
          * format, but the extension is not supported.
          */
         return;
      }
      else {
         internalFormat = ifmt;
      }

      if (texture_error_check(ctx, target, level, internalFormat,
                              format, type, 2, width, height, 1, border)) {
         return;   /* error in texture image was detected */
      }

      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);

      if (!texImage) {
         texImage = _mesa_alloc_texture_image();
         set_tex_image(texObj, target, level, texImage);
         /*texObj->Image[level] = texImage;*/
         if (!texImage) {
            gl_error(ctx, GL_OUT_OF_MEMORY, "glTexImage2D");
            return;
         }
      }
      else if (texImage->Data) {
         FREE(texImage->Data);
         texImage->Data = NULL;
      }

      /* setup the teximage struct's fields */
      init_texture_image(ctx, texImage, width, height,
                         1, border, internalFormat);

      /* process the texture image */
      if (pixels) {
         GLboolean retain = GL_TRUE;
         GLboolean success = GL_FALSE;
         if (!ctx->Pixel.MapColorFlag && !ctx->Pixel.ScaleOrBiasRGBA
             && ctx->Driver.TexImage2D) {
            /* let device driver try to use raw image */
            success = (*ctx->Driver.TexImage2D)( ctx, target, level, format,
                                                 type, pixels, &ctx->Unpack,
                                                 texObj, texImage, &retain);
         }
         if (retain || !success) {
            /* make internal copy of the texture image */
            make_texture_image(ctx, texImage, format, type,
                               pixels, &ctx->Unpack);
            if (!success && ctx->Driver.TexImage2D) {
               /* let device driver try to use unpacked image */
               (*ctx->Driver.TexImage2D)( ctx, target, level, texImage->Format,
                                          GL_UNSIGNED_BYTE, texImage->Data,
                                          &_mesa_native_packing,
                                          texObj, texImage, &retain);
            }
         }
         if (!retain && texImage->Data) {
            FREE(texImage->Data);
            texImage->Data = NULL;
         }
      }
      else {
         make_null_texture(texImage);
         if (ctx->Driver.TexImage2D) {
            GLboolean retain;
            (*ctx->Driver.TexImage2D)( ctx, target, level, texImage->Format,
                                       GL_UNSIGNED_BYTE, texImage->Data,
                                       &_mesa_native_packing,
                                       texObj, texImage, &retain);
         }
      }

#define OLD_DD_TEXTURE
#ifdef OLD_DD_TEXTURE
      /* XXX this will be removed in the future */
      if (ctx->Driver.TexImage) {
         (*ctx->Driver.TexImage)( ctx, target, texObj, level, internalFormat,
                                  texImage );
      }
#endif

      /* state update */
      gl_put_texobj_on_dirty_list( ctx, texObj );
      ctx->NewState |= NEW_TEXTURING;
   }
   else if (target == GL_PROXY_TEXTURE_2D) {
      /* Proxy texture: check for errors and update proxy state */
      GLenum error = texture_error_check(ctx, target, level, internalFormat,
                                    format, type, 2, width, height, 1, border);
      if (!error && ctx->Driver.TestProxyTexImage) {
         error = !(*ctx->Driver.TestProxyTexImage)(ctx, target, level,
                                                  internalFormat, format, type,
                                                  width, height, 1, border);
      }
      if (error) {
         /* if error, clear all proxy texture image parameters */
         if (level>=0 && level<ctx->Const.MaxTextureLevels) {
            clear_proxy_teximage(ctx->Texture.Proxy2D->Image[level]);
         }
      }
      else {
         /* if no error, update proxy texture image parameters */
         init_texture_image(ctx,
                            ctx->Texture.Proxy2D->Image[level],
                            width, height, 1, border, internalFormat);
      }
   }
   else {
      gl_error( ctx, GL_INVALID_ENUM, "glTexImage2D(target)" );
      return;
   }
}


/*
 * Called by the API or display list executor.
 * Note that width and height include the border.
 */
void
_mesa_TexImage3D( GLenum target, GLint level, GLint internalFormat,
                  GLsizei width, GLsizei height, GLsizei depth,
                  GLint border, GLenum format, GLenum type,
                  const GLvoid *pixels )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glTexImage3D");

   if (target==GL_TEXTURE_3D_EXT) {
      struct gl_texture_unit *texUnit;
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImage;
      GLint ifmt;

      ifmt = get_specific_compressed_tex_format(ctx, internalFormat, 3,
                                                &level,
                                                &width, &height, &depth,
                                                &border, &format, &type);
      if (ifmt < 0) {
         /*
          * The error here is that we were sent a generic compressed
          * format, but the extension is not supported.
          */
         return;
      }
      else {
         internalFormat = ifmt;
      }

      if (texture_error_check(ctx, target, level, internalFormat,
                              format, type, 3, width, height, depth, border)) {
         return;   /* error in texture image was detected */
      }

      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texObj = texUnit->CurrentD[3];
      texImage = texObj->Image[level];

      if (!texImage) {
         texImage = _mesa_alloc_texture_image();
         texObj->Image[level] = texImage;
         if (!texImage) {
            gl_error(ctx, GL_OUT_OF_MEMORY, "glTexImage3D");
            return;
         }
      }
      else if (texImage->Data) {
         FREE(texImage->Data);
         texImage->Data = NULL;
      }

      /* setup the teximage struct's fields */
      init_texture_image(ctx, texImage, width, height, depth,
                         border, internalFormat);

      /* process the texture image */
      if (pixels) {
         GLboolean retain = GL_TRUE;
         GLboolean success = GL_FALSE;
         if (!ctx->Pixel.MapColorFlag && !ctx->Pixel.ScaleOrBiasRGBA
             && ctx->Driver.TexImage3D) {
            /* let device driver try to use raw image */
            success = (*ctx->Driver.TexImage3D)( ctx, target, level, format,
                                                 type, pixels, &ctx->Unpack,
                                                 texObj, texImage, &retain);
         }
         if (retain || !success) {
            /* make internal copy of the texture image */
            make_texture_image(ctx, texImage, format, type,
                               pixels, &ctx->Unpack);
            if (!success && ctx->Driver.TexImage3D) {
               /* let device driver try to use unpacked image */
               (*ctx->Driver.TexImage3D)( ctx, target, level, texImage->Format,
                                          GL_UNSIGNED_BYTE, texImage->Data,
                                          &_mesa_native_packing,
                                          texObj, texImage, &retain);
            }
         }
         if (!retain && texImage->Data) {
            FREE(texImage->Data);
            texImage->Data = NULL;
         }
      }
      else {
         make_null_texture(texImage);
         if (ctx->Driver.TexImage3D) {
            GLboolean retain;
            (*ctx->Driver.TexImage3D)( ctx, target, level, texImage->Format,
                                       GL_UNSIGNED_BYTE, texImage->Data,
                                       &_mesa_native_packing,
                                       texObj, texImage, &retain);
         }
      }

      /* state update */
      gl_put_texobj_on_dirty_list( ctx, texObj );
      ctx->NewState |= NEW_TEXTURING;
   }
   else if (target == GL_PROXY_TEXTURE_3D) {
      /* Proxy texture: check for errors and update proxy state */
      GLenum error = texture_error_check(ctx, target, level, internalFormat,
                                format, type, 3, width, height, depth, border);
      if (!error && ctx->Driver.TestProxyTexImage) {
         error = !(*ctx->Driver.TestProxyTexImage)(ctx, target, level,
                                                 internalFormat, format, type,
                                                 width, height, depth, border);
      }
      if (error) {
         /* if error, clear all proxy texture image parameters */
         if (level>=0 && level<ctx->Const.MaxTextureLevels) {
            clear_proxy_teximage(ctx->Texture.Proxy3D->Image[level]);
         }
      }
      else {
         /* if no error, update proxy texture image parameters */
         init_texture_image(ctx, ctx->Texture.Proxy3D->Image[level],
                            width, height, depth, border, internalFormat);
      }
   }
   else {
      gl_error( ctx, GL_INVALID_ENUM, "glTexImage3D(target)" );
      return;
   }
}


void
_mesa_TexImage3DEXT( GLenum target, GLint level, GLenum internalFormat,
                     GLsizei width, GLsizei height, GLsizei depth,
                     GLint border, GLenum format, GLenum type,
                     const GLvoid *pixels )
{
   _mesa_TexImage3D(target, level, (GLint) internalFormat, width, height,
                    depth, border, format, type, pixels);
}


/*
 * Fetch a texture image from the device driver.
 * Store the results in the given texture object at the given mipmap level.
 */
void
_mesa_get_teximage_from_driver( GLcontext *ctx, GLenum target, GLint level,
                                const struct gl_texture_object *texObj )
{
   GLvoid *image;
   GLenum imgFormat, imgType;
   GLboolean freeImage;
   struct gl_texture_image *texImage;
   GLint destComponents, numPixels, srcBytesPerTexel;

   if (!ctx->Driver.GetTexImage)
      return;

   image = (*ctx->Driver.GetTexImage)( ctx, target, level, texObj,
                                       &imgFormat, &imgType, &freeImage);
   if (!image)
      return;

   texImage = texObj->Image[level];
   ASSERT(texImage);
   if (!texImage)
      return;

   destComponents = components_in_intformat(texImage->Format);
   assert(destComponents > 0);
   numPixels = texImage->Width * texImage->Height * texImage->Depth;
   assert(numPixels > 0);
   srcBytesPerTexel = _mesa_bytes_per_pixel(imgFormat, imgType);
   assert(srcBytesPerTexel > 0);

   if (!texImage->Data) {
      /* Allocate memory for the texture image data */
      texImage->Data = (GLubyte *) MALLOC(numPixels * destComponents + EXTRA_BYTE);
   }

   if (imgFormat == texImage->Format && imgType == GL_UNSIGNED_BYTE) {
      /* We got lucky!  The driver's format and type match Mesa's format. */
      if (texImage->Data) {
         MEMCPY(texImage->Data, image, numPixels * destComponents);
      }
   }
   else {
      /* Convert the texture image from the driver's format to Mesa's
       * internal format.
       */
      const GLint width = texImage->Width;
      const GLint height = texImage->Height;
      const GLint depth = texImage->Depth;
      const GLint destBytesPerRow = width * destComponents * sizeof(GLchan);
      const GLint srcBytesPerRow = width * srcBytesPerTexel;
      const GLenum dstType = GL_UNSIGNED_BYTE;
      const GLenum dstFormat = texImage->Format;
      const GLubyte *srcPtr = (const GLubyte *) image;
      GLubyte *destPtr = texImage->Data;

      if (texImage->Format == GL_COLOR_INDEX) {
         /* color index texture */
         GLint img, row;
         assert(imgFormat == GL_COLOR_INDEX);
         for (img = 0; img < depth; img++) {
            for (row = 0; row < height; row++) {
               _mesa_unpack_index_span(ctx, width, dstType, destPtr,
                             imgType, srcPtr, &_mesa_native_packing, GL_FALSE);
               destPtr += destBytesPerRow;
               srcPtr += srcBytesPerRow;
            }
         }
      }
      else {
         /* color texture */
         GLint img, row;
         for (img = 0; img < depth; img++) {
            for (row = 0; row < height; row++) {
               _mesa_unpack_ubyte_color_span(ctx, width, dstFormat, destPtr,
                  imgFormat, imgType, srcPtr, &_mesa_native_packing, GL_FALSE);
               destPtr += destBytesPerRow;
               srcPtr += srcBytesPerRow;
            }
         }
      }
   }

   if (freeImage)
      FREE(image);
}


/*
 * Get all the mipmap images for a texture object from the device driver.
 * Actually, only get mipmap images if we're using a mipmap filter.
 */
GLboolean
_mesa_get_teximages_from_driver(GLcontext *ctx,
                                struct gl_texture_object *texObj)
{
   if (ctx->Driver.GetTexImage) {
      static const GLenum targets[] = {
         GL_TEXTURE_1D,
         GL_TEXTURE_2D,
         GL_TEXTURE_3D,
         GL_TEXTURE_CUBE_MAP_ARB,
         GL_TEXTURE_CUBE_MAP_ARB,
         GL_TEXTURE_CUBE_MAP_ARB
      };
      GLboolean needLambda = (texObj->MinFilter != texObj->MagFilter);
      GLenum target = targets[texObj->Dimensions - 1];
      if (needLambda) {
         GLint level;
         /* Get images for all mipmap levels.  We might not need them
          * all but this is easier.  We're on a (slow) software path
          * anyway.
          */
         for (level = 0; level <= texObj->P; level++) {
            struct gl_texture_image *texImg = texObj->Image[level];
            if (texImg && !texImg->Data) {
               _mesa_get_teximage_from_driver(ctx, target, level, texObj);
               if (!texImg->Data)
                  return GL_FALSE;  /* out of memory */
            }
         }
      }
      else {
         GLint level = texObj->BaseLevel;
         struct gl_texture_image *texImg = texObj->Image[level];
         if (texImg && !texImg->Data) {
            _mesa_get_teximage_from_driver(ctx, target, level, texObj);
            if (!texImg->Data)
               return GL_FALSE;  /* out of memory */
         }
      }
      return GL_TRUE;
   }
   return GL_FALSE;
}



void
_mesa_GetTexImage( GLenum target, GLint level, GLenum format,
                   GLenum type, GLvoid *pixels )
{
   const struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLboolean discardImage;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetTexImage");

   if (level < 0 || level >= ctx->Const.MaxTextureLevels) {
      gl_error( ctx, GL_INVALID_VALUE, "glGetTexImage(level)" );
      return;
   }

   if (_mesa_sizeof_type(type) <= 0) {
      gl_error( ctx, GL_INVALID_ENUM, "glGetTexImage(type)" );
      return;
   }

   if (_mesa_components_in_format(format) <= 0) {
      gl_error( ctx, GL_INVALID_ENUM, "glGetTexImage(format)" );
      return;
   }

   if (!pixels)
      return;

   switch (target) {
      case GL_TEXTURE_1D:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentD[1];
         texImage = texObj->Image[level];
         break;
      case GL_TEXTURE_2D:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentD[2];
         texImage = texObj->Image[level];
         break;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap;
         texImage = texObj->Image[level];
         break;
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap;
         texImage = texObj->NegX[level];
         break;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap;
         texImage = texObj->PosY[level];
         break;
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap;
         texImage = texObj->NegY[level];
         break;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap;
         texImage = texObj->PosZ[level];
         break;
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap;
         texImage = texObj->NegZ[level];
         break;
      case GL_TEXTURE_3D:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentD[3];
         texImage = texObj->Image[level];
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetTexImage(target)" );
         return;
   }

   if (!texImage) {
      /* invalid mipmap level */
      return;
   }

   if (!texImage->Data) {
      /* try to get the texture image from the device driver */
      _mesa_get_teximage_from_driver(ctx, target, level, texObj);
      discardImage = GL_TRUE;
   }
   else {
      discardImage = GL_FALSE;
   }

   if (texImage->Data) {
      GLint width = texImage->Width;
      GLint height = texImage->Height;
      GLint row;

      for (row = 0; row < height; row++) {
         /* compute destination address in client memory */
         GLvoid *dest = _mesa_image_address( &ctx->Unpack, pixels,
                                                width, height,
                                                format, type, 0, row, 0);

         assert(dest);
         if (texImage->Format == GL_RGBA) {
            const GLubyte *src = texImage->Data + row * width * 4 * sizeof(GLubyte);
            _mesa_pack_rgba_span( ctx, width, (CONST GLubyte (*)[4]) src,
                                  format, type, dest, &ctx->Pack, GL_TRUE );
         }
         else {
            /* fetch RGBA row from texture image then pack it in client mem */
            GLubyte rgba[MAX_WIDTH][4];
            GLint i;
            const GLubyte *src;
            switch (texImage->Format) {
               case GL_ALPHA:
                  src = texImage->Data + row * width * sizeof(GLubyte);
                  for (i = 0; i < width; i++) {
                     rgba[i][RCOMP] = 255;
                     rgba[i][GCOMP] = 255;
                     rgba[i][BCOMP] = 255;
                     rgba[i][ACOMP] = src[i];
                  }
                  break;
               case GL_LUMINANCE:
                  src = texImage->Data + row * width * sizeof(GLubyte);
                  for (i = 0; i < width; i++) {
                     rgba[i][RCOMP] = src[i];
                     rgba[i][GCOMP] = src[i];
                     rgba[i][BCOMP] = src[i];
                     rgba[i][ACOMP] = 255;
                   }
                  break;
               case GL_LUMINANCE_ALPHA:
                  src = texImage->Data + row * 2 * width * sizeof(GLubyte);
                  for (i = 0; i < width; i++) {
                     rgba[i][RCOMP] = src[i*2+0];
                     rgba[i][GCOMP] = src[i*2+0];
                     rgba[i][BCOMP] = src[i*2+0];
                     rgba[i][ACOMP] = src[i*2+1];
                  }
                  break;
               case GL_INTENSITY:
                  src = texImage->Data + row * width * sizeof(GLubyte);
                  for (i = 0; i < width; i++) {
                     rgba[i][RCOMP] = src[i];
                     rgba[i][GCOMP] = src[i];
                     rgba[i][BCOMP] = src[i];
                     rgba[i][ACOMP] = 255;
                  }
                  break;
               case GL_RGB:
                  src = texImage->Data + row * 3 * width * sizeof(GLubyte);
                  for (i = 0; i < width; i++) {
                     rgba[i][RCOMP] = src[i*3+0];
                     rgba[i][GCOMP] = src[i*3+1];
                     rgba[i][BCOMP] = src[i*3+2];
                     rgba[i][ACOMP] = 255;
                  }
                  break;
               case GL_RGBA:
                  /* this special case should have been handled above! */
                  gl_problem( ctx, "error 1 in gl_GetTexImage" );
                  break;
               case GL_COLOR_INDEX:
                  gl_problem( ctx, "GL_COLOR_INDEX not implemented in gl_GetTexImage" );
                  break;
               default:
                  gl_problem( ctx, "bad format in gl_GetTexImage" );
            }
            _mesa_pack_rgba_span( ctx, width, (CONST GLubyte (*)[4])rgba,
                                  format, type, dest, &ctx->Pack, GL_TRUE );
         }
      }

      /* if we got the teximage from the device driver we'll discard it now */
      if (discardImage) {
         FREE(texImage->Data);
         texImage->Data = NULL;
      }
   }
}



void
_mesa_TexSubImage1D( GLenum target, GLint level,
                     GLint xoffset, GLsizei width,
                     GLenum format, GLenum type,
                     const GLvoid *pixels )
{
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLboolean success = GL_FALSE;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glTexSubImage1D");

   if (subtexture_error_check(ctx, 1, target, level, xoffset, 0, 0,
                              width, 1, 1, format, type)) {
      return;   /* error was detected */
   }

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = texUnit->CurrentD[1];
   texImage = texObj->Image[level];
   assert(texImage);

   if (width == 0 || !pixels)
      return;  /* no-op, not an error */


   if (!ctx->Pixel.MapColorFlag && !ctx->Pixel.ScaleOrBiasRGBA
       && ctx->Driver.TexSubImage1D) {
      success = (*ctx->Driver.TexSubImage1D)( ctx, target, level, xoffset,
                                              width, format, type, pixels,
                                              &ctx->Unpack, texObj, texImage );
   }
   if (!success) {
      /* XXX if Driver.TexSubImage1D, unpack image and try again? */

      const GLint texComponents = components_in_intformat(texImage->Format);
      const GLenum texFormat = texImage->Format;
      const GLint xoffsetb = xoffset + texImage->Border;
      GLboolean retain = GL_TRUE;
      if (!texImage->Data) {
         _mesa_get_teximage_from_driver( ctx, target, level, texObj );
         if (!texImage->Data) {
            make_null_texture(texImage);
         }
         if (!texImage->Data)
            return;  /* we're really out of luck! */
      }

      if (texFormat == GL_COLOR_INDEX) {
         /* color index texture */
         GLubyte *dst = texImage->Data + xoffsetb * texComponents;
         const GLvoid *src = _mesa_image_address(&ctx->Unpack, pixels, width,
                                                 1, format, type, 0, 0, 0);
         _mesa_unpack_index_span(ctx, width, GL_UNSIGNED_BYTE, dst,
                                 type, src, &ctx->Unpack, GL_TRUE);
      }
      else {
         /* color texture */
         GLubyte *dst = texImage->Data + xoffsetb * texComponents;
         const GLvoid *src = _mesa_image_address(&ctx->Unpack, pixels, width,
                                                 1, format, type, 0, 0, 0);
         _mesa_unpack_ubyte_color_span(ctx, width, texFormat, dst, format,
                                       type, src, &ctx->Unpack, GL_TRUE);
      }

      if (ctx->Driver.TexImage1D) {
         (*ctx->Driver.TexImage1D)( ctx, target, level, texImage->Format,
                                    GL_UNSIGNED_BYTE, texImage->Data,
                                    &_mesa_native_packing, texObj, texImage,
                                    &retain );
      }

      if (!retain && texImage->Data) {
         FREE(texImage->Data);
         texImage->Data = NULL;
      }
   }

   /*gl_put_texobj_on_dirty_list( ctx, texUnit->CurrentD[1] );*/
}


void
_mesa_TexSubImage2D( GLenum target, GLint level,
                     GLint xoffset, GLint yoffset,
                     GLsizei width, GLsizei height,
                     GLenum format, GLenum type,
                     const GLvoid *pixels )
{
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLboolean success = GL_FALSE;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glTexSubImage2D");

   if (subtexture_error_check(ctx, 2, target, level, xoffset, yoffset, 0,
                              width, height, 1, format, type)) {
      return;   /* error was detected */
   }

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = texObj->Image[level];
   assert(texImage);

   if (width == 0 || height == 0 || !pixels)
      return;  /* no-op, not an error */

   if (!ctx->Pixel.MapColorFlag && !ctx->Pixel.ScaleOrBiasRGBA
       && ctx->Driver.TexSubImage2D) {
      success = (*ctx->Driver.TexSubImage2D)( ctx, target, level, xoffset,
                                     yoffset, width, height, format, type,
                                     pixels, &ctx->Unpack, texObj, texImage );
   }
   if (!success) {
      /* XXX if Driver.TexSubImage2D, unpack image and try again? */

      const GLint texComponents = components_in_intformat(texImage->Format);
      const GLenum texFormat = texImage->Format;
      const GLint xoffsetb = xoffset + texImage->Border;
      const GLint yoffsetb = yoffset + texImage->Border;
      const GLint srcStride = _mesa_image_row_stride(&ctx->Unpack, width,
                                                     format, type);
      const GLint dstStride = texImage->Width * texComponents *sizeof(GLubyte);
      GLboolean retain = GL_TRUE;

      if (!texImage->Data) {
         _mesa_get_teximage_from_driver( ctx, target, level, texObj );
         if (!texImage->Data) {
            make_null_texture(texImage);
         }
         if (!texImage->Data)
            return;  /* we're really out of luck! */
      }

      if (texFormat == GL_COLOR_INDEX) {
         /* color index texture */
         GLubyte *dst = texImage->Data
                    + (yoffsetb * texImage->Width + xoffsetb) * texComponents;
         const GLubyte *src = (const GLubyte *)
            _mesa_image_address(&ctx->Unpack, pixels, width, height, format,
                                type, 0, 0, 0);
         GLint row;
         for (row = 0; row < height; row++) {
            _mesa_unpack_index_span(ctx, width, GL_UNSIGNED_BYTE, dst, type,
                                 (const GLvoid *) src, &ctx->Unpack, GL_TRUE);
            src += srcStride;
            dst += dstStride;
         }
      }
      else {
         /* color texture */
         GLubyte *dst = texImage->Data
                    + (yoffsetb * texImage->Width + xoffsetb) * texComponents;
         const GLubyte *src = (const GLubyte *)
            _mesa_image_address(&ctx->Unpack, pixels, width, height, format,
                                type, 0, 0, 0);
         GLint row;
         for (row = 0; row < height; row++) {
            _mesa_unpack_ubyte_color_span(ctx, width, texFormat, dst, format,
                           type, (const GLvoid *) src, &ctx->Unpack, GL_TRUE);
            src += srcStride;
            dst += dstStride;
         }
      }

      if (ctx->Driver.TexImage2D) {
         (*ctx->Driver.TexImage2D)(ctx, target, level, texImage->Format,
                                   GL_UNSIGNED_BYTE, texImage->Data,
                                   &_mesa_native_packing, texObj, texImage,
                                   &retain);
      }

      if (!retain && texImage->Data) {
         FREE(texImage->Data);
         texImage->Data = NULL;
      }

#ifdef OLD_DD_TEXTURE
      /* XXX this will be removed in the future */
      if (ctx->Driver.TexSubImage) {
         (*ctx->Driver.TexSubImage)(ctx, target, texObj, level,
                                    xoffset, yoffset, width, height,
                                    texImage->IntFormat, texImage);
      }
      else if (ctx->Driver.TexImage) {
         (*ctx->Driver.TexImage)(ctx, GL_TEXTURE_2D, texObj,
                                 level, texImage->IntFormat, texImage );
      }
#endif
   }
}



void
_mesa_TexSubImage3D( GLenum target, GLint level,
                     GLint xoffset, GLint yoffset, GLint zoffset,
                     GLsizei width, GLsizei height, GLsizei depth,
                     GLenum format, GLenum type,
                     const GLvoid *pixels )
{
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLboolean success = GL_FALSE;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glTexSubImage3D");

   if (subtexture_error_check(ctx, 3, target, level, xoffset, yoffset, zoffset,
                              width, height, depth, format, type)) {
      return;   /* error was detected */
   }

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = texUnit->CurrentD[3];
   texImage = texObj->Image[level];
   assert(texImage);

   if (width == 0 || height == 0 || height == 0 || !pixels)
      return;  /* no-op, not an error */

   if (!ctx->Pixel.MapColorFlag && !ctx->Pixel.ScaleOrBiasRGBA
       && ctx->Driver.TexSubImage3D) {
      success = (*ctx->Driver.TexSubImage3D)( ctx, target, level, xoffset,
                                yoffset, zoffset, width, height, depth, format,
                                type, pixels, &ctx->Unpack, texObj, texImage );
   }
   if (!success) {
      /* XXX if Driver.TexSubImage3D, unpack image and try again? */

      const GLint texComponents = components_in_intformat(texImage->Format);
      const GLenum texFormat = texImage->Format;
      const GLint xoffsetb = xoffset + texImage->Border;
      const GLint yoffsetb = yoffset + texImage->Border;
      const GLint zoffsetb = zoffset + texImage->Border;
      const GLint texWidth = texImage->Width;
      const GLint dstRectArea = texWidth * texImage->Height;
      const GLint srcStride = _mesa_image_row_stride(&ctx->Unpack,
                                                     width, format, type);
      const GLint dstStride = texWidth * texComponents * sizeof(GLubyte);
      GLboolean retain = GL_TRUE;

      if (texFormat == GL_COLOR_INDEX) {
         /* color index texture */
         GLint img, row;
         for (img = 0; img < depth; img++) {
            const GLubyte *src = (const GLubyte *)
               _mesa_image_address(&ctx->Unpack, pixels, width, height,
                                   format, type, img, 0, 0);
            GLubyte *dst = texImage->Data + ((zoffsetb + img) * dstRectArea
                     + yoffsetb * texWidth + xoffsetb) * texComponents;
            for (row = 0; row < height; row++) {
               _mesa_unpack_index_span(ctx, width, GL_UNSIGNED_BYTE, dst,
                         type, (const GLvoid *) src, &ctx->Unpack, GL_TRUE);
               src += srcStride;
               dst += dstStride;
            }
         }
      }
      else {
         /* color texture */
         GLint img, row;
         for (img = 0; img < depth; img++) {
            const GLubyte *src = (const GLubyte *)
               _mesa_image_address(&ctx->Unpack, pixels, width, height,
                                   format, type, img, 0, 0);
            GLubyte *dst = texImage->Data + ((zoffsetb + img) * dstRectArea
                     + yoffsetb * texWidth + xoffsetb) * texComponents;
            for (row = 0; row < height; row++) {
               _mesa_unpack_ubyte_color_span(ctx, width, texFormat, dst,
                   format, type, (const GLvoid *) src, &ctx->Unpack, GL_TRUE);
               src += srcStride;
               dst += dstStride;
            }
         }
      }

      if (ctx->Driver.TexImage3D) {
         (*ctx->Driver.TexImage3D)(ctx, target, level, texImage->Format,
                                   GL_UNSIGNED_BYTE, texImage->Data,
                                   &_mesa_native_packing, texObj, texImage,
                                   &retain);
      }

      if (!retain && texImage->Data) {
         FREE(texImage->Data);
         texImage->Data = NULL;
      }
   }
}



/*
 * Read an RGBA image from the frame buffer.
 * This is used by glCopyTexSubImage[12]D().
 * Input:  ctx - the context
 *         x, y - lower left corner
 *         width, height - size of region to read
 * Return: pointer to block of GL_RGBA, GLubyte data.
 */
static GLubyte *
read_color_image( GLcontext *ctx, GLint x, GLint y,
                  GLsizei width, GLsizei height )
{
   GLint stride, i;
   GLubyte *image, *dst;

   image = (GLubyte *) MALLOC(width * height * 4 * sizeof(GLubyte));
   if (!image)
      return NULL;

   /* Select buffer to read from */
   (*ctx->Driver.SetReadBuffer)( ctx, ctx->ReadBuffer,
                                 ctx->Pixel.DriverReadBuffer );

   /* XXX TODO we have to apply pixel transfer ops here! */

   RENDER_START(ctx);

   dst = image;
   stride = width * 4 * sizeof(GLubyte);
   for (i = 0; i < height; i++) {
      gl_read_rgba_span( ctx, ctx->ReadBuffer, width, x, y + i,
                         (GLubyte (*)[4]) dst );
      dst += stride;
   }

   RENDER_FINISH(ctx);

   /* Read from draw buffer (the default) */
   (*ctx->Driver.SetReadBuffer)( ctx, ctx->DrawBuffer,
                                 ctx->Color.DriverDrawBuffer );

   return image;
}



void
_mesa_CopyTexImage1D( GLenum target, GLint level,
                      GLenum internalFormat,
                      GLint x, GLint y,
                      GLsizei width, GLint border )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glCopyTexImage1D");

   if (copytexture_error_check(ctx, 1, target, level, internalFormat,
                               width, 1, border))
      return;

   if (ctx->Pixel.MapColorFlag || ctx->Pixel.ScaleOrBiasRGBA
       || !ctx->Driver.CopyTexImage1D
       || !(*ctx->Driver.CopyTexImage1D)(ctx, target, level,
                         internalFormat, x, y, width, border))
   {
      struct gl_pixelstore_attrib unpackSave;

      /* get image from framebuffer */
      GLubyte *image  = read_color_image( ctx, x, y, width, 1 );
      if (!image) {
         gl_error( ctx, GL_OUT_OF_MEMORY, "glCopyTexImage1D" );
         return;
      }

      /* call glTexImage1D to redefine the texture */
      unpackSave = ctx->Unpack;
      ctx->Unpack = _mesa_native_packing;
      (*ctx->Exec->TexImage1D)( target, level, internalFormat, width,
                                border, GL_RGBA, GL_UNSIGNED_BYTE, image );
      ctx->Unpack = unpackSave;

      FREE(image);
   }
}



void
_mesa_CopyTexImage2D( GLenum target, GLint level, GLenum internalFormat,
                      GLint x, GLint y, GLsizei width, GLsizei height,
                      GLint border )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glCopyTexImage2D");

   if (copytexture_error_check(ctx, 2, target, level, internalFormat,
                               width, height, border))
      return;

   if (ctx->Pixel.MapColorFlag || ctx->Pixel.ScaleOrBiasRGBA
       || !ctx->Driver.CopyTexImage2D
       || !(*ctx->Driver.CopyTexImage2D)(ctx, target, level,
                         internalFormat, x, y, width, height, border))
   {
      struct gl_pixelstore_attrib unpackSave;

      /* get image from framebuffer */
      GLubyte *image  = read_color_image( ctx, x, y, width, height );
      if (!image) {
         gl_error( ctx, GL_OUT_OF_MEMORY, "glCopyTexImage2D" );
         return;
      }

      /* call glTexImage2D to redefine the texture */
      unpackSave = ctx->Unpack;
      ctx->Unpack = _mesa_native_packing;
      (ctx->Exec->TexImage2D)( target, level, internalFormat, width,
                      height, border, GL_RGBA, GL_UNSIGNED_BYTE, image );
      ctx->Unpack = unpackSave;

      FREE(image);
   }
}



void
_mesa_CopyTexSubImage1D( GLenum target, GLint level,
                         GLint xoffset, GLint x, GLint y, GLsizei width )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glCopyTexSubImage1D");

   if (copytexsubimage_error_check(ctx, 1, target, level,
                                   xoffset, 0, 0, width, 1))
      return;

   if (ctx->Pixel.MapColorFlag || ctx->Pixel.ScaleOrBiasRGBA
       || !ctx->Driver.CopyTexSubImage1D
       || !(*ctx->Driver.CopyTexSubImage1D)(ctx, target, level,
                                            xoffset, x, y, width)) {
      struct gl_texture_unit *texUnit;
      struct gl_texture_image *teximage;
      struct gl_pixelstore_attrib unpackSave;
      GLubyte *image;

      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      teximage = texUnit->CurrentD[1]->Image[level];
      assert(teximage);

      /* get image from frame buffer */
      image = read_color_image(ctx, x, y, width, 1);
      if (!image) {
         gl_error( ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage2D" );
         return;
      }

      /* now call glTexSubImage1D to do the real work */
      unpackSave = ctx->Unpack;
      ctx->Unpack = _mesa_native_packing;
      _mesa_TexSubImage1D(target, level, xoffset, width,
                          GL_RGBA, GL_UNSIGNED_BYTE, image);
      ctx->Unpack = unpackSave;

      FREE(image);
   }
}



void
_mesa_CopyTexSubImage2D( GLenum target, GLint level,
                         GLint xoffset, GLint yoffset,
                         GLint x, GLint y, GLsizei width, GLsizei height )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glCopyTexSubImage2D");

   if (copytexsubimage_error_check(ctx, 2, target, level,
                                   xoffset, yoffset, 0, width, height))
      return;

   if (ctx->Pixel.MapColorFlag || ctx->Pixel.ScaleOrBiasRGBA
       || !ctx->Driver.CopyTexSubImage2D
       || !(*ctx->Driver.CopyTexSubImage2D)(ctx, target, level,
                                xoffset, yoffset, x, y, width, height )) {
      struct gl_texture_unit *texUnit;
      struct gl_texture_image *teximage;
      struct gl_pixelstore_attrib unpackSave;
      GLubyte *image;

      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      teximage = texUnit->CurrentD[2]->Image[level];
      assert(teximage);

      /* get image from frame buffer */
      image = read_color_image(ctx, x, y, width, height);
      if (!image) {
         gl_error( ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage2D" );
         return;
      }

      /* now call glTexSubImage2D to do the real work */
      unpackSave = ctx->Unpack;
      ctx->Unpack = _mesa_native_packing;
      _mesa_TexSubImage2D(target, level, xoffset, yoffset, width, height,
                          GL_RGBA, GL_UNSIGNED_BYTE, image);
      ctx->Unpack = unpackSave;

      FREE(image);
   }
}



void
_mesa_CopyTexSubImage3D( GLenum target, GLint level,
                         GLint xoffset, GLint yoffset, GLint zoffset,
                         GLint x, GLint y, GLsizei width, GLsizei height )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glCopyTexSubImage3D");

   if (copytexsubimage_error_check(ctx, 3, target, level,
                    xoffset, yoffset, zoffset, width, height))
      return;

   if (ctx->Pixel.MapColorFlag || ctx->Pixel.ScaleOrBiasRGBA
       || !ctx->Driver.CopyTexSubImage3D
       || !(*ctx->Driver.CopyTexSubImage3D)(ctx, target, level,
                     xoffset, yoffset, zoffset, x, y, width, height )) {
      struct gl_texture_unit *texUnit;
      struct gl_texture_image *teximage;
      struct gl_pixelstore_attrib unpackSave;
      GLubyte *image;

      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      teximage = texUnit->CurrentD[3]->Image[level];
      assert(teximage);

      /* get image from frame buffer */
      image = read_color_image(ctx, x, y, width, height);
      if (!image) {
         gl_error( ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage2D" );
         return;
      }

      /* now call glTexSubImage2D to do the real work */
      unpackSave = ctx->Unpack;
      ctx->Unpack = _mesa_native_packing;
      _mesa_TexSubImage3D(target, level, xoffset, yoffset, zoffset,
                          width, height, 1, GL_RGBA, GL_UNSIGNED_BYTE, image);
      ctx->Unpack = unpackSave;

      FREE(image);
   }
}



void
_mesa_CompressedTexImage1DARB(GLenum target, GLint level,
                              GLenum internalFormat, GLsizei width,
                              GLint border, GLsizei imageSize,
                              const GLvoid *data)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glCompressedTexImage1DARB");

   switch (internalFormat) {
      case GL_COMPRESSED_ALPHA_ARB:
      case GL_COMPRESSED_LUMINANCE_ARB:
      case GL_COMPRESSED_LUMINANCE_ALPHA_ARB:
      case GL_COMPRESSED_INTENSITY_ARB:
      case GL_COMPRESSED_RGB_ARB:
      case GL_COMPRESSED_RGBA_ARB:
         gl_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage1DARB");
         return;
      default:
         /* silence compiler warning */
         ;
   }

   if (target == GL_TEXTURE_1D) {
      struct gl_texture_unit *texUnit;
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImage;
      GLsizei computedImageSize;

      if (texture_error_check(ctx, target, level, internalFormat,
                              GL_NONE, GL_NONE, 1, width, 1, 1, border)) {
         return;   /* error in texture image was detected */
      }

      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texObj = texUnit->CurrentD[1];
      texImage = texObj->Image[level];

      if (!texImage) {
         texImage = _mesa_alloc_texture_image();
         texObj->Image[level] = texImage;
         if (!texImage) {
            gl_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage1DARB");
            return;
         }
      }
      else if (texImage->Data) {
         FREE(texImage->Data);
         texImage->Data = NULL;
      }

      /* setup the teximage struct's fields */
      init_texture_image(ctx, texImage, width, 1, 1,
                         border, internalFormat);

      /* process the texture image */
      if (data) {
         GLboolean retain = GL_TRUE;
         GLboolean success = GL_FALSE;
         if (ctx->Driver.CompressedTexImage1D) {
            success = (*ctx->Driver.CompressedTexImage1D)(ctx, target, level,
                               imageSize, data, texObj, texImage, &retain);
         }
         if (retain || !success) {
            /* make internal copy of the texture image */
            computedImageSize = _mesa_compressed_image_size(ctx,
                                                        internalFormat,
                                                        1,    /* num dims */
                                                        width,
                                                        1,    /* height   */
                                                        1);   /* depth    */
            if (computedImageSize != imageSize) {
                gl_error(ctx, GL_INVALID_VALUE, "glCompressedTexImage1DARB(imageSize)");
                return;
            }
            texImage->Data = (GLubyte *) MALLOC(computedImageSize);
            if (texImage->Data) {
               MEMCPY(texImage->Data, data, computedImageSize);
            }
         }
         if (!retain && texImage->Data) {
            FREE(texImage->Data);
            texImage->Data = NULL;
         }
      }
      else {
         make_null_texture(texImage);
         if (ctx->Driver.CompressedTexImage1D) {
            GLboolean retain;
            (*ctx->Driver.CompressedTexImage1D)(ctx, target, level, 0,
                                                texImage->Data, texObj,
                                                texImage, &retain);
         }
      }

      /* state update */
      gl_put_texobj_on_dirty_list( ctx, texObj );
      ctx->NewState |= NEW_TEXTURING;
   }
   else if (target == GL_PROXY_TEXTURE_1D) {
      /* Proxy texture: check for errors and update proxy state */
      GLenum error = texture_error_check(ctx, target, level, internalFormat,
                                    GL_NONE, GL_NONE, 1, width, 1, 1, border);
      if (!error && ctx->Driver.TestProxyTexImage) {
         error = !(*ctx->Driver.TestProxyTexImage)(ctx, target, level,
                                             internalFormat, GL_NONE, GL_NONE,
                                             width, 1, 1, border);
      }
      if (error) {
         /* if error, clear all proxy texture image parameters */
         if (level>=0 && level<ctx->Const.MaxTextureLevels) {
            clear_proxy_teximage(ctx->Texture.Proxy1D->Image[level]);
         }
      }
      else {
         /* if no error, update proxy texture image parameters */
         init_texture_image(ctx, ctx->Texture.Proxy1D->Image[level],
                            width, 1, 1, border, internalFormat);
      }
   }
   else {
      gl_error( ctx, GL_INVALID_ENUM, "glCompressedTexImage1DARB(target)" );
      return;
   }
}


void
_mesa_CompressedTexImage2DARB(GLenum target, GLint level,
                              GLenum internalFormat, GLsizei width,
                              GLsizei height, GLint border, GLsizei imageSize,
                              const GLvoid *data)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glCompressedTexImage2DARB");

   switch (internalFormat) {
      case GL_COMPRESSED_ALPHA_ARB:
      case GL_COMPRESSED_LUMINANCE_ARB:
      case GL_COMPRESSED_LUMINANCE_ALPHA_ARB:
      case GL_COMPRESSED_INTENSITY_ARB:
      case GL_COMPRESSED_RGB_ARB:
      case GL_COMPRESSED_RGBA_ARB:
         gl_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage2DARB");
         return;
      default:
         /* silence compiler warning */
         ;
   }

   if (target==GL_TEXTURE_2D ||
       (ctx->Extensions.HaveTextureCubeMap &&
        target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
        target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB)) {
      struct gl_texture_unit *texUnit;
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImage;
      GLsizei computedImageSize;

      if (texture_error_check(ctx, target, level, internalFormat,
                              GL_NONE, GL_NONE, 1, width, height, 1, border)) {
         return;   /* error in texture image was detected */
      }

      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texObj = texUnit->CurrentD[2];
      texImage = texObj->Image[level];

      if (!texImage) {
         texImage = _mesa_alloc_texture_image();
         texObj->Image[level] = texImage;
         if (!texImage) {
            gl_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage2DARB");
            return;
         }
      }
      else if (texImage->Data) {
         FREE(texImage->Data);
         texImage->Data = NULL;
      }

      /* setup the teximage struct's fields */
      init_texture_image(ctx, texImage, width, height, 1, border, internalFormat);

      /* process the texture image */
      if (data) {
         GLboolean retain = GL_TRUE;
         GLboolean success = GL_FALSE;
         if (ctx->Driver.CompressedTexImage2D) {
            success = (*ctx->Driver.CompressedTexImage2D)( ctx,
                                                           target,
                                                           level,
                                                           imageSize,
                                                           data,
                                                           texObj,
                                                           texImage,
                                                           &retain);
         }
         if (retain || !success) {
            /* make internal copy of the texture image */
            computedImageSize = _mesa_compressed_image_size(ctx,
                                                           internalFormat,
                                                           2,    /* num dims */
                                                           width,
                                                           height,
                                                           1);   /* depth    */
            if (computedImageSize != imageSize) {
                gl_error(ctx, GL_INVALID_VALUE, "glCompressedTexImage2DARB(imageSize)");
                return;
            }
            texImage->Data = (GLubyte *) MALLOC(computedImageSize);
            if (texImage->Data) {
               MEMCPY(texImage->Data, data, computedImageSize);
            }
         }
         if (!retain && texImage->Data) {
            FREE(texImage->Data);
            texImage->Data = NULL;
         }
      }
      else {
         make_null_texture(texImage);
         if (ctx->Driver.CompressedTexImage2D) {
            GLboolean retain;
            (*ctx->Driver.CompressedTexImage2D)( ctx, target, level, 0,
                                                 texImage->Data, texObj,
                                                 texImage, &retain);
         }
      }

      /* state update */
      gl_put_texobj_on_dirty_list( ctx, texObj );
      ctx->NewState |= NEW_TEXTURING;
   }
   else if (target == GL_PROXY_TEXTURE_2D) {
      /* Proxy texture: check for errors and update proxy state */
      GLenum error = texture_error_check(ctx, target, level, internalFormat,
                                GL_NONE, GL_NONE, 2, width, height, 1, border);
      if (!error && ctx->Driver.TestProxyTexImage) {
         error = !(*ctx->Driver.TestProxyTexImage)(ctx, target, level,
                                              internalFormat, GL_NONE, GL_NONE,
                                              width, height, 1, border);
      }
      if (error) {
         /* if error, clear all proxy texture image parameters */
         if (level>=0 && level<ctx->Const.MaxTextureLevels) {
            clear_proxy_teximage(ctx->Texture.Proxy2D->Image[level]);
         }
      }
      else {
         /* if no error, update proxy texture image parameters */
         init_texture_image(ctx, ctx->Texture.Proxy2D->Image[level],
                            width, 1, 1, border, internalFormat);
      }
   }
   else {
      gl_error( ctx, GL_INVALID_ENUM, "glCompressedTexImage2DARB(target)" );
      return;
   }
}


void
_mesa_CompressedTexImage3DARB(GLenum target, GLint level,
                              GLenum internalFormat, GLsizei width,
                              GLsizei height, GLsizei depth, GLint border,
                              GLsizei imageSize, const GLvoid *data)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glCompressedTexImage3DARB");

   switch (internalFormat) {
      case GL_COMPRESSED_ALPHA_ARB:
      case GL_COMPRESSED_LUMINANCE_ARB:
      case GL_COMPRESSED_LUMINANCE_ALPHA_ARB:
      case GL_COMPRESSED_INTENSITY_ARB:
      case GL_COMPRESSED_RGB_ARB:
      case GL_COMPRESSED_RGBA_ARB:
         gl_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage3DARB");
         return;
      default:
         /* silence compiler warning */
         ;
   }

   if (target == GL_TEXTURE_3D) {
      struct gl_texture_unit *texUnit;
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImage;
      GLsizei computedImageSize;

      if (texture_error_check(ctx, target, level, internalFormat,
                          GL_NONE, GL_NONE, 1, width, height, depth, border)) {
         return;   /* error in texture image was detected */
      }

      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texObj = texUnit->CurrentD[3];
      texImage = texObj->Image[level];

      if (!texImage) {
         texImage = _mesa_alloc_texture_image();
         texObj->Image[level] = texImage;
         if (!texImage) {
            gl_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage3DARB");
            return;
         }
      }
      else if (texImage->Data) {
         FREE(texImage->Data);
         texImage->Data = NULL;
      }

      /* setup the teximage struct's fields */
      init_texture_image(ctx, texImage, width, height, depth,
                         border, internalFormat);

      /* process the texture image */
      if (data) {
         GLboolean retain = GL_TRUE;
         GLboolean success = GL_FALSE;
         if (ctx->Driver.CompressedTexImage3D) {
            success = (*ctx->Driver.CompressedTexImage3D)(ctx, target, level,
                                                          imageSize, data,
                                                          texObj, texImage,
                                                          &retain);
         }
         if (retain || !success) {
            /* make internal copy of the texture image */
            computedImageSize = _mesa_compressed_image_size(ctx,
                                                            internalFormat,
                                                            3,  /* num dims */
                                                            width,
                                                            height,
                                                            depth);
            if (computedImageSize != imageSize) {
                gl_error(ctx, GL_INVALID_VALUE, "glCompressedTexImage3DARB(imageSize)");
                return;
            }
            texImage->Data = (GLubyte *) MALLOC(computedImageSize);
            if (texImage->Data) {
               MEMCPY(texImage->Data, data, computedImageSize);
            }
         }
         if (!retain && texImage->Data) {
            FREE(texImage->Data);
            texImage->Data = NULL;
         }
      }
      else {
         make_null_texture(texImage);
         if (ctx->Driver.CompressedTexImage3D) {
            GLboolean retain;
            (*ctx->Driver.CompressedTexImage3D)( ctx, target, level, 0,
                                                 texImage->Data, texObj,
                                                 texImage, &retain);
         }
      }

      /* state update */
      gl_put_texobj_on_dirty_list( ctx, texObj );
      ctx->NewState |= NEW_TEXTURING;
   }
   else if (target == GL_PROXY_TEXTURE_3D) {
      /* Proxy texture: check for errors and update proxy state */
      GLenum error = texture_error_check(ctx, target, level, internalFormat,
                            GL_NONE, GL_NONE, 1, width, height, depth, border);
      if (!error && ctx->Driver.TestProxyTexImage) {
         error = !(*ctx->Driver.TestProxyTexImage)(ctx, target, level,
                                             internalFormat, GL_NONE, GL_NONE,
                                             width, height, depth, border);
      }
      if (error) {
         /* if error, clear all proxy texture image parameters */
         if (level>=0 && level<ctx->Const.MaxTextureLevels) {
            clear_proxy_teximage(ctx->Texture.Proxy3D->Image[level]);
         }
      }
      else {
         /* if no error, update proxy texture image parameters */
         init_texture_image(ctx, ctx->Texture.Proxy3D->Image[level],
                            width, 1, 1, border, internalFormat);
      }
   }
   else {
      gl_error( ctx, GL_INVALID_ENUM, "glCompressedTexImage3DARB(target)" );
      return;
   }
}


void
_mesa_CompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format,
                                 GLsizei imageSize, const GLvoid *data)
{
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLboolean success = GL_FALSE;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glCompressedTexSubImage1DARB");

   if (subtexture_error_check(ctx, 1, target, level, xoffset, 0, 0,
                              width, 1, 1, format, GL_NONE)) {
      return;   /* error was detected */
   }

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = texObj->Image[level];
   assert(texImage);

   if (width == 0 || !data)
      return;  /* no-op, not an error */

   if (ctx->Driver.CompressedTexSubImage1D) {
      success = (*ctx->Driver.CompressedTexSubImage1D)(ctx, target, level,
                   xoffset, width, format, imageSize, data, texObj, texImage);
   }
   if (!success) {
      /* XXX what else can we do? */
      gl_problem(ctx, "glCompressedTexSubImage1DARB failed!");
      return;
   }
}


void
_mesa_CompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLsizei imageSize,
                                 const GLvoid *data)
{
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLboolean success = GL_FALSE;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glCompressedTexSubImage2DARB");

   if (subtexture_error_check(ctx, 2, target, level, xoffset, yoffset, 0,
                              width, height, 1, format, GL_NONE)) {
      return;   /* error was detected */
   }

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = texObj->Image[level];
   assert(texImage);

   if (width == 0 || height == 0 || !data)
      return;  /* no-op, not an error */

   if (ctx->Driver.CompressedTexSubImage2D) {
      success = (*ctx->Driver.CompressedTexSubImage2D)(ctx, target, level,
                                       xoffset, yoffset, width, height, format,
                                       imageSize, data, texObj, texImage);
   }
   if (!success) {
      /* XXX what else can we do? */
      gl_problem(ctx, "glCompressedTexSubImage2DARB failed!");
      return;
   }
}


void
_mesa_CompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLint zoffset, GLsizei width,
                                 GLsizei height, GLsizei depth, GLenum format,
                                 GLsizei imageSize, const GLvoid *data)
{
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLboolean success = GL_FALSE;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glCompressedTexSubImage3DARB");

   if (subtexture_error_check(ctx, 3, target, level, xoffset, yoffset, zoffset,
                              width, height, depth, format, GL_NONE)) {
      return;   /* error was detected */
   }

   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = texObj->Image[level];
   assert(texImage);

   if (width == 0 || height == 0 || depth == 0 || !data)
      return;  /* no-op, not an error */

   if (ctx->Driver.CompressedTexSubImage3D) {
      success = (*ctx->Driver.CompressedTexSubImage3D)(ctx, target, level,
                               xoffset, yoffset, zoffset, width, height, depth,
                               format, imageSize, data, texObj, texImage);
   }
   if (!success) {
      /* XXX what else can we do? */
      gl_problem(ctx, "glCompressedTexSubImage3DARB failed!");
      return;
   }
}


void
_mesa_GetCompressedTexImageARB(GLenum target, GLint level, GLvoid *img)
{
   const struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetCompressedTexImageARB");

   if (level < 0 || level >= ctx->Const.MaxTextureLevels) {
      gl_error( ctx, GL_INVALID_VALUE, "glGetCompressedTexImageARB(level)" );
      return;
   }

   switch (target) {
      case GL_TEXTURE_1D:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentD[1];
         texImage = texObj->Image[level];
         break;
      case GL_TEXTURE_2D:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentD[2];
         texImage = texObj->Image[level];
         break;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap;
         texImage = texObj->Image[level];
         break;
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap;
         texImage = texObj->NegX[level];
         break;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap;
         texImage = texObj->PosY[level];
         break;
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap;
         texImage = texObj->NegY[level];
         break;
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap;
         texImage = texObj->PosZ[level];
         break;
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentCubeMap;
         texImage = texObj->NegZ[level];
         break;
      case GL_TEXTURE_3D:
         texObj = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentD[3];
         texImage = texObj->Image[level];
         break;
      default:
         gl_error(ctx, GL_INVALID_ENUM, "glGetCompressedTexImageARB(target)");
         return;
   }

   if (!texImage) {
      /* invalid mipmap level */
      gl_error(ctx, GL_INVALID_VALUE, "glGetCompressedTexImageARB(level)");
      return;
   }

   if (!texImage->IsCompressed) {
      gl_error(ctx, GL_INVALID_OPERATION, "glGetCompressedTexImageARB");
      return;
   }

   if (!img)
      return;

   if (ctx->Driver.GetCompressedTexImage) {
      (*ctx->Driver.GetCompressedTexImage)(ctx, target, level, img, texObj,
                                           texImage);
   }
   else {
      gl_problem(ctx, "Driver doesn't implement GetCompressedTexImage");
   }
}
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/extras/Mesa/src/teximage.c,v 1.24 2003/10/22 15:27:40 tsi Exp $ */
d4 1
a4 1
 * Version:  5.0.2
d6 1
a6 1
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
d26 4
a31 1
#include "convolve.h"
d33 1
a33 2
#include "imports.h"
#include "macros.h"
d35 1
a35 2
#include "state.h"
#include "texcompress.h"
d39 2
a40 2
#include "texstore.h"
#include "mtypes.h"
d46 1
a46 1
 * Mesa's native texture datatype is GLchan.  Native formats are
d53 2
a54 2
#if 0
static void PrintTexture(GLcontext *ctx, const struct gl_texture_image *img)
a55 3
#if CHAN_TYPE == GL_FLOAT
   _mesa_problem(NULL, "PrintTexture doesn't support float channels");
#else
d57 1
a57 1
   const GLchan *data = (const GLchan *) img->Data;
d60 1
a60 1
      _mesa_printf("No texture data\n");
d81 1
a81 1
         _mesa_problem(NULL, "error in PrintTexture\n");
d85 1
d89 1
a89 1
            _mesa_printf("%02x  ", data[0]);
d91 1
a91 1
            _mesa_printf("%02x%02x  ", data[0], data[1]);
d93 1
a93 1
            _mesa_printf("%02x%02x%02x  ", data[0], data[1], data[2]);
d95 2
a96 2
            _mesa_printf("%02x%02x%02x%02x  ", data[0], data[1], data[2], data[3]);
         data += (img->RowStride - img->Width) * c;
d98 1
a98 1
      _mesa_printf("\n");
a99 1
#endif
d108 1
a108 1
 * If n < 0 return -1.
d116 1
a116 1
   if (n < 0) {
a137 4
 *
 * This is the format which is used during texture application (i.e. the
 * texture format and env mode determine the arithmetic used.
 *
d143 10
a152 4
   /*
    * Ask the driver for the base format, if it doesn't
    * know, it will return -1;
    */
d209 1
a209 61
         if (ctx->Extensions.EXT_paletted_texture)
            return GL_COLOR_INDEX;
         else
            return -1;
      case GL_DEPTH_COMPONENT:
      case GL_DEPTH_COMPONENT16_SGIX:
      case GL_DEPTH_COMPONENT24_SGIX:
      case GL_DEPTH_COMPONENT32_SGIX:
         if (ctx->Extensions.SGIX_depth_texture)
            return GL_DEPTH_COMPONENT;
         else
            return -1;

      /* GL_ARB_texture_compression */
      case GL_COMPRESSED_ALPHA:
         if (ctx->Extensions.ARB_texture_compression)
            return GL_ALPHA;
         else
            return -1;
      case GL_COMPRESSED_LUMINANCE:
         if (ctx->Extensions.ARB_texture_compression)
            return GL_LUMINANCE;
         else
            return -1;
      case GL_COMPRESSED_LUMINANCE_ALPHA:
         if (ctx->Extensions.ARB_texture_compression)
            return GL_LUMINANCE_ALPHA;
         else
            return -1;
      case GL_COMPRESSED_INTENSITY:
         if (ctx->Extensions.ARB_texture_compression)
            return GL_INTENSITY;
         else
            return -1;
      case GL_COMPRESSED_RGB:
         if (ctx->Extensions.ARB_texture_compression)
            return GL_RGB;
         else
            return -1;
      case GL_COMPRESSED_RGBA:
         if (ctx->Extensions.ARB_texture_compression)
            return GL_RGBA;
         else
            return -1;
      case GL_COMPRESSED_RGB_FXT1_3DFX:
         if (ctx->Extensions.TDFX_texture_compression_FXT1)
            return GL_RGB;
         else
            return -1;
      case GL_COMPRESSED_RGBA_FXT1_3DFX:
         if (ctx->Extensions.TDFX_texture_compression_FXT1)
            return GL_RGBA;
         else
            return -1;

      case GL_YCBCR_MESA:
         if (ctx->Extensions.MESA_ycbcr_texture)
            return GL_YCBCR_MESA;
         else
            return -1;

d216 1
d218 4
a221 2
 * Test if the given image format is a color/rgba format.  That is,
 * not color index, depth, stencil, etc.
d223 2
a224 2
static GLboolean
is_color_format(GLenum format)
d232 1
d239 1
d248 1
d254 1
d264 1
d274 1
a274 12
         return GL_TRUE;
      case GL_YCBCR_MESA:  /* not considered to be RGB */
      default:
         return GL_FALSE;
   }
}


static GLboolean
is_index_format(GLenum format)
{
   switch (format) {
d282 1
a282 1
         return GL_TRUE;
d284 1
a284 1
         return GL_FALSE;
d289 3
a291 4
/**
 * Return GL_TRUE if internalFormat is a supported compressed format,
 * return GL_FALSE otherwise.
 * \param - internalFormat - the internal format token provided by the user
d294 1
a294 1
is_compressed_format(GLenum internalFormat)
d296 4
a299 7
   switch (internalFormat) {
      case GL_COMPRESSED_RGB_FXT1_3DFX:
      case GL_COMPRESSED_RGBA_FXT1_3DFX:
         return GL_TRUE;
      default:
         return GL_FALSE;
   }
d303 5
a307 9
/*
 * Store a gl_texture_image pointer in a gl_texture_object structure
 * according to the target and level parameters.
 * This was basically prompted by the introduction of cube maps.
 */
void
_mesa_set_tex_image(struct gl_texture_object *tObj,
                    GLenum target, GLint level,
                    struct gl_texture_image *texImage)
a311 1
      case GL_TEXTURE_1D:
a312 1
      case GL_TEXTURE_3D:
a332 4
      case GL_TEXTURE_RECTANGLE_NV:
         ASSERT(level == 0);
         tObj->Image[level] = texImage;
         return;
d334 1
a334 1
         _mesa_problem(NULL, "bad target in _mesa_set_tex_image()");
a339 1

d351 34
d388 2
a389 2
   if (teximage->Data && !teximage->IsClientData) {
      MESA_PBUFFER_FREE( teximage->Data );
d396 1
d398 21
a418 10
 * Return GL_TRUE if the target is a proxy target.
 */
static GLboolean
is_proxy_target(GLenum target)
{
   return (target == GL_PROXY_TEXTURE_1D ||
           target == GL_PROXY_TEXTURE_2D ||
           target == GL_PROXY_TEXTURE_3D ||
           target == GL_PROXY_TEXTURE_CUBE_MAP_ARB ||
           target == GL_PROXY_TEXTURE_RECTANGLE_NV);
d422 1
d428 1
a428 1
_mesa_select_tex_object(GLcontext *ctx, const struct gl_texture_unit *texUnit,
d433 1
a433 1
         return texUnit->Current1D;
d437 1
a437 1
         return texUnit->Current2D;
d441 1
a441 1
         return texUnit->Current3D;
d451 1
a451 1
         return ctx->Extensions.ARB_texture_cube_map
d454 1
a454 1
         return ctx->Extensions.ARB_texture_cube_map
a455 6
      case GL_TEXTURE_RECTANGLE_NV:
         return ctx->Extensions.NV_texture_rectangle
                ? texUnit->CurrentRect : NULL;
      case GL_PROXY_TEXTURE_RECTANGLE_NV:
         return ctx->Extensions.NV_texture_rectangle
                ? ctx->Texture.ProxyRect : NULL;
d457 1
a457 1
         _mesa_problem(NULL, "bad target in _mesa_select_tex_object()");
a471 1
   ASSERT(level < MAX_TEXTURE_LEVELS);
d474 1
a474 1
         return texUnit->Current1D->Image[level];
d478 1
a478 1
         return texUnit->Current2D->Image[level];
d482 1
a482 1
         return texUnit->Current3D->Image[level];
d486 1
a486 1
         if (ctx->Extensions.ARB_texture_cube_map)
d491 1
a491 1
         if (ctx->Extensions.ARB_texture_cube_map)
d496 1
a496 1
         if (ctx->Extensions.ARB_texture_cube_map)
d501 1
a501 1
         if (ctx->Extensions.ARB_texture_cube_map)
d506 1
a506 1
         if (ctx->Extensions.ARB_texture_cube_map)
d511 1
a511 1
         if (ctx->Extensions.ARB_texture_cube_map)
d516 1
a516 1
         if (ctx->Extensions.ARB_texture_cube_map)
a519 16
      case GL_TEXTURE_RECTANGLE_NV:
         if (ctx->Extensions.NV_texture_rectangle) {
            ASSERT(level == 0);
            return texUnit->CurrentRect->Image[level];
         }
         else {
            return NULL;
         }
      case GL_PROXY_TEXTURE_RECTANGLE_NV:
         if (ctx->Extensions.NV_texture_rectangle) {
            ASSERT(level == 0);
            return ctx->Texture.ProxyRect->Image[level];
         }
         else {
            return NULL;
         }
d521 1
a521 1
         _mesa_problem(ctx, "bad target in _mesa_select_tex_image()");
d527 12
d540 3
a542 2
 * Return the maximum number of allows mipmap levels for the given
 * texture target.
d544 5
a548 2
GLint
_mesa_max_texture_levels(GLcontext *ctx, GLenum target)
d550 126
a675 24
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
      return ctx->Const.MaxTextureLevels;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      return ctx->Const.Max3DTextureLevels;
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
      return ctx->Const.MaxCubeTextureLevels;
      break;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_PROXY_TEXTURE_RECTANGLE_NV:
      return 1;
      break;
   default:
      return 0; /* bad target */
a680 1
#if 000 /* not used anymore */
d684 1
a684 1
 * spec.
d686 2
a687 2
static GLubyte *
make_null_texture(GLint width, GLint height, GLint depth, GLenum format)
d689 10
a698 3
   const GLint components = _mesa_components_in_format(format);
   const GLint numPixels = width * height * depth;
   GLubyte *data = (GLubyte *) MALLOC(numPixels * components * sizeof(GLubyte));
a699 1
#ifdef DEBUG
d705 1
a705 1
   if (data) {
d717 10
a726 11
      GLubyte *imgPtr = data;
      GLint h, i, j, k;
      for (h = 0; h < depth; h++) {
         for (i = 0; i < height; i++) {
            GLint srcRow = 7 - (i % 8);
            for (j = 0; j < width; j++) {
               GLint srcCol = j % 32;
               GLubyte texel = (message[srcRow][srcCol]=='X') ? 255 : 70;
               for (k = 0; k < components; k++) {
                  *imgPtr++ = texel;
               }
a730 3
#endif

   return data;
a731 1
#endif
a735 1
 * Reset the fields of a gl_texture_image struct to zero.
a737 3
 * It's also used in glTexImage[123]D as a safeguard to be sure all
 * required fields get initialized properly by the Driver.TexImage[123]D
 * functions.
d740 1
a740 1
clear_teximage_fields(struct gl_texture_image *img)
a748 1
   img->RowStride = 0;
a755 2
   img->TexFormat = &_mesa_null_texformat;
   img->FetchTexel = NULL;
d758 1
a758 53
}


/*
 * Initialize basic fields of the gl_texture_image struct.
 */
void
_mesa_init_teximage_fields(GLcontext *ctx, GLenum target,
                           struct gl_texture_image *img,
                           GLsizei width, GLsizei height, GLsizei depth,
                           GLint border, GLenum internalFormat)
{
   ASSERT(img);
   img->Format = _mesa_base_tex_format( ctx, internalFormat );
   ASSERT(img->Format > 0);
   img->IntFormat = internalFormat;
   img->Border = border;
   img->Width = width;
   img->Height = height;
   img->Depth = depth;
   img->RowStride = width;
   img->WidthLog2 = logbase2(width - 2 * border);
   if (height == 1)  /* 1-D texture */
      img->HeightLog2 = 0;
   else
      img->HeightLog2 = logbase2(height - 2 * border);
   if (depth == 1)   /* 2-D texture */
      img->DepthLog2 = 0;
   else
      img->DepthLog2 = logbase2(depth - 2 * border);
   img->Width2 = 1 << img->WidthLog2;
   img->Height2 = 1 << img->HeightLog2;
   img->Depth2 = 1 << img->DepthLog2;
   img->MaxLog2 = MAX2(img->WidthLog2, img->HeightLog2);
   img->IsCompressed = is_compressed_format(internalFormat);
   if (img->IsCompressed)
      img->CompressedSize = _mesa_compressed_texture_size(ctx, width, height,
                                                       depth, internalFormat);
   else
      img->CompressedSize = 0;

   /* Compute Width/Height/DepthScale for mipmap lod computation */
   if (target == GL_TEXTURE_RECTANGLE_NV) {
      /* scale = 1.0 since texture coords directly map to texels */
      img->WidthScale = 1.0;
      img->HeightScale = 1.0;
      img->DepthScale = 1.0;
   }
   else {
      img->WidthScale = (GLfloat) img->Width;
      img->HeightScale = (GLfloat) img->Height;
      img->DepthScale = (GLfloat) img->Depth;
   }
d778 1
a778 1
   GLint maxLevels = 0, maxTextureSize;
d781 3
a783 8
      if (target == GL_PROXY_TEXTURE_1D) {
         isProxy = GL_TRUE;
      }
      else if (target == GL_TEXTURE_1D) {
         isProxy = GL_FALSE;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage1D(target)" );
a785 1
      maxLevels = ctx->Const.MaxTextureLevels;
d788 7
a794 44
      if (target == GL_PROXY_TEXTURE_2D) {
         isProxy = GL_TRUE;
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_TEXTURE_2D) {
         isProxy = GL_FALSE;
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage2D(target)");
            return GL_TRUE;
         }
         isProxy = GL_TRUE;
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
               target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage2D(target)");
            return GL_TRUE;
         }
         isProxy = GL_FALSE;
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else if (target == GL_PROXY_TEXTURE_RECTANGLE_NV) {
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage2D(target)");
            return GL_TRUE;
         }
         isProxy = GL_TRUE;
         maxLevels = 1;
      }
      else if (target == GL_TEXTURE_RECTANGLE_NV) {
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage2D(target)");
            return GL_TRUE;
         }
         isProxy = GL_FALSE;
         maxLevels = 1;
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage2D(target)");
         return GL_TRUE;
d798 3
a800 8
      if (target == GL_PROXY_TEXTURE_3D) {
         isProxy = GL_TRUE;
      }
      else if (target == GL_TEXTURE_3D) {
         isProxy = GL_FALSE;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage3D(target)" );
a802 1
      maxLevels = ctx->Const.Max3DTextureLevels;
d805 1
a805 1
      _mesa_problem( ctx, "bad dims in texture_error_check" );
a808 3
   ASSERT(maxLevels > 0);
   maxTextureSize = 1 << (maxLevels - 1);

d812 3
a814 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%dD(border=%d)", dimensions, border);
a817 4
   if ((target == GL_TEXTURE_RECTANGLE_NV ||
        target == GL_PROXY_TEXTURE_RECTANGLE_NV) && border != 0) {
      return GL_TRUE;
   }
d820 1
a820 11
   if (target == GL_TEXTURE_RECTANGLE_NV ||
       target == GL_PROXY_TEXTURE_RECTANGLE_NV) {
      if (width < 1 || width > ctx->Const.MaxTextureRectSize) {
         if (!isProxy) {
            _mesa_error(ctx, GL_INVALID_VALUE,
                        "glTexImage%dD(width=%d)", dimensions, width);
         }
         return GL_TRUE;
      }
   }
   else if (width < 2 * border || width > 2 + maxTextureSize
d823 3
a825 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%dD(width=%d)", dimensions, width);
d831 2
a832 12
   if (target == GL_TEXTURE_RECTANGLE_NV ||
       target == GL_PROXY_TEXTURE_RECTANGLE_NV) {
      if (height < 1 || height > ctx->Const.MaxTextureRectSize) {
         if (!isProxy) {
            _mesa_error(ctx, GL_INVALID_VALUE,
                        "glTexImage%dD(height=%d)", dimensions, height);
         }
         return GL_TRUE;
      }
   }
   else if (dimensions >= 2) {
      if (height < 2 * border || height > 2 + maxTextureSize
d835 3
a837 2
            _mesa_error(ctx, GL_INVALID_VALUE,
                        "glTexImage%dD(height=%d)", dimensions, height);
d848 1
a848 1
            _mesa_error(ctx, GL_INVALID_VALUE, "glTexImage2D(width != height)");
d856 1
a856 1
      if (depth < 2 * border || depth > 2 + maxTextureSize
d859 1
a859 2
            _mesa_error( ctx, GL_INVALID_VALUE,
                         "glTexImage3D(depth=%d)", depth );
d866 5
a870 8
   if (target == GL_TEXTURE_RECTANGLE_NV ||
       target == GL_PROXY_TEXTURE_RECTANGLE_NV) {
      if (level != 0) {
         if (!isProxy) {
            _mesa_error(ctx, GL_INVALID_VALUE,
                        "glTexImage2D(level=%d)", level);
         }
         return GL_TRUE;
d872 1
d874 3
a876 1
   else if (level < 0 || level >= maxLevels) {
d878 3
a880 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%dD(level=%d)", dimensions, level);
d885 10
a894 5
   /* For cube map, width must equal height */
   if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
       target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
      if (width != height) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexImage2D(width != height)");
d899 6
a904 85
   if (_mesa_base_tex_format(ctx, internalFormat) < 0) {
      if (!isProxy) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%dD(internalFormat=0x%x)",
                     dimensions, internalFormat);
      }
      return GL_TRUE;
   }

   if (!_mesa_is_legal_format_and_type(format, type)) {
      /* Yes, generate GL_INVALID_OPERATION, not GL_INVALID_ENUM, if there
       * is a type/format mismatch.  See 1.2 spec page 94, sec 3.6.4.
       */
      if (!isProxy) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexImage%dD(format or type)", dimensions);
      }
      return GL_TRUE;
   }

   if (format == GL_YCBCR_MESA || internalFormat == GL_YCBCR_MESA) {
      ASSERT(ctx->Extensions.MESA_ycbcr_texture);
      if (format != GL_YCBCR_MESA ||
          internalFormat != GL_YCBCR_MESA ||
          (type != GL_UNSIGNED_SHORT_8_8_MESA &&
          type != GL_UNSIGNED_SHORT_8_8_REV_MESA)) {
         char message[100];
         _mesa_sprintf(message,
                 "glTexImage%d(format/type/internalFormat YCBCR mismatch",
                 dimensions);
         _mesa_error(ctx, GL_INVALID_ENUM, message);
         return GL_TRUE; /* error */
      }
      if (target != GL_TEXTURE_2D &&
          target != GL_PROXY_TEXTURE_2D &&
          target != GL_TEXTURE_RECTANGLE_NV &&
          target != GL_PROXY_TEXTURE_RECTANGLE_NV) {
         if (!isProxy)
            _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage(target)");
         return GL_TRUE;
      }
      if (border != 0) {
         if (!isProxy) {
            char message[100];
            _mesa_sprintf(message,
                    "glTexImage%d(format=GL_YCBCR_MESA and border=%d)",
                    dimensions, border);
            _mesa_error(ctx, GL_INVALID_VALUE, message);
         }
         return GL_TRUE;
      }
   }

   if (is_compressed_format(internalFormat)) {
      if (target == GL_TEXTURE_2D || target == GL_PROXY_TEXTURE_2D) {
         /* OK */
      }
      else if (ctx->Extensions.ARB_texture_cube_map &&
               (target == GL_PROXY_TEXTURE_CUBE_MAP ||
                (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X &&
                 target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z))) {
         /* OK */
      }
      else {
         if (!isProxy) {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexImage%d(target)", dimensions);
            return GL_TRUE;
         }
      }
      if (border != 0) {
         if (!isProxy) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glTexImage%D(border!=0)", dimensions);
         }
         return GL_TRUE;
      }
   }

   /* if we get here, the parameters are OK */
   return GL_FALSE;
}



a919 1
   GLint maxLevels = 0;
d922 2
a923 5
      if (target == GL_TEXTURE_1D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexSubImage1D(target)" );
d928 7
a934 8
      if (ctx->Extensions.ARB_texture_cube_map &&
          target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
          target <=GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else if (ctx->Extensions.NV_texture_rectangle &&
               target == GL_TEXTURE_RECTANGLE_NV) {
         maxLevels = 1;
d936 2
a937 5
      else if (target == GL_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexSubImage2D(target)" );
d942 2
a943 5
      if (target == GL_TEXTURE_3D) {
         maxLevels = ctx->Const.Max3DTextureLevels;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexSubImage3D(target)" );
d948 1
a948 1
      _mesa_problem( ctx, "bad dims in texture_error_check" );
d952 2
a953 4
   ASSERT(maxLevels > 0);

   if (level < 0 || level >= maxLevels) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexSubImage2D(level=%d)", level);
d958 3
a960 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexSubImage%dD(width=%d)", dimensions, width);
d964 3
a966 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexSubImage%dD(height=%d)", dimensions, height);
d970 3
a972 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage%dD(depth=%d)", dimensions, depth);
d976 1
a976 2
   destTex = _mesa_select_tex_image(ctx, texUnit, target, level);

d978 1
a978 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexSubImage2D");
d983 1
a983 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage1/2/3D(xoffset)");
d987 1
a987 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage1/2/3D(xoffset+width)");
d992 1
a992 1
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage2/3D(yoffset)");
d996 1
a996 1
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage2/3D(yoffset+height)");
d1002 1
a1002 1
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage3D(zoffset)");
d1005 2
a1006 2
      if (zoffset + depth  > (GLint) (destTex->Depth + destTex->Border)) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage3D(zoffset+depth)");
d1011 5
a1015 30
   if (!_mesa_is_legal_format_and_type(format, type)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glTexSubImage%dD(format or type)", dimensions);
      return GL_TRUE;
   }

   if (destTex->IsCompressed) {
      const struct gl_texture_unit *texUnit;
      const struct gl_texture_image *texImage;
      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);

      if (target == GL_TEXTURE_2D || target == GL_PROXY_TEXTURE_2D) {
         /* OK */
      }
      else if (ctx->Extensions.ARB_texture_cube_map &&
               (target == GL_PROXY_TEXTURE_CUBE_MAP ||
                (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X &&
                 target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z))) {
         /* OK */
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexSubImage%D(target)", dimensions);
         return GL_TRUE;
      }
      /* offset must be multiple of 4 */
      if ((xoffset & 3) || (yoffset & 3)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexSubImage%D(xoffset or yoffset)", dimensions);
a1017 11
      /* size must be multiple of 4 or equal to whole texture size */
      if ((width & 3) && (GLuint) width != texImage->Width) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexSubImage%D(width)", dimensions);
         return GL_TRUE;
      }         
      if ((height & 3) && (GLuint) height != texImage->Height) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexSubImage%D(width)", dimensions);
         return GL_TRUE;
      }         
d1034 1
a1034 1
   GLint maxLevels = 0, maxTextureSize;
d1038 1
a1038 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexImage1D(target)" );
a1040 1
      maxLevels = ctx->Const.MaxTextureLevels;
d1043 5
a1047 10
      if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
          target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexImage2D(target)" );
            return GL_TRUE;
         }
      }
      else if (target == GL_TEXTURE_RECTANGLE_NV) {
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexImage2D(target)" );
d1052 1
a1052 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexImage2D(target)" );
a1054 6
      if (target == GL_TEXTURE_2D)
         maxLevels = ctx->Const.MaxTextureLevels;
      else if (target == GL_TEXTURE_RECTANGLE_NV)
         maxLevels = 1;
      else
         maxLevels = ctx->Const.MaxCubeTextureLevels;
a1056 3
   ASSERT(maxLevels > 0);
   maxTextureSize = 1 << (maxLevels - 1);

d1058 4
a1061 3
   if (border != 0 && border != 1) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%dD(border)", dimensions);
d1066 1
a1066 1
   if (width < 2 * border || width > 2 + maxTextureSize
d1068 3
a1070 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%dD(width=%d)", dimensions, width);
d1076 1
a1076 1
      if (height < 2 * border || height > 2 + maxTextureSize
d1078 3
a1080 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexImage%dD(height=%d)", dimensions, height);
d1089 1
a1089 1
         _mesa_error(ctx, GL_INVALID_VALUE, "glCopyTexImage2D(width != height)");
d1095 4
a1098 3
   if (level < 0 || level >= maxLevels) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%dD(level=%d)", dimensions, level);
d1102 5
a1106 3
   if (_mesa_base_tex_format(ctx, internalFormat) < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%dD(internalFormat)", dimensions);
a1109 13
   if (is_compressed_format(internalFormat)) {
      if (target != GL_TEXTURE_2D) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glCopyTexImage%d(target)", dimensions);
         return GL_TRUE;
      }
      if (border != 0) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexImage%D(border!=0)", dimensions);
         return GL_TRUE;
      }
   }

a1122 1
   GLint maxLevels = 0;
d1126 1
a1126 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage1D(target)" );
a1128 1
      maxLevels = ctx->Const.MaxTextureLevels;
d1131 5
a1135 10
      if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
          target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage2D(target)" );
            return GL_TRUE;
         }
      }
      else if (target == GL_TEXTURE_RECTANGLE_NV) {
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage2D(target)" );
d1140 1
a1140 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage2D(target)" );
a1142 6
      if (target == GL_TEXTURE_2D)
         maxLevels = ctx->Const.MaxTextureLevels;
      else if (target == GL_TEXTURE_RECTANGLE_NV)
         maxLevels = 1;
      else
         maxLevels = ctx->Const.MaxCubeTextureLevels;
d1146 1
a1146 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage3D(target)" );
a1148 1
      maxLevels = ctx->Const.Max3DTextureLevels;
d1151 4
a1154 5
   ASSERT(maxLevels > 0);

   if (level < 0 || level >= maxLevels) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(level=%d)", dimensions, level);
d1159 3
a1161 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(width=%d)", dimensions, width);
d1165 3
a1167 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(height=%d)", dimensions, height);
d1171 1
a1171 1
   teximage = _mesa_select_tex_image(ctx, texUnit, target, level);
d1173 3
a1175 3
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexSubImage%dD(undefined texture level: %d)",
                  dimensions, level);
d1180 3
a1182 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(xoffset=%d)", dimensions, xoffset);
d1185 4
a1188 3
   if (xoffset + width > (GLint) (teximage->Width + teximage->Border)) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(xoffset+width)", dimensions);
d1193 3
a1195 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(yoffset=%d)", dimensions, yoffset);
d1199 4
a1202 3
      if (yoffset + height > (GLint) (teximage->Height + teximage->Border)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(yoffset+height)", dimensions);
d1209 3
a1211 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(zoffset)", dimensions);
d1214 4
a1217 17
      if (zoffset > (GLint) (teximage->Depth + teximage->Border)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(zoffset+depth)", dimensions);
         return GL_TRUE;
      }
   }

   if (teximage->IsCompressed) {
      if (target != GL_TEXTURE_2D) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glCopyTexSubImage%d(target)", dimensions);
         return GL_TRUE;
      }
      /* offset must be multiple of 4 */
      if ((xoffset & 3) || (yoffset & 3)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%D(xoffset or yoffset)", dimensions);
a1219 16
      /* size must be multiple of 4 */
      if ((width & 3) != 0 && (GLuint) width != teximage->Width) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%D(width)", dimensions);
         return GL_TRUE;
      }         
      if ((height & 3) != 0 && (GLuint) height != teximage->Height) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%D(height)", dimensions);
         return GL_TRUE;
      }         
   }

   if (teximage->IntFormat == GL_YCBCR_MESA) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glCopyTexSubImage2D");
      return GL_TRUE;
a1227 10
void
_mesa_GetTexImage( GLenum target, GLint level, GLenum format,
                   GLenum type, GLvoid *pixels )
{
   const struct gl_texture_unit *texUnit;
   const struct gl_texture_object *texObj;
   const struct gl_texture_image *texImage;
   GLint maxLevels = 0;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1229 32
a1260 5
   texUnit = &(ctx->Texture.Unit[ctx->Texture.CurrentUnit]);
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   if (!texObj || is_proxy_target(target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexImage(target)");
      return;
d1263 58
a1320 113
   maxLevels = _mesa_max_texture_levels(ctx, target);
   ASSERT(maxLevels > 0);  /* 0 indicates bad target, caught above */

   if (level < 0 || level >= maxLevels) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glGetTexImage(level)" );
      return;
   }

   if (_mesa_sizeof_packed_type(type) <= 0) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexImage(type)" );
      return;
   }

   if (_mesa_components_in_format(format) <= 0 ||
       format == GL_STENCIL_INDEX) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexImage(format)" );
      return;
   }

   if (!ctx->Extensions.EXT_paletted_texture && is_index_format(format)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexImage(format)");
   }

   if (!ctx->Extensions.SGIX_depth_texture && format == GL_DEPTH_COMPONENT) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexImage(format)");
   }

   if (!ctx->Extensions.MESA_ycbcr_texture && format == GL_YCBCR_MESA) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexImage(format)");
   }

   /* XXX what if format/type doesn't match texture format/type? */

   if (!pixels)
      return;

   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   if (!texImage) {
      /* invalid mipmap level, not an error */
      return;
   }

   if (!texImage->Data) {
      /* no image data, not an error */
      return;
   }

   {
      const GLint width = texImage->Width;
      const GLint height = texImage->Height;
      const GLint depth = texImage->Depth;
      GLint img, row;
      for (img = 0; img < depth; img++) {
         for (row = 0; row < height; row++) {
            /* compute destination address in client memory */
            GLvoid *dest = _mesa_image_address( &ctx->Pack, pixels,
                                                width, height, format, type,
                                                img, row, 0);
            assert(dest);

            if (format == GL_COLOR_INDEX) {
               GLuint indexRow[MAX_WIDTH];
               GLint col;
               for (col = 0; col < width; col++) {
                  (*texImage->FetchTexel)(texImage, col, row, img,
                                          (GLvoid *) &indexRow[col]);
               }
               _mesa_pack_index_span(ctx, width, type, dest,
                                     indexRow, &ctx->Pack,
                                     0 /* no image transfer */);
            }
            else if (format == GL_DEPTH_COMPONENT) {
               GLfloat depthRow[MAX_WIDTH];
               GLint col;
               for (col = 0; col < width; col++) {
                  (*texImage->FetchTexel)(texImage, col, row, img,
                                          (GLvoid *) &depthRow[col]);
               }
               _mesa_pack_depth_span(ctx, width, dest, type,
                                     depthRow, &ctx->Pack);
            }
            else if (format == GL_YCBCR_MESA) {
               /* No pixel transfer */
               const GLint rowstride = texImage->RowStride;
               MEMCPY(dest,
                      (const GLushort *) texImage->Data + row * rowstride,
                      width * sizeof(GLushort));
               /* check for byte swapping */
               if ((texImage->TexFormat->MesaFormat == MESA_FORMAT_YCBCR
                    && type == GL_UNSIGNED_SHORT_8_8_REV_MESA) ||
                   (texImage->TexFormat->MesaFormat == MESA_FORMAT_YCBCR_REV
                    && type == GL_UNSIGNED_SHORT_8_8_MESA)) {
                  if (!ctx->Pack.SwapBytes)
                     _mesa_swap2((GLushort *) dest, width);
               }
               else if (ctx->Pack.SwapBytes) {
                  _mesa_swap2((GLushort *) dest, width);
               }
            }
            else {
               /* general case:  convert row to RGBA format */
               GLchan rgba[MAX_WIDTH][4];
               GLint col;
               for (col = 0; col < width; col++) {
                  (*texImage->FetchTexel)(texImage, col, row, img,
                                          (GLvoid *) rgba[col]);
               }
               _mesa_pack_rgba_span(ctx, width, (const GLchan (*)[4])rgba,
                                    format, type, dest, &ctx->Pack,
                                    0 /* no image transfer */);
            } /* format */
         } /* row */
      } /* img */
d1322 1
a1325 1

a1333 1
   GLsizei postConvWidth = width;
d1335 1
a1335 5
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (is_color_format(internalFormat)) {
      _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);
   }
d1337 1
a1337 1
   if (target == GL_TEXTURE_1D) {
d1341 16
d1359 2
a1360 2
                              format, type, 1, postConvWidth, 1, 1, border)) {
         return;   /* error was recorded */
d1364 2
a1365 2
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d1371 1
a1371 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage1D");
d1375 45
a1419 24
      else if (texImage->Data && !texImage->IsClientData) {
         /* free the old texture data */
         MESA_PBUFFER_FREE(texImage->Data);
      }
      texImage->Data = NULL;
      clear_teximage_fields(texImage); /* not really needed, but helpful */
      _mesa_init_teximage_fields(ctx, target, texImage,
                                 postConvWidth, 1, 1,
                                 border, internalFormat);

      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
         _mesa_update_state(ctx);

      ASSERT(ctx->Driver.TexImage1D);

      /* Give the texture to the driver!  <pixels> may be null! */
      (*ctx->Driver.TexImage1D)(ctx, target, level, internalFormat,
                                width, border, format, type, pixels,
                                &ctx->Unpack, texObj, texImage);

      ASSERT(texImage->TexFormat);
      if (!texImage->FetchTexel) {
         /* If driver didn't explicitly set this, use the default */
         texImage->FetchTexel = texImage->TexFormat->FetchTexel1D;
a1420 1
      ASSERT(texImage->FetchTexel);
d1423 2
a1424 2
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d1428 3
a1430 4
      GLboolean error = texture_error_check(ctx, target, level, internalFormat,
                                 format, type, 1, postConvWidth, 1, 1, border);
      if (!error) {
         ASSERT(ctx->Driver.TestProxyTexImage);
d1433 1
a1433 1
                                                  postConvWidth, 1, 1, border);
d1437 2
a1438 2
         if (level >= 0 && level < ctx->Const.MaxTextureLevels) {
            clear_teximage_fields(ctx->Texture.Proxy1D->Image[level]);
d1442 3
a1444 8
         /* no error, set the tex image parameters */
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage,
                                    postConvWidth, 1, 1,
                                    border, internalFormat);
d1448 1
a1448 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage1D(target)" );
a1459 1
   GLsizei postConvWidth = width, postConvHeight = height;
d1461 1
a1461 6
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (is_color_format(internalFormat)) {
      _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth,
					 &postConvHeight);
   }
d1463 2
a1464 2
   if (target == GL_TEXTURE_2D ||
       (ctx->Extensions.ARB_texture_cube_map &&
d1466 1
a1466 4
        target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) ||
       (ctx->Extensions.NV_texture_rectangle &&
        target == GL_TEXTURE_RECTANGLE_NV)) {
      /* non-proxy target */
d1470 16
d1488 2
a1489 3
                              format, type, 2, postConvWidth, postConvHeight,
                              1, border)) {
         return;   /* error was recorded */
d1498 2
a1499 1
         _mesa_set_tex_image(texObj, target, level, texImage);
d1501 1
a1501 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage2D");
d1505 54
a1558 24
      else if (texImage->Data && !texImage->IsClientData) {
         /* free the old texture data */
         MESA_PBUFFER_FREE(texImage->Data);
      }
      texImage->Data = NULL;
      clear_teximage_fields(texImage); /* not really needed, but helpful */
      _mesa_init_teximage_fields(ctx, target, texImage,
                                 postConvWidth, postConvHeight, 1,
                                 border, internalFormat);

      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
         _mesa_update_state(ctx);

      ASSERT(ctx->Driver.TexImage2D);

      /* Give the texture to the driver!  <pixels> may be null! */
      (*ctx->Driver.TexImage2D)(ctx, target, level, internalFormat,
                                width, height, border, format, type, pixels,
                                &ctx->Unpack, texObj, texImage);

      ASSERT(texImage->TexFormat);
      if (!texImage->FetchTexel) {
         /* If driver didn't explicitly set this, use the default */
         texImage->FetchTexel = texImage->TexFormat->FetchTexel2D;
d1560 1
a1560 1
      ASSERT(texImage->FetchTexel);
d1563 2
a1564 2
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d1566 1
a1566 5
   else if (target == GL_PROXY_TEXTURE_2D ||
            (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB &&
             ctx->Extensions.ARB_texture_cube_map) ||
            (target == GL_PROXY_TEXTURE_RECTANGLE_NV &&
             ctx->Extensions.NV_texture_rectangle)) {
d1568 3
a1570 4
      GLboolean error = texture_error_check(ctx, target, level, internalFormat,
                    format, type, 2, postConvWidth, postConvHeight, 1, border);
      if (!error) {
         ASSERT(ctx->Driver.TestProxyTexImage);
d1572 2
a1573 2
                                    internalFormat, format, type,
                                    postConvWidth, postConvHeight, 1, border);
d1577 2
a1578 4
         const GLint maxLevels = (target == GL_PROXY_TEXTURE_2D) ?
            ctx->Const.MaxTextureLevels : ctx->Const.MaxCubeTextureLevels;
         if (level >= 0 && level < maxLevels) {
            clear_teximage_fields(ctx->Texture.Proxy2D->Image[level]);
d1582 4
a1585 8
         /* no error, set the tex image parameters */
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage,
                                    postConvWidth, postConvHeight, 1,
                                    border, internalFormat);
d1589 1
a1589 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage2D(target)" );
d1606 1
a1606 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1608 1
a1608 1
   if (target == GL_TEXTURE_3D) {
d1612 16
d1629 1
a1629 1
      if (texture_error_check(ctx, target, level, (GLint) internalFormat,
d1631 1
a1631 1
         return;   /* error was recorded */
d1635 2
a1636 2
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d1642 1
a1642 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage3D");
d1646 36
a1681 2
      else if (texImage->Data && !texImage->IsClientData) {
         MESA_PBUFFER_FREE(texImage->Data);
d1683 9
a1691 20
      texImage->Data = NULL;
      clear_teximage_fields(texImage); /* not really needed, but helpful */
      _mesa_init_teximage_fields(ctx, target, texImage,
                                 width, height, depth,
                                 border, internalFormat);

      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
         _mesa_update_state(ctx);

      ASSERT(ctx->Driver.TexImage3D);

      /* Give the texture to the driver!  <pixels> may be null! */
      (*ctx->Driver.TexImage3D)(ctx, target, level, internalFormat,
                                width, height, depth, border, format, type,
                                pixels, &ctx->Unpack, texObj, texImage);

      ASSERT(texImage->TexFormat);
      if (!texImage->FetchTexel) {
         /* If driver didn't explicitly set this, use the default */
         texImage->FetchTexel = texImage->TexFormat->FetchTexel3D;
a1692 1
      ASSERT(texImage->FetchTexel);
d1695 2
a1696 2
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d1700 1
a1700 1
      GLboolean error = texture_error_check(ctx, target, level, internalFormat,
d1702 1
a1702 2
      if (!error) {
         ASSERT(ctx->Driver.TestProxyTexImage);
d1709 2
a1710 2
         if (level >= 0 && level < ctx->Const.Max3DTextureLevels) {
            clear_teximage_fields(ctx->Texture.Proxy3D->Image[level]);
d1714 3
a1716 7
         /* no error, set the tex image parameters */
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                    border, internalFormat);
d1720 1
a1720 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage3D(target)" );
d1737 4
a1740 1

d1742 2
a1743 4
_mesa_TexSubImage1D( GLenum target, GLint level,
                     GLint xoffset, GLsizei width,
                     GLenum format, GLenum type,
                     const GLvoid *pixels )
d1745 3
a1747 3
   GLsizei postConvWidth = width;
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
d1749 14
a1762 2
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1764 6
a1769 2
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);
d1771 3
a1773 3
   /* XXX should test internal format */
   if (is_color_format(format)) {
      _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);
d1776 45
a1820 3
   if (subtexture_error_check(ctx, 1, target, level, xoffset, 0, 0,
                              postConvWidth, 1, 1, format, type)) {
      return;   /* error was detected */
d1823 254
a2076 4
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   assert(texImage);
a2080 2
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
d2082 53
a2134 5
   ASSERT(ctx->Driver.TexSubImage1D);
   (*ctx->Driver.TexSubImage1D)(ctx, target, level, xoffset, width,
                                format, type, pixels, &ctx->Unpack,
                                texObj, texImage);
   ctx->NewState |= _NEW_TEXTURE;
a2144 1
   GLsizei postConvWidth = width, postConvHeight = height;
d2148 1
d2150 1
a2150 10
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);

   /* XXX should test internal format */
   if (is_color_format(format)) {
      _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth,
                                         &postConvHeight);
   }
d2153 1
a2153 1
                             postConvWidth, postConvHeight, 1, format, type)) {
d2159 1
a2159 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2165 83
a2247 9
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
   yoffset += texImage->Border;

   ASSERT(ctx->Driver.TexSubImage2D);
   (*ctx->Driver.TexSubImage2D)(ctx, target, level, xoffset, yoffset,
                                width, height, format, type, pixels,
                                &ctx->Unpack, texObj, texImage);
   ctx->NewState |= _NEW_TEXTURE;
d2262 1
d2264 1
a2264 4
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);
d2272 2
a2273 2
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2279 114
a2392 12
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
   yoffset += texImage->Border;
   zoffset += texImage->Border;

   ASSERT(ctx->Driver.TexSubImage3D);
   (*ctx->Driver.TexSubImage3D)(ctx, target, level,
                                xoffset, yoffset, zoffset,
                                width, height, depth,
                                format, type, pixels,
                                &ctx->Unpack, texObj, texImage );
   ctx->NewState |= _NEW_TEXTURE;
a2402 4
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLsizei postConvWidth = width;
d2404 1
a2404 8
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);

   if (is_color_format(internalFormat)) {
      _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);
   }
d2407 1
a2407 1
                               postConvWidth, 1, border))
d2410 11
a2420 8
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   if (!texImage) {
      texImage = _mesa_alloc_texture_image();
      _mesa_set_tex_image(texObj, target, level, texImage);
      if (!texImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage1D");
a2422 6
   }
   else if (texImage->Data && !texImage->IsClientData) {
      /* free the old texture data */
      MESA_PBUFFER_FREE(texImage->Data);
   }
   texImage->Data = NULL;
d2424 6
a2429 3
   clear_teximage_fields(texImage); /* not really needed, but helpful */
   _mesa_init_teximage_fields(ctx, target, texImage, postConvWidth, 1, 1,
                              border, internalFormat);
d2431 1
a2431 9

   ASSERT(ctx->Driver.CopyTexImage1D);
   (*ctx->Driver.CopyTexImage1D)(ctx, target, level, internalFormat,
                                 x, y, width, border);

   ASSERT(texImage->TexFormat);
   if (!texImage->FetchTexel) {
      /* If driver didn't explicitly set this, use the default */
      texImage->FetchTexel = texImage->TexFormat->FetchTexel1D;
a2432 5
   ASSERT(texImage->FetchTexel);

   /* state update */
   texObj->Complete = GL_FALSE;
   ctx->NewState |= _NEW_TEXTURE;
a2441 4
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLsizei postConvWidth = width, postConvHeight = height;
d2443 1
a2443 9
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);

   if (is_color_format(internalFormat)) {
      _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth,
                                         &postConvHeight);
   }
d2446 1
a2446 1
                               postConvWidth, postConvHeight, border))
d2449 11
a2459 8
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   if (!texImage) {
      texImage = _mesa_alloc_texture_image();
      _mesa_set_tex_image(texObj, target, level, texImage);
      if (!texImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage2D");
a2461 11
   }
   else if (texImage->Data && !texImage->IsClientData) {
      /* free the old texture data */
      MESA_PBUFFER_FREE(texImage->Data);
   }
   texImage->Data = NULL;

   clear_teximage_fields(texImage); /* not really needed, but helpful */
   _mesa_init_teximage_fields(ctx, target, texImage,
                              postConvWidth, postConvHeight, 1,
                              border, internalFormat);
d2463 6
a2468 3
   ASSERT(ctx->Driver.CopyTexImage2D);
   (*ctx->Driver.CopyTexImage2D)(ctx, target, level, internalFormat,
                                 x, y, width, height, border);
d2470 1
a2470 4
   ASSERT(texImage->TexFormat);
   if (!texImage->FetchTexel) {
      /* If driver didn't explicitly set this, use the default */
      texImage->FetchTexel = texImage->TexFormat->FetchTexel2D;
a2471 5
   ASSERT(texImage->FetchTexel);

   /* state update */
   texObj->Complete = GL_FALSE;
   ctx->NewState |= _NEW_TEXTURE;
a2479 3
   struct gl_texture_unit *texUnit;
   struct gl_texture_image *texImage;
   GLsizei postConvWidth = width;
d2481 1
a2481 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2483 3
a2485 2
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);
d2487 8
a2494 2
   /* XXX should test internal format */
   _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);
d2496 3
a2498 3
   if (copytexsubimage_error_check(ctx, 1, target, level,
                                   xoffset, 0, 0, postConvWidth, 1))
      return;
d2500 6
a2505 2
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2507 6
a2512 2
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
d2514 2
a2515 3
   ASSERT(ctx->Driver.CopyTexSubImage1D);
   (*ctx->Driver.CopyTexSubImage1D)(ctx, target, level, xoffset, x, y, width);
   ctx->NewState |= _NEW_TEXTURE;
a2524 3
   struct gl_texture_unit *texUnit;
   struct gl_texture_image *texImage;
   GLsizei postConvWidth = width, postConvHeight = height;
d2526 1
a2526 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2528 3
a2530 2
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);
d2532 12
a2543 2
   /* XXX should test internal format */
   _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth, &postConvHeight);
d2545 6
a2550 3
   if (copytexsubimage_error_check(ctx, 2, target, level, xoffset, yoffset, 0,
                                   postConvWidth, postConvHeight))
      return;
d2552 6
a2557 2
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2559 2
a2560 8
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
   yoffset += texImage->Border;

   ASSERT(ctx->Driver.CopyTexSubImage2D);
   (*ctx->Driver.CopyTexSubImage2D)(ctx, target, level,
                                    xoffset, yoffset, x, y, width, height);
   ctx->NewState |= _NEW_TEXTURE;
a2569 3
   struct gl_texture_unit *texUnit;
   struct gl_texture_image *texImage;
   GLsizei postConvWidth = width, postConvHeight = height;
d2571 1
a2571 7
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);

   /* XXX should test internal format */
   _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth, &postConvHeight);
d2573 2
a2574 2
   if (copytexsubimage_error_check(ctx, 3, target, level, xoffset, yoffset,
                                   zoffset, postConvWidth, postConvHeight))
d2577 8
a2584 2
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2586 3
a2588 4
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
   yoffset += texImage->Border;
   zoffset += texImage->Border;
d2590 5
a2594 49
   ASSERT(ctx->Driver.CopyTexSubImage3D);
   (*ctx->Driver.CopyTexSubImage3D)(ctx, target, level,
                                    xoffset, yoffset, zoffset,
                                    x, y, width, height);
   ctx->NewState |= _NEW_TEXTURE;
}




/**********************************************************************/
/******                   Compressed Textures                    ******/
/**********************************************************************/


/**
 * Error checking for glCompressedTexImage[123]D().
 * \return error code or GL_NO_ERROR.
 */
static GLenum
compressed_texture_error_check(GLcontext *ctx, GLint dimensions,
                               GLenum target, GLint level,
                               GLenum internalFormat, GLsizei width,
                               GLsizei height, GLsizei depth, GLint border,
                               GLsizei imageSize)
{
   GLint expectedSize, maxLevels = 0, maxTextureSize;

   if (dimensions == 1) {
      /* 1D compressed textures not allowed */
      return GL_INVALID_ENUM;
   }
   else if (dimensions == 2) {
      if (target == GL_PROXY_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map)
            return GL_INVALID_ENUM; /*target*/
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
               target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map)
            return GL_INVALID_ENUM; /*target*/
         maxLevels = ctx->Const.MaxCubeTextureLevels;
a2595 10
      else {
         return GL_INVALID_ENUM; /*target*/
      }
   }
   else if (dimensions == 3) {
      /* 3D compressed textures not allowed */
      return GL_INVALID_ENUM;
   }

   maxTextureSize = 1 << (maxLevels - 1);
d2597 6
a2602 2
   if (!is_compressed_format(internalFormat))
      return GL_INVALID_ENUM;
d2604 1
a2604 47
   if (border != 0)
      return GL_INVALID_VALUE;

   if (width < 1 || width > maxTextureSize || logbase2(width) < 0)
      return GL_INVALID_VALUE;

   if ((height < 1 || height > maxTextureSize || logbase2(height) < 0)
       && dimensions > 1)
      return GL_INVALID_VALUE;

   if ((depth < 1 || depth > maxTextureSize || logbase2(depth) < 0)
       && dimensions > 2)
      return GL_INVALID_VALUE;

   /* For cube map, width must equal height */
   if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
       target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB && width != height)
      return GL_INVALID_VALUE;

   if (level < 0 || level >= maxLevels)
      return GL_INVALID_VALUE;

   expectedSize = _mesa_compressed_texture_size(ctx, width, height, depth,
                                                internalFormat);
   if (expectedSize != imageSize)
      return GL_INVALID_VALUE;

   return GL_NO_ERROR;
}


/**
 * Error checking for glCompressedTexSubImage[123]D().
 * \return error code or GL_NO_ERROR.
 */
static GLenum
compressed_subtexture_error_check(GLcontext *ctx, GLint dimensions,
                                  GLenum target, GLint level,
                                  GLint xoffset, GLint yoffset, GLint zoffset,
                                  GLsizei width, GLsizei height, GLsizei depth,
                                  GLenum format, GLsizei imageSize)
{
   GLint expectedSize, maxLevels = 0, maxTextureSize;

   if (dimensions == 1) {
      /* 1D compressed textures not allowed */
      return GL_INVALID_ENUM;
a2605 57
   else if (dimensions == 2) {
      if (target == GL_PROXY_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map)
            return GL_INVALID_ENUM; /*target*/
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
               target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map)
            return GL_INVALID_ENUM; /*target*/
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else {
         return GL_INVALID_ENUM; /*target*/
      }
   }
   else if (dimensions == 3) {
      /* 3D compressed textures not allowed */
      return GL_INVALID_ENUM;
   }

   maxTextureSize = 1 << (maxLevels - 1);

   if (!is_compressed_format(format))
      return GL_INVALID_ENUM;

   if (width < 1 || width > maxTextureSize || logbase2(width) < 0)
      return GL_INVALID_VALUE;

   if ((height < 1 || height > maxTextureSize || logbase2(height) < 0)
       && dimensions > 1)
      return GL_INVALID_VALUE;

   if (level < 0 || level >= maxLevels)
      return GL_INVALID_VALUE;

   if ((xoffset & 3) != 0 || (yoffset & 3) != 0)
      return GL_INVALID_VALUE;

   if ((width & 3) != 0 && width != 2 && width != 1)
      return GL_INVALID_VALUE;

   if ((height & 3) != 0 && height != 2 && height != 1)
      return GL_INVALID_VALUE;

   expectedSize = _mesa_compressed_texture_size(ctx, width, height, depth,
                                                format);
   if (expectedSize != imageSize)
      return GL_INVALID_VALUE;

   return GL_NO_ERROR;
d2617 15
a2631 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2637 5
a2641 5
      GLenum error = compressed_texture_error_check(ctx, 1, target, level,
                               internalFormat, width, 1, 1, border, imageSize);
      if (error) {
         _mesa_error(ctx, error, "glCompressedTexImage1D");
         return;
d2645 2
a2646 2
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2652 1
a2652 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage1D");
d2656 47
a2702 2
      else if (texImage->Data && !texImage->IsClientData) {
         MESA_PBUFFER_FREE(texImage->Data);
a2703 10
      texImage->Data = NULL;

      _mesa_init_teximage_fields(ctx, target, texImage, width, 1, 1,
                                 border, internalFormat);

      ASSERT(ctx->Driver.CompressedTexImage1D);
      (*ctx->Driver.CompressedTexImage1D)(ctx, target, level,
                                          internalFormat, width, border,
                                          imageSize, data,
                                          texObj, texImage);
d2706 2
a2707 2
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d2711 3
a2713 4
      GLenum error = compressed_texture_error_check(ctx, 1, target, level,
                               internalFormat, width, 1, 1, border, imageSize);
      if (!error) {
         ASSERT(ctx->Driver.TestProxyTexImage);
d2720 2
a2721 2
         if (level >= 0 && level < ctx->Const.MaxTextureLevels) {
            clear_teximage_fields(ctx->Texture.Proxy1D->Image[level]);
d2725 3
a2727 7
         /* store the teximage parameters */
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, 1, 1,
                                    border, internalFormat);
d2731 1
a2731 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage1D(target)");
d2744 1
a2744 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2746 16
a2761 2
   if (target == GL_TEXTURE_2D ||
       (ctx->Extensions.ARB_texture_cube_map &&
d2767 5
a2771 5
      GLenum error = compressed_texture_error_check(ctx, 2, target, level,
                          internalFormat, width, height, 1, border, imageSize);
      if (error) {
         _mesa_error(ctx, error, "glCompressedTexImage2D");
         return;
d2775 2
a2776 2
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2782 1
a2782 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage2D");
d2786 52
a2837 2
      else if (texImage->Data && !texImage->IsClientData) {
         MESA_PBUFFER_FREE(texImage->Data);
a2838 10
      texImage->Data = NULL;

      _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                 border, internalFormat);

      ASSERT(ctx->Driver.CompressedTexImage2D);
      (*ctx->Driver.CompressedTexImage2D)(ctx, target, level,
                                          internalFormat, width, height,
                                          border, imageSize, data,
                                          texObj, texImage);
d2841 2
a2842 2
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d2844 1
a2844 3
   else if (target == GL_PROXY_TEXTURE_2D ||
            (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB &&
             ctx->Extensions.ARB_texture_cube_map)) {
d2846 3
a2848 4
      GLenum error = compressed_texture_error_check(ctx, 2, target, level,
                          internalFormat, width, height, 1, border, imageSize);
      if (!error) {
         ASSERT(ctx->Driver.TestProxyTexImage);
d2855 2
a2856 4
         const GLint maxLevels = (target == GL_PROXY_TEXTURE_2D) ?
            ctx->Const.MaxTextureLevels : ctx->Const.MaxCubeTextureLevels;
         if (level >= 0 && level < maxLevels) {
            clear_teximage_fields(ctx->Texture.Proxy2D->Image[level]);
d2860 3
a2862 7
         /* store the teximage parameters */
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                    border, internalFormat);
d2866 1
a2866 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage2D(target)");
d2879 15
a2893 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2899 5
a2903 5
      GLenum error = compressed_texture_error_check(ctx, 3, target, level,
                      internalFormat, width, height, depth, border, imageSize);
      if (error) {
         _mesa_error(ctx, error, "glCompressedTexImage3D");
         return;
d2907 2
a2908 2
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2914 1
a2914 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage3D");
d2918 49
a2966 2
      else if (texImage->Data && !texImage->IsClientData) {
         MESA_PBUFFER_FREE(texImage->Data);
a2967 11
      texImage->Data = NULL;

      _mesa_init_teximage_fields(ctx, target, texImage, width, height, depth,
                                 border, internalFormat);

      ASSERT(ctx->Driver.CompressedTexImage3D);
      (*ctx->Driver.CompressedTexImage3D)(ctx, target, level,
                                          internalFormat,
                                          width, height, depth,
                                          border, imageSize, data,
                                          texObj, texImage);
d2970 2
a2971 2
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d2975 3
a2977 4
      GLenum error = compressed_texture_error_check(ctx, 3, target, level,
                      internalFormat, width, height, depth, border, imageSize);
      if (!error) {
         ASSERT(ctx->Driver.TestProxyTexImage);
d2984 2
a2985 2
         if (level >= 0 && level < ctx->Const.Max3DTextureLevels) {
            clear_teximage_fields(ctx->Texture.Proxy3D->Image[level]);
d2989 3
a2991 7
         /* store the teximage parameters */
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, height,
                                    depth, border, internalFormat);
d2995 1
a2995 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage3D(target)");
d3009 1
a3009 1
   GLenum error;
d3011 1
a3011 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3013 3
a3015 5
   error = compressed_subtexture_error_check(ctx, 1, target, level,
                                xoffset, 0, 0, width, 1, 1, format, imageSize);
   if (error) {
      _mesa_error(ctx, error, "glCompressedTexSubImage1D");
      return;
d3020 1
a3020 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
a3022 11
   if ((GLint) format != texImage->IntFormat) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage1D(format)");
      return;
   }

   if ((width == 1 || width == 2) && (GLuint) width != texImage->Width) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage1D(width)");
      return;
   }
      
d3027 7
a3033 4
      (*ctx->Driver.CompressedTexSubImage1D)(ctx, target, level,
                                             xoffset, width,
                                             format, imageSize, data,
                                             texObj, texImage);
a3034 1
   ctx->NewState |= _NEW_TEXTURE;
d3047 1
a3047 1
   GLenum error;
d3049 1
a3049 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3051 3
a3053 5
   error = compressed_subtexture_error_check(ctx, 2, target, level,
                     xoffset, yoffset, 0, width, height, 1, format, imageSize);
   if (error) {
      _mesa_error(ctx, error, "glCompressedTexSubImage2D");
      return;
d3058 1
a3058 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
a3060 12
   if ((GLint) format != texImage->IntFormat) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage2D(format)");
      return;
   }

   if (((width == 1 || width == 2) && (GLuint) width != texImage->Width) ||
       ((height == 1 || height == 2) && (GLuint) height != texImage->Height)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage2D(size)");
      return;
   }
      
d3065 8
a3072 4
      (*ctx->Driver.CompressedTexSubImage2D)(ctx, target, level,
                                             xoffset, yoffset, width, height,
                                             format, imageSize, data,
                                             texObj, texImage);
a3073 1
   ctx->NewState |= _NEW_TEXTURE;
d3086 1
a3086 1
   GLenum error;
d3088 1
a3088 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3090 3
a3092 5
   error = compressed_subtexture_error_check(ctx, 3, target, level,
           xoffset, yoffset, zoffset, width, height, depth, format, imageSize);
   if (error) {
      _mesa_error(ctx, error, "glCompressedTexSubImage2D");
      return;
d3097 1
a3097 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
a3099 13
   if ((GLint) format != texImage->IntFormat) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage3D(format)");
      return;
   }

   if (((width == 1 || width == 2) && (GLuint) width != texImage->Width) ||
       ((height == 1 || height == 2) && (GLuint) height != texImage->Height) ||
       ((depth == 1 || depth == 2) && (GLuint) depth != texImage->Depth)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage3D(size)");
      return;
   }
      
d3104 8
a3111 5
      (*ctx->Driver.CompressedTexSubImage3D)(ctx, target, level,
                                             xoffset, yoffset, zoffset,
                                             width, height, depth,
                                             format, imageSize, data,
                                             texObj, texImage);
a3112 1
   ctx->NewState |= _NEW_TEXTURE;
a3118 1
   const struct gl_texture_unit *texUnit;
a3120 1
   GLint maxLevels;
d3122 1
a3122 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3124 2
a3125 4
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   if (!texObj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetCompressedTexImageARB");
d3129 40
a3168 6
   maxLevels = _mesa_max_texture_levels(ctx, target);
   ASSERT(maxLevels > 0); /* 0 indicates bad target, caught above */

   if (level < 0 || level >= maxLevels) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetCompressedTexImageARB(level)");
      return;
a3170 6
   if (is_proxy_target(target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetCompressedTexImageARB(target)");
      return;
   }

   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d3172 2
a3173 2
      /* probably invalid mipmap level */
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetCompressedTexImageARB(level)");
d3178 1
a3178 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetCompressedTexImageARB");
d3185 7
a3191 2
   /* just memcpy, no pixelstore or pixel transfer */
   MEMCPY(img, texImage->Data, texImage->CompressedSize);
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d4 1
a4 1
 * Version:  4.0.4
d6 1
a6 1
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
a31 1
#include "convolve.h"
a32 1
#include "macros.h"
d35 1
a35 1
#include "state.h"
d39 1
a39 3
#include "texstore.h"
#include "mtypes.h"
#include "swrast/s_span.h" /* XXX SWRAST hack */
d46 1
a46 1
 * Mesa's native texture datatype is GLchan.  Native formats are
a55 3
#if CHAN_TYPE == GL_FLOAT
   _mesa_problem(NULL, "PrintTexture doesn't support float channels");
#else
d57 1
a57 1
   const GLchan *data = (const GLchan *) img->Data;
d81 1
a81 1
         _mesa_problem(NULL, "error in PrintTexture\n");
d85 1
a97 1
      data += (img->RowStride - img->Width) * c;
a99 1
#endif
d108 1
a108 1
 * If n < 0 return -1.
d116 1
a116 1
   if (n < 0) {
d143 4
a146 4
   /*
    * Ask the driver for the base format, if it doesn't
    * know, it will return -1;
    */
d209 1
a209 17
         if (ctx->Extensions.EXT_paletted_texture)
            return GL_COLOR_INDEX;
         else
            return -1;
      case GL_DEPTH_COMPONENT:
      case GL_DEPTH_COMPONENT16_SGIX:
      case GL_DEPTH_COMPONENT24_SGIX:
      case GL_DEPTH_COMPONENT32_SGIX:
         if (ctx->Extensions.SGIX_depth_texture)
            return GL_DEPTH_COMPONENT;
         else
            return -1;
      case GL_YCBCR_MESA:
         if (ctx->Extensions.MESA_ycbcr_texture)
            return GL_YCBCR_MESA;
         else
            return -1;
d216 1
d218 4
a221 2
 * Test if the given image format is a color/rgba format.  That is,
 * not color index, depth, stencil, etc.
d223 2
a224 2
static GLboolean
is_color_format(GLenum format)
d232 1
d239 1
d248 1
d254 1
d264 1
d274 1
a274 12
         return GL_TRUE;
      case GL_YCBCR_MESA:  /* not considered to be RGB */
      default:
         return GL_FALSE;
   }
}


static GLboolean
is_index_format(GLenum format)
{
   switch (format) {
d282 1
a282 1
         return GL_TRUE;
d284 1
a284 1
         return GL_FALSE;
d296 4
a299 8
   if (ctx->Driver.BaseCompressedTexFormat) {
      GLint b = (*ctx->Driver.BaseCompressedTexFormat)(ctx, internalFormat);
      if (b > 0)
         return GL_TRUE;
      else
         return GL_FALSE;
   }
   return GL_FALSE;
d304 4
a307 9
/*
 * Store a gl_texture_image pointer in a gl_texture_object structure
 * according to the target and level parameters.
 * This was basically prompted by the introduction of cube maps.
 */
void
_mesa_set_tex_image(struct gl_texture_object *tObj,
                    GLenum target, GLint level,
                    struct gl_texture_image *texImage)
a311 1
      case GL_TEXTURE_1D:
a312 1
      case GL_TEXTURE_3D:
a332 4
      case GL_TEXTURE_RECTANGLE_NV:
         ASSERT(level == 0);
         tObj->Image[level] = texImage;
         return;
d334 1
a334 1
         _mesa_problem(NULL, "bad target in _mesa_set_tex_image()");
a339 1

d351 34
d388 2
a389 2
   if (teximage->Data && !teximage->IsClientData) {
      MESA_PBUFFER_FREE( teximage->Data );
d396 1
d398 3
a400 1
 * Return GL_TRUE if the target is a proxy target.
d402 17
a418 7
static GLboolean
is_proxy_target(GLenum target)
{
   return (target == GL_PROXY_TEXTURE_1D ||
           target == GL_PROXY_TEXTURE_2D ||
           target == GL_PROXY_TEXTURE_3D ||
           target == GL_PROXY_TEXTURE_CUBE_MAP_ARB);
d422 1
d428 1
a428 1
_mesa_select_tex_object(GLcontext *ctx, const struct gl_texture_unit *texUnit,
d433 1
a433 1
         return texUnit->Current1D;
d437 1
a437 1
         return texUnit->Current2D;
d441 1
a441 1
         return texUnit->Current3D;
d451 1
a451 1
         return ctx->Extensions.ARB_texture_cube_map
d454 1
a454 1
         return ctx->Extensions.ARB_texture_cube_map
a455 6
      case GL_TEXTURE_RECTANGLE_NV:
         return ctx->Extensions.NV_texture_rectangle
                ? texUnit->CurrentRect : NULL;
      case GL_PROXY_TEXTURE_RECTANGLE_NV:
         return ctx->Extensions.NV_texture_rectangle
                ? ctx->Texture.ProxyRect : NULL;
d457 1
a457 1
         _mesa_problem(NULL, "bad target in _mesa_select_tex_object()");
a471 1
   ASSERT(level < MAX_TEXTURE_LEVELS);
d474 1
a474 1
         return texUnit->Current1D->Image[level];
d478 1
a478 1
         return texUnit->Current2D->Image[level];
d482 1
a482 1
         return texUnit->Current3D->Image[level];
d486 1
a486 1
         if (ctx->Extensions.ARB_texture_cube_map)
d491 1
a491 1
         if (ctx->Extensions.ARB_texture_cube_map)
d496 1
a496 1
         if (ctx->Extensions.ARB_texture_cube_map)
d501 1
a501 1
         if (ctx->Extensions.ARB_texture_cube_map)
d506 1
a506 1
         if (ctx->Extensions.ARB_texture_cube_map)
d511 1
a511 1
         if (ctx->Extensions.ARB_texture_cube_map)
d516 1
a516 1
         if (ctx->Extensions.ARB_texture_cube_map)
d520 88
a607 4
      case GL_TEXTURE_RECTANGLE_NV:
         if (ctx->Extensions.NV_texture_rectangle) {
            ASSERT(level == 0);
            return texUnit->CurrentRect->Image[level];
d610 26
a635 1
            return NULL;
d637 21
a657 4
      case GL_PROXY_TEXTURE_RECTANGLE_NV:
         if (ctx->Extensions.NV_texture_rectangle) {
            ASSERT(level == 0);
            return ctx->Texture.ProxyRect->Image[level];
d659 15
a673 2
         else {
            return NULL;
d675 1
a675 3
      default:
         _mesa_problem(ctx, "bad target in _mesa_select_tex_image()");
         return NULL;
a680 1
#if 000 /* not used anymore */
d684 1
a684 1
 * spec.
d686 2
a687 2
static GLubyte *
make_null_texture(GLint width, GLint height, GLint depth, GLenum format)
d689 10
a698 3
   const GLint components = _mesa_components_in_format(format);
   const GLint numPixels = width * height * depth;
   GLubyte *data = (GLubyte *) MALLOC(numPixels * components * sizeof(GLubyte));
a699 1
#ifdef DEBUG
d705 1
a705 1
   if (data) {
d717 10
a726 11
      GLubyte *imgPtr = data;
      GLint h, i, j, k;
      for (h = 0; h < depth; h++) {
         for (i = 0; i < height; i++) {
            GLint srcRow = 7 - (i % 8);
            for (j = 0; j < width; j++) {
               GLint srcCol = j % 32;
               GLubyte texel = (message[srcRow][srcCol]=='X') ? 255 : 70;
               for (k = 0; k < components; k++) {
                  *imgPtr++ = texel;
               }
a730 3
#endif

   return data;
a731 1
#endif
a735 1
 * Reset the fields of a gl_texture_image struct to zero.
a737 3
 * It's also used in glTexImage[123]D as a safeguard to be sure all
 * required fields get initialized properly by the Driver.TexImage[123]D
 * functions.
d740 1
a740 1
clear_teximage_fields(struct gl_texture_image *img)
a748 1
   img->RowStride = 0;
a755 2
   img->TexFormat = &_mesa_null_texformat;
   img->FetchTexel = NULL;
d758 1
a758 35
}


/*
 * Initialize basic fields of the gl_texture_image struct.
 */
void
_mesa_init_teximage_fields(GLcontext *ctx, GLenum target,
                           struct gl_texture_image *img,
                           GLsizei width, GLsizei height, GLsizei depth,
                           GLint border, GLenum internalFormat)
{
   ASSERT(img);
   img->Format = _mesa_base_tex_format( ctx, internalFormat );
   ASSERT(img->Format > 0);
   img->IntFormat = internalFormat;
   img->Border = border;
   img->Width = width;
   img->Height = height;
   img->Depth = depth;
   img->RowStride = img->Width;
   img->WidthLog2 = logbase2(width - 2 * border);
   if (height == 1)  /* 1-D texture */
      img->HeightLog2 = 0;
   else
      img->HeightLog2 = logbase2(height - 2 * border);
   if (depth == 1)   /* 2-D texture */
      img->DepthLog2 = 0;
   else
      img->DepthLog2 = logbase2(depth - 2 * border);
   img->Width2 = 1 << img->WidthLog2;
   img->Height2 = 1 << img->HeightLog2;
   img->Depth2 = 1 << img->DepthLog2;
   img->MaxLog2 = MAX2(img->WidthLog2, img->HeightLog2);
   img->IsCompressed = is_compressed_format(ctx, internalFormat);
a778 1
   GLint maxLevels = 0, maxTextureSize;
d781 3
a783 8
      if (target == GL_PROXY_TEXTURE_1D) {
         isProxy = GL_TRUE;
      }
      else if (target == GL_TEXTURE_1D) {
         isProxy = GL_FALSE;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage1D(target)" );
a785 1
      maxLevels = ctx->Const.MaxTextureLevels;
d788 7
a794 44
      if (target == GL_PROXY_TEXTURE_2D) {
         isProxy = GL_TRUE;
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_TEXTURE_2D) {
         isProxy = GL_FALSE;
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage2D(target)");
            return GL_TRUE;
         }
         isProxy = GL_TRUE;
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
               target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage2D(target)");
            return GL_TRUE;
         }
         isProxy = GL_FALSE;
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else if (target == GL_PROXY_TEXTURE_RECTANGLE_NV) {
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage2D(target)");
            return GL_TRUE;
         }
         isProxy = GL_TRUE;
         maxLevels = 1;
      }
      else if (target == GL_TEXTURE_RECTANGLE_NV) {
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage2D(target)");
            return GL_TRUE;
         }
         isProxy = GL_FALSE;
         maxLevels = 1;
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage2D(target)");
         return GL_TRUE;
d798 3
a800 8
      if (target == GL_PROXY_TEXTURE_3D) {
         isProxy = GL_TRUE;
      }
      else if (target == GL_TEXTURE_3D) {
         isProxy = GL_FALSE;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage3D(target)" );
a802 1
      maxLevels = ctx->Const.Max3DTextureLevels;
d805 1
a805 1
      _mesa_problem( ctx, "bad dims in texture_error_check" );
a808 3
   ASSERT(maxLevels > 0);
   maxTextureSize = 1 << (maxLevels - 1);

d813 2
a814 2
         sprintf(message, "glTexImage%dD(border=%d)", dimensions, border);
         _mesa_error(ctx, GL_INVALID_VALUE, message);
a817 4
   if ((target == GL_TEXTURE_RECTANGLE_NV ||
        target == GL_PROXY_TEXTURE_RECTANGLE_NV) && border != 0) {
      return GL_TRUE;
   }
d820 1
a820 12
   if (target == GL_TEXTURE_RECTANGLE_NV ||
       target == GL_PROXY_TEXTURE_RECTANGLE_NV) {
      if (width < 1 || width > ctx->Const.MaxTextureRectSize) {
         if (!isProxy) {
            char message[100];
            sprintf(message, "glTexImage%dD(width=%d)", dimensions, width);
            _mesa_error(ctx, GL_INVALID_VALUE, message);
         }
         return GL_TRUE;
      }
   }
   else if (width < 2 * border || width > 2 + maxTextureSize
d824 2
a825 2
         sprintf(message, "glTexImage%dD(width=%d)", dimensions, width);
         _mesa_error(ctx, GL_INVALID_VALUE, message);
d831 2
a832 13
   if (target == GL_TEXTURE_RECTANGLE_NV ||
       target == GL_PROXY_TEXTURE_RECTANGLE_NV) {
      if (height < 1 || height > ctx->Const.MaxTextureRectSize) {
         if (!isProxy) {
            char message[100];
            sprintf(message, "glTexImage%dD(height=%d)", dimensions, height);
            _mesa_error(ctx, GL_INVALID_VALUE, message);
         }
         return GL_TRUE;
      }
   }
   else if (dimensions >= 2) {
      if (height < 2 * border || height > 2 + maxTextureSize
d836 2
a837 2
            sprintf(message, "glTexImage%dD(height=%d)", dimensions, height);
            _mesa_error(ctx, GL_INVALID_VALUE, message);
d848 1
a848 1
            _mesa_error(ctx, GL_INVALID_VALUE, "glTexImage2D(width != height)");
d856 1
a856 1
      if (depth < 2 * border || depth > 2 + maxTextureSize
d859 1
a859 3
            char message[100];
            sprintf(message, "glTexImage3D(depth=%d)", depth );
            _mesa_error( ctx, GL_INVALID_VALUE, message );
d866 1
a866 12
   if (target == GL_TEXTURE_RECTANGLE_NV ||
       target == GL_PROXY_TEXTURE_RECTANGLE_NV) {
      if (level != 0) {
         if (!isProxy) {
            char message[100];
            sprintf(message, "glTexImage%dD(level=%d)", dimensions, level);
            _mesa_error(ctx, GL_INVALID_VALUE, message);
         }
         return GL_TRUE;
      }
   }
   else if (level < 0 || level >= maxLevels) {
d869 2
a870 2
         sprintf(message, "glTexImage%dD(level=%d)", dimensions, level);
         _mesa_error(ctx, GL_INVALID_VALUE, message);
a874 9
   /* For cube map, width must equal height */
   if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
       target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
      if (width != height) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexImage2D(width != height)");
         return GL_TRUE;
      }
   }

d879 2
a880 18
         sprintf(message, "glTexImage%dD(internalFormat=0x%x)", dimensions,
                 internalFormat);
         _mesa_error(ctx, GL_INVALID_VALUE, message);
      }
      return GL_TRUE;
   }

   ASSERT(iformat > 0);

   if (!is_compressed_format( ctx, internalFormat ) &&
       !_mesa_is_legal_format_and_type( format, type )) {
      /* Yes, generate GL_INVALID_OPERATION, not GL_INVALID_ENUM, if there
       * is a type/format mismatch.  See 1.2 spec page 94, sec 3.6.4.
       */
      if (!isProxy) {
	 char message[100];
	 sprintf(message, "glTexImage%dD(format or type)", dimensions);
	 _mesa_error(ctx, GL_INVALID_OPERATION, message);
d885 5
a889 24
   if (format == GL_YCBCR_MESA || iformat == GL_YCBCR_MESA) {
      ASSERT(ctx->Extensions.MESA_ycbcr_texture);
      if (format != GL_YCBCR_MESA ||
          iformat != GL_YCBCR_MESA ||
          (type != GL_UNSIGNED_SHORT_8_8_MESA &&
          type != GL_UNSIGNED_SHORT_8_8_REV_MESA)) {
         if (!isProxy) {
            char message[100];
            sprintf(message,
                    "glTexImage%d(format/type/internalFormat YCBCR mismatch)",
                    dimensions);
            _mesa_error(ctx, GL_INVALID_ENUM, message);
         }
         return GL_TRUE; /* error */
      }
      if (target != GL_TEXTURE_2D &&
          target != GL_PROXY_TEXTURE_2D &&
          target != GL_TEXTURE_RECTANGLE_NV &&
          target != GL_PROXY_TEXTURE_RECTANGLE_NV) {
         if (!isProxy)
            _mesa_error(ctx, GL_INVALID_ENUM, "glTexImage(target)");
         return GL_TRUE;
      }
      if (border != 0) {
d892 2
a893 4
            sprintf(message,
                    "glTexImage%d(format=GL_YCBCR_MESA and border=%d)",
                    dimensions, border);
            _mesa_error(ctx, GL_INVALID_VALUE, message);
a919 2
   GLint maxLevels = 0;
   GLboolean compressed;
d922 2
a923 5
      if (target == GL_TEXTURE_1D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexSubImage1D(target)" );
d928 7
a934 8
      if (ctx->Extensions.ARB_texture_cube_map &&
          target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
          target <=GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else if (ctx->Extensions.NV_texture_rectangle &&
               target == GL_TEXTURE_RECTANGLE_NV) {
         maxLevels = 1;
d936 2
a937 5
      else if (target == GL_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexSubImage2D(target)" );
d942 2
a943 5
      if (target == GL_TEXTURE_3D) {
         maxLevels = ctx->Const.Max3DTextureLevels;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexSubImage3D(target)" );
d948 1
a948 1
      _mesa_problem( ctx, "bad dims in texture_error_check" );
d952 2
a953 6
   ASSERT(maxLevels > 0);

   if (level < 0 || level >= maxLevels) {
      char message[100];
      sprintf(message, "glTexSubImage2D(level=%d)", level);
      _mesa_error(ctx, GL_INVALID_ENUM, message);
d959 2
a960 2
      sprintf(message, "glTexSubImage%dD(width=%d)", dimensions, width);
      _mesa_error(ctx, GL_INVALID_VALUE, message);
d965 2
a966 2
      sprintf(message, "glTexSubImage%dD(height=%d)", dimensions, height);
      _mesa_error(ctx, GL_INVALID_VALUE, message);
d971 2
a972 2
      sprintf(message, "glTexSubImage%dD(depth=%d)", dimensions, depth);
      _mesa_error(ctx, GL_INVALID_VALUE, message);
d976 1
a976 2
   destTex = _mesa_select_tex_image(ctx, texUnit, target, level);

d978 1
a978 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexSubImage1/2/3D");
d983 1
a983 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage1/2/3D(xoffset)");
d987 1
a987 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage1/2/3D(xoffset+width)");
d992 1
a992 1
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage2/3D(yoffset)");
d996 1
a996 1
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage2/3D(yoffset+height)");
d1002 1
a1002 1
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage3D(zoffset)");
d1005 2
a1006 2
      if (zoffset + depth  > (GLint) (destTex->Depth + destTex->Border)) {
         _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage3D(zoffset+depth)");
d1011 5
a1015 23
   compressed = is_compressed_format(ctx, destTex->IntFormat);

   if (!compressed && !_mesa_is_legal_format_and_type(format, type)) {
      char message[100];
      sprintf(message, "glTexSubImage%dD(format or type)", dimensions);
      _mesa_error(ctx, GL_INVALID_ENUM, message);
      return GL_TRUE;
   }

   if (compressed) {
      if (xoffset != -((GLint)destTex->Border)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexSubImage1/2/3D(xoffset != -border");
         return GL_TRUE;
      }
      if (dimensions > 1 && yoffset != -((GLint)destTex->Border)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexSubImage2/3D(yoffset != -border");
         return GL_TRUE;
      }
      if (dimensions > 2 && zoffset != -((GLint)destTex->Border)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexSubImage3D(zoffset != -border");
a1034 1
   GLint maxLevels = 0, maxTextureSize;
d1038 1
a1038 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexImage1D(target)" );
a1040 1
      maxLevels = ctx->Const.MaxTextureLevels;
d1043 5
a1047 4
      if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
          target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexImage2D(target)" );
d1051 2
a1052 8
      else if (target == GL_TEXTURE_RECTANGLE_NV) {
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexImage2D(target)" );
            return GL_TRUE;
         }
      }
      else if (target != GL_TEXTURE_2D) {
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexImage2D(target)" );
a1054 6
      if (target == GL_TEXTURE_2D)
         maxLevels = ctx->Const.MaxTextureLevels;
      else if (target == GL_TEXTURE_RECTANGLE_NV)
         maxLevels = 1;
      else
         maxLevels = ctx->Const.MaxCubeTextureLevels;
a1056 3
   ASSERT(maxLevels > 0);
   maxTextureSize = 1 << (maxLevels - 1);

d1058 1
a1058 1
   if (border != 0 && border != 1) {
d1061 1
a1061 1
      _mesa_error(ctx, GL_INVALID_VALUE, message);
d1066 1
a1066 1
   if (width < 2 * border || width > 2 + maxTextureSize
d1069 2
a1070 2
      sprintf(message, "glCopyTexImage%dD(width=%d)", dimensions, width);
      _mesa_error(ctx, GL_INVALID_VALUE, message);
d1076 1
a1076 1
      if (height < 2 * border || height > 2 + maxTextureSize
d1079 2
a1080 2
         sprintf(message, "glCopyTexImage%dD(height=%d)", dimensions, height);
         _mesa_error(ctx, GL_INVALID_VALUE, message);
d1089 1
a1089 1
         _mesa_error(ctx, GL_INVALID_VALUE, "glCopyTexImage2D(width != height)");
d1095 1
a1095 1
   if (level < 0 || level >= maxLevels) {
d1097 2
a1098 2
      sprintf(message, "glCopyTexImage%dD(level=%d)", dimensions, level);
      _mesa_error(ctx, GL_INVALID_VALUE, message);
d1102 1
a1102 1
   iformat = _mesa_base_tex_format(ctx, internalFormat);
d1106 1
a1106 1
      _mesa_error(ctx, GL_INVALID_VALUE, message);
a1122 2
   GLint maxLevels = 0;
   GLboolean compressed;
d1126 1
a1126 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage1D(target)" );
a1128 1
      maxLevels = ctx->Const.MaxTextureLevels;
d1131 1
a1131 1
      if (ctx->Extensions.ARB_texture_cube_map) {
d1135 1
a1135 1
            _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage2D(target)" );
d1140 1
a1140 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage2D(target)" );
a1142 4
      if (target == GL_TEXTURE_2D)
         maxLevels = ctx->Const.MaxTextureLevels;
      else
         maxLevels = ctx->Const.MaxCubeTextureLevels;
d1146 1
a1146 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage3D(target)" );
a1148 1
      maxLevels = ctx->Const.Max3DTextureLevels;
d1151 1
a1151 3
   ASSERT(maxLevels > 0);

   if (level < 0 || level >= maxLevels) {
d1153 2
a1154 2
      sprintf(message, "glCopyTexSubImage%dD(level=%d)", dimensions, level);
      _mesa_error(ctx, GL_INVALID_VALUE, message);
d1160 2
a1161 2
      sprintf(message, "glCopyTexSubImage%dD(width=%d)", dimensions, width);
      _mesa_error(ctx, GL_INVALID_VALUE, message);
d1166 2
a1167 2
      sprintf(message, "glCopyTexSubImage%dD(height=%d)", dimensions, height);
      _mesa_error(ctx, GL_INVALID_VALUE, message);
d1171 1
a1171 1
   teximage = _mesa_select_tex_image(ctx, texUnit, target, level);
d1175 1
a1175 1
      _mesa_error(ctx, GL_INVALID_OPERATION, message);
d1181 2
a1182 2
      sprintf(message, "glCopyTexSubImage%dD(xoffset=%d)", dimensions, xoffset);
      _mesa_error(ctx, GL_INVALID_VALUE, message);
d1185 1
a1185 1
   if (xoffset + width > (GLint) (teximage->Width + teximage->Border)) {
d1188 1
a1188 1
      _mesa_error(ctx, GL_INVALID_VALUE, message);
d1194 2
a1195 2
         sprintf(message, "glCopyTexSubImage%dD(yoffset=%d)", dimensions, yoffset);
         _mesa_error(ctx, GL_INVALID_VALUE, message);
d1199 1
a1199 1
      if (yoffset + height > (GLint) (teximage->Height + teximage->Border)) {
d1202 1
a1202 1
         _mesa_error(ctx, GL_INVALID_VALUE, message);
d1211 1
a1211 1
         _mesa_error(ctx, GL_INVALID_VALUE, message);
d1214 1
a1214 1
      if (zoffset > (GLint) (teximage->Depth + teximage->Border)) {
d1217 1
a1217 20
         _mesa_error(ctx, GL_INVALID_VALUE, message);
         return GL_TRUE;
      }
   }

   compressed = is_compressed_format(ctx, teximage->IntFormat);
   if (compressed) {
      if (xoffset != -((GLint)teximage->Border)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexSubImage1/2/3D(xoffset != -border");
         return GL_TRUE;
      }
      if (dimensions > 1 && yoffset != -((GLint)teximage->Border)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexSubImage2/3D(yoffset != -border");
         return GL_TRUE;
      }
      if (dimensions > 2 && zoffset != -((GLint)teximage->Border)) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexSubImage3D(zoffset != -border");
a1221 5
   if (teximage->IntFormat == GL_YCBCR_MESA) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glCopyTexSubImage2D");
      return GL_TRUE;
   }

a1227 10
void
_mesa_GetTexImage( GLenum target, GLint level, GLenum format,
                   GLenum type, GLvoid *pixels )
{
   const struct gl_texture_unit *texUnit;
   const struct gl_texture_object *texObj;
   const struct gl_texture_image *texImage;
   GLint maxLevels = 0;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1229 32
a1260 5
   texUnit = &(ctx->Texture.Unit[ctx->Texture.CurrentUnit]);
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   if (!texObj || is_proxy_target(target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexImage(target)");
      return;
d1263 58
a1320 124
   if (target == GL_TEXTURE_1D || target == GL_TEXTURE_2D) {
      maxLevels = ctx->Const.MaxTextureLevels;
   }
   else if (target == GL_TEXTURE_3D) {
      maxLevels = ctx->Const.Max3DTextureLevels;
   }
   else if (target == GL_TEXTURE_RECTANGLE_NV) {
      maxLevels = 1;
   }
   else {
      maxLevels = ctx->Const.MaxCubeTextureLevels;
   }

   ASSERT(maxLevels > 0);

   if (level < 0 || level >= maxLevels) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glGetTexImage(level)" );
      return;
   }

   if (_mesa_sizeof_packed_type(type) <= 0) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexImage(type)" );
      return;
   }

   if (_mesa_components_in_format(format) <= 0 ||
       format == GL_STENCIL_INDEX) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexImage(format)" );
      return;
   }

   if (!ctx->Extensions.EXT_paletted_texture && is_index_format(format)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexImage(format)");
   }

   if (!ctx->Extensions.SGIX_depth_texture && format == GL_DEPTH_COMPONENT) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexImage(format)");
   }

   if (!ctx->Extensions.MESA_ycbcr_texture && format == GL_YCBCR_MESA) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexImage(format)");
   }

   /* XXX what if format/type doesn't match texture format/type? */

   if (!pixels)
      return;

   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   if (!texImage) {
      /* invalid mipmap level, not an error */
      return;
   }

   if (!texImage->Data) {
      /* no image data, not an error */
      return;
   }

   {
      const GLint width = texImage->Width;
      const GLint height = texImage->Height;
      const GLint depth = texImage->Depth;
      GLint img, row;
      for (img = 0; img < depth; img++) {
         for (row = 0; row < height; row++) {
            /* compute destination address in client memory */
            GLvoid *dest = _mesa_image_address( &ctx->Pack, pixels,
                                                width, height, format, type,
                                                img, row, 0);
            assert(dest);

            if (format == GL_COLOR_INDEX) {
               GLuint indexRow[MAX_WIDTH];
               GLint col;
               for (col = 0; col < width; col++) {
                  (*texImage->FetchTexel)(texImage, col, row, img,
                                          (GLvoid *) &indexRow[col]);
               }
               _mesa_pack_index_span(ctx, width, type, dest,
                                     indexRow, &ctx->Pack,
                                     0 /* no image transfer */);
            }
            else if (format == GL_DEPTH_COMPONENT) {
               GLfloat depthRow[MAX_WIDTH];
               GLint col;
               for (col = 0; col < width; col++) {
                  (*texImage->FetchTexel)(texImage, col, row, img,
                                          (GLvoid *) &depthRow[col]);
               }
               _mesa_pack_depth_span(ctx, width, dest, type,
                                     depthRow, &ctx->Pack);
            }
            else if (format == GL_YCBCR_MESA) {
	       const GLint rowstride = texImage->RowStride;
               /* No pixel transfer */
               MEMCPY(dest, (const GLushort *) texImage->Data + row * rowstride,
                      width * sizeof(GLushort));
               /* check for byte swapping */
               if ((texImage->TexFormat->MesaFormat == MESA_FORMAT_YCBCR
                    && type == GL_UNSIGNED_SHORT_8_8_REV_MESA) ||
                   (texImage->TexFormat->MesaFormat == MESA_FORMAT_YCBCR_REV
                    && type == GL_UNSIGNED_SHORT_8_8_MESA)) {
                  if (!ctx->Pack.SwapBytes)
                     _mesa_swap2((GLushort *) dest, width);
               }
               else if (ctx->Pack.SwapBytes) {
                  _mesa_swap2((GLushort *) dest, width);
               }
            }
            else {
               /* general case:  convert row to RGBA format */
               GLchan rgba[MAX_WIDTH][4];
               GLint col;
               for (col = 0; col < width; col++) {
                  (*texImage->FetchTexel)(texImage, col, row, img,
                                          (GLvoid *) rgba[col]);
               }
               _mesa_pack_rgba_span(ctx, width, (const GLchan (*)[4])rgba,
                                    format, type, dest, &ctx->Pack,
                                    0 /* no image transfer */);
            } /* format */
         } /* row */
      } /* img */
d1322 1
a1325 1

a1333 1
   GLsizei postConvWidth = width;
d1335 1
a1335 5
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (is_color_format(internalFormat)) {
      _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);
   }
d1337 1
a1337 1
   if (target == GL_TEXTURE_1D) {
d1341 16
d1359 2
a1360 2
                              format, type, 1, postConvWidth, 1, 1, border)) {
         return;   /* error was recorded */
d1364 2
a1365 2
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d1371 1
a1371 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage1D");
d1375 3
a1377 3
      else if (texImage->Data && !texImage->IsClientData) {
         /* free the old texture data */
         MESA_PBUFFER_FREE(texImage->Data);
a1378 4
      texImage->Data = NULL;
      clear_teximage_fields(texImage); /* not really needed, but helpful */
      _mesa_init_teximage_fields(ctx, target, texImage, postConvWidth, 1, 1,
                                 border, internalFormat);
d1380 2
a1381 2
      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
         _mesa_update_state(ctx);
d1383 1
a1383 3
      ASSERT(ctx->Driver.TexImage1D);

#if 0 /* don't make default teximage anymore */
d1385 25
a1409 3
         (*ctx->Driver.TexImage1D)(ctx, target, level, internalFormat,
                                   width, border, format, type, pixels,
                                   &ctx->Unpack, texObj, texImage);
d1412 7
a1418 7
         GLubyte *dummy = make_null_texture(width, 1, 1, format);
         if (dummy) {
            (*ctx->Driver.TexImage1D)(ctx, target, level, internalFormat,
                                      width, border,
                                      format, GL_UNSIGNED_BYTE, dummy,
                                      &_mesa_native_packing, texObj, texImage);
            FREE(dummy);
a1420 17
#else
      /* <pixels> may be null! */
      (*ctx->Driver.TexImage1D)(ctx, target, level, internalFormat,
                                width, border, format, type, pixels,
                                &ctx->Unpack, texObj, texImage);
#endif

      ASSERT(texImage->TexFormat);
      if (!texImage->FetchTexel) {
         /* If driver didn't explicitly set this, use the default */
         texImage->FetchTexel = texImage->TexFormat->FetchTexel1D;
      }
      ASSERT(texImage->FetchTexel);

      if (texImage->IsCompressed) {
         ASSERT(texImage->CompressedSize > 0);
      }
d1423 2
a1424 2
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d1429 2
a1430 10
                                         format, type, 1,
                                         postConvWidth, 1, 1, border);
      if (!error) {
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, postConvWidth, 1, 1,
                                    border, internalFormat);
         ASSERT(ctx->Driver.TestProxyTexImage);
d1433 1
a1433 1
                                                  postConvWidth, 1, 1, border);
d1437 2
a1438 2
         if (level >= 0 && level < ctx->Const.MaxTextureLevels) {
            clear_teximage_fields(ctx->Texture.Proxy1D->Image[level]);
d1441 5
d1448 1
a1448 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage1D(target)" );
a1459 1
   GLsizei postConvWidth = width, postConvHeight = height;
d1461 1
a1461 6
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (is_color_format(internalFormat)) {
      _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth,
					 &postConvHeight);
   }
d1463 2
a1464 2
   if (target == GL_TEXTURE_2D ||
       (ctx->Extensions.ARB_texture_cube_map &&
d1466 1
a1466 4
        target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) ||
       (ctx->Extensions.NV_texture_rectangle &&
        target == GL_TEXTURE_RECTANGLE_NV)) {
      /* non-proxy target */
d1470 16
d1488 2
a1489 3
                              format, type, 2, postConvWidth, postConvHeight,
                              1, border)) {
         return;   /* error was recorded */
d1498 2
a1499 1
         _mesa_set_tex_image(texObj, target, level, texImage);
d1501 1
a1501 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage2D");
d1505 4
a1508 9
      else if (texImage->Data && !texImage->IsClientData) {
         /* free the old texture data */
         MESA_PBUFFER_FREE(texImage->Data);
      }
      texImage->Data = NULL;
      clear_teximage_fields(texImage); /* not really needed, but helpful */
      _mesa_init_teximage_fields(ctx, target, texImage,
                                 postConvWidth, postConvHeight,
                                 1, border, internalFormat);
d1510 3
a1512 2
      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
         _mesa_update_state(ctx);
d1514 1
a1514 3
      ASSERT(ctx->Driver.TexImage2D);

#if 0 /* don't make default teximage anymore */
d1516 25
a1540 3
         (*ctx->Driver.TexImage2D)(ctx, target, level, internalFormat,
                                   width, height, border, format, type, pixels,
                                   &ctx->Unpack, texObj, texImage);
d1543 7
a1549 7
         GLubyte *dummy = make_null_texture(width, height, 1, format);
         if (dummy) {
            (*ctx->Driver.TexImage2D)(ctx, target, level, internalFormat,
                                      width, height, border,
                                      format, GL_UNSIGNED_BYTE, dummy,
                                      &_mesa_native_packing, texObj, texImage);
            FREE(dummy);
a1551 6
#else
      /* <pixels> may be null! */
      (*ctx->Driver.TexImage2D)(ctx, target, level, internalFormat,
                                width, height, border, format, type, pixels,
                                &ctx->Unpack, texObj, texImage);
#endif
d1553 6
a1558 9
      ASSERT(texImage->TexFormat);
      if (!texImage->FetchTexel) {
         /* If driver didn't explicitly set this, use the default */
         texImage->FetchTexel = texImage->TexFormat->FetchTexel2D;
      }
      ASSERT(texImage->FetchTexel);

      if (texImage->IsCompressed) {
         ASSERT(texImage->CompressedSize > 0);
d1560 1
d1563 2
a1564 2
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d1566 1
a1566 5
   else if (target == GL_PROXY_TEXTURE_2D ||
            (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB &&
             ctx->Extensions.ARB_texture_cube_map) ||
            (target == GL_PROXY_TEXTURE_RECTANGLE_NV &&
             ctx->Extensions.NV_texture_rectangle)) {
d1569 2
a1570 10
				format, type, 2,
				postConvWidth, postConvHeight, 1, border);
      if (!error) {
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, postConvWidth,
                                    postConvHeight, 1, border, internalFormat);
         ASSERT(ctx->Driver.TestProxyTexImage);
d1572 2
a1573 2
                                    internalFormat, format, type,
                                    postConvWidth, postConvHeight, 1, border);
d1577 2
a1578 4
         const GLint maxLevels = (target == GL_PROXY_TEXTURE_2D) ?
            ctx->Const.MaxTextureLevels : ctx->Const.MaxCubeTextureLevels;
         if (level >= 0 && level < maxLevels) {
            clear_teximage_fields(ctx->Texture.Proxy2D->Image[level]);
d1581 6
d1589 1
a1589 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage2D(target)" );
d1600 1
a1600 1
_mesa_TexImage3D( GLenum target, GLint level, GLenum internalFormat,
d1606 1
a1606 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1608 1
a1608 1
   if (target == GL_TEXTURE_3D) {
d1612 16
d1629 1
a1629 1
      if (texture_error_check(ctx, target, level, (GLint) internalFormat,
d1631 1
a1631 1
         return;   /* error was recorded */
d1635 2
a1636 2
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d1642 1
a1642 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage3D");
d1646 3
a1648 2
      else if (texImage->Data && !texImage->IsClientData) {
         MESA_PBUFFER_FREE(texImage->Data);
a1649 4
      texImage->Data = NULL;
      clear_teximage_fields(texImage); /* not really needed, but helpful */
      _mesa_init_teximage_fields(ctx, target, texImage, width, height, depth,
                                 border, internalFormat);
d1651 3
a1653 2
      if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
         _mesa_update_state(ctx);
d1655 1
a1655 3
      ASSERT(ctx->Driver.TexImage3D);

#if 0 /* don't make default teximage anymore */
d1657 25
a1681 4
         (*ctx->Driver.TexImage3D)(ctx, target, level, (GLint) internalFormat,
                                   width, height, depth, border,
                                   format, type, pixels,
                                   &ctx->Unpack, texObj, texImage);
d1684 7
a1690 8
         GLubyte *dummy = make_null_texture(width, height, depth, format);
         if (dummy) {
            (*ctx->Driver.TexImage3D)(ctx, target, level,
                                      (GLint) internalFormat,
                                      width, height, depth, border,
                                      format, GL_UNSIGNED_BYTE, dummy,
                                      &_mesa_native_packing, texObj, texImage);
            FREE(dummy);
a1692 17
#else
      /* <pixels> may be null! */
      (*ctx->Driver.TexImage3D)(ctx, target, level, internalFormat,
                                width, height, depth, border, format, type,
                                pixels, &ctx->Unpack, texObj, texImage);
#endif

      ASSERT(texImage->TexFormat);
      if (!texImage->FetchTexel) {
         /* If driver didn't explicitly set this, use the default */
         texImage->FetchTexel = texImage->TexFormat->FetchTexel3D;
      }
      ASSERT(texImage->FetchTexel);

      if (texImage->IsCompressed) {
         ASSERT(texImage->CompressedSize > 0);
      }
d1695 2
a1696 2
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d1702 1
a1702 8
      if (!error) {
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                    border, internalFormat);
         ASSERT(ctx->Driver.TestProxyTexImage);
d1709 2
a1710 2
         if (level >= 0 && level < ctx->Const.Max3DTextureLevels) {
            clear_teximage_fields(ctx->Texture.Proxy3D->Image[level]);
d1713 5
d1720 1
a1720 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexImage3D(target)" );
d1732 1
a1732 1
   _mesa_TexImage3D(target, level, internalFormat, width, height,
d1737 317
a2060 1
   GLsizei postConvWidth = width;
d2064 1
d2066 1
a2066 9
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);

   /* XXX should test internal format */
   if (is_color_format(format)) {
      _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);
   }
d2069 1
a2069 1
                              postConvWidth, 1, 1, format, type)) {
d2074 2
a2075 2
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
a2080 2
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
d2082 53
a2134 5
   ASSERT(ctx->Driver.TexSubImage1D);
   (*ctx->Driver.TexSubImage1D)(ctx, target, level, xoffset, width,
                                format, type, pixels, &ctx->Unpack,
                                texObj, texImage);
   ctx->NewState |= _NEW_TEXTURE;
a2144 1
   GLsizei postConvWidth = width, postConvHeight = height;
d2148 1
d2150 1
a2150 10
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);

   /* XXX should test internal format */
   if (is_color_format(format)) {
      _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth,
                                         &postConvHeight);
   }
d2153 1
a2153 1
                             postConvWidth, postConvHeight, 1, format, type)) {
d2159 1
a2159 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2165 83
a2247 9
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
   yoffset += texImage->Border;

   ASSERT(ctx->Driver.TexSubImage2D);
   (*ctx->Driver.TexSubImage2D)(ctx, target, level, xoffset, yoffset,
                                width, height, format, type, pixels,
                                &ctx->Unpack, texObj, texImage);
   ctx->NewState |= _NEW_TEXTURE;
d2262 1
d2264 1
a2264 4
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);
d2272 2
a2273 2
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2279 114
a2392 12
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
   yoffset += texImage->Border;
   zoffset += texImage->Border;

   ASSERT(ctx->Driver.TexSubImage3D);
   (*ctx->Driver.TexSubImage3D)(ctx, target, level,
                                xoffset, yoffset, zoffset,
                                width, height, depth,
                                format, type, pixels,
                                &ctx->Unpack, texObj, texImage );
   ctx->NewState |= _NEW_TEXTURE;
a2402 4
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLsizei postConvWidth = width;
d2404 1
a2404 8
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);

   if (is_color_format(internalFormat)) {
      _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);
   }
d2407 1
a2407 1
                               postConvWidth, 1, border))
d2410 11
a2420 8
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   if (!texImage) {
      texImage = _mesa_alloc_texture_image();
      _mesa_set_tex_image(texObj, target, level, texImage);
      if (!texImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage1D");
a2422 10
   }
   else if (texImage->Data && !texImage->IsClientData) {
      /* free the old texture data */
      MESA_PBUFFER_FREE(texImage->Data);
   }
   texImage->Data = NULL;

   clear_teximage_fields(texImage); /* not really needed, but helpful */
   _mesa_init_teximage_fields(ctx, target, texImage, postConvWidth, 1, 1,
                              border, internalFormat);
d2424 6
d2431 1
a2431 8
   ASSERT(ctx->Driver.CopyTexImage1D);
   (*ctx->Driver.CopyTexImage1D)(ctx, target, level, internalFormat,
                                 x, y, width, border);

   ASSERT(texImage->TexFormat);
   if (!texImage->FetchTexel) {
      /* If driver didn't explicitly set this, use the default */
      texImage->FetchTexel = texImage->TexFormat->FetchTexel1D;
a2432 5
   ASSERT(texImage->FetchTexel);

   /* state update */
   texObj->Complete = GL_FALSE;
   ctx->NewState |= _NEW_TEXTURE;
a2441 4
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLsizei postConvWidth = width, postConvHeight = height;
d2443 1
a2443 9
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);

   if (is_color_format(internalFormat)) {
      _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth,
                                         &postConvHeight);
   }
d2446 1
a2446 1
                               postConvWidth, postConvHeight, border))
d2449 11
a2459 8
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
   if (!texImage) {
      texImage = _mesa_alloc_texture_image();
      _mesa_set_tex_image(texObj, target, level, texImage);
      if (!texImage) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage2D");
a2461 11
   }
   else if (texImage->Data && !texImage->IsClientData) {
      /* free the old texture data */
      MESA_PBUFFER_FREE(texImage->Data);
   }
   texImage->Data = NULL;

   clear_teximage_fields(texImage); /* not really needed, but helpful */
   _mesa_init_teximage_fields(ctx, target, texImage,
                              postConvWidth, postConvHeight, 1,
                              border, internalFormat);
d2463 6
a2468 3
   ASSERT(ctx->Driver.CopyTexImage2D);
   (*ctx->Driver.CopyTexImage2D)(ctx, target, level, internalFormat,
                                 x, y, width, height, border);
d2470 1
a2470 4
   ASSERT(texImage->TexFormat);
   if (!texImage->FetchTexel) {
      /* If driver didn't explicitly set this, use the default */
      texImage->FetchTexel = texImage->TexFormat->FetchTexel2D;
a2471 5
   ASSERT(texImage->FetchTexel);

   /* state update */
   texObj->Complete = GL_FALSE;
   ctx->NewState |= _NEW_TEXTURE;
a2479 4
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLsizei postConvWidth = width;
d2481 1
a2481 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2483 3
a2485 2
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);
d2487 8
a2494 2
   /* XXX should test internal format */
   _mesa_adjust_image_for_convolution(ctx, 1, &postConvWidth, NULL);
d2496 3
a2498 3
   if (copytexsubimage_error_check(ctx, 1, target, level,
                                   xoffset, 0, 0, postConvWidth, 1))
      return;
d2500 6
a2505 3
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2507 6
a2512 2
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
d2514 2
a2515 3
   ASSERT(ctx->Driver.CopyTexSubImage1D);
   (*ctx->Driver.CopyTexSubImage1D)(ctx, target, level, xoffset, x, y, width);
   ctx->NewState |= _NEW_TEXTURE;
a2524 4
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLsizei postConvWidth = width, postConvHeight = height;
d2526 1
a2526 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2528 3
a2530 2
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);
d2532 8
a2539 2
   /* XXX should test internal format */
   _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth, &postConvHeight);
d2541 10
a2550 3
   if (copytexsubimage_error_check(ctx, 2, target, level, xoffset, yoffset, 0,
                                   postConvWidth, postConvHeight))
      return;
d2552 6
a2557 3
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2559 2
a2560 8
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
   yoffset += texImage->Border;

   ASSERT(ctx->Driver.CopyTexSubImage2D);
   (*ctx->Driver.CopyTexSubImage2D)(ctx, target, level,
                                    xoffset, yoffset, x, y, width, height);
   ctx->NewState |= _NEW_TEXTURE;
a2569 4
   struct gl_texture_unit *texUnit;
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLsizei postConvWidth = width, postConvHeight = height;
d2571 1
a2571 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2573 12
a2584 2
   if (ctx->NewState & _IMAGE_NEW_TRANSFER_STATE)
      _mesa_update_state(ctx);
d2586 3
a2588 2
   /* XXX should test internal format */
   _mesa_adjust_image_for_convolution(ctx, 2, &postConvWidth, &postConvHeight);
d2590 6
a2595 3
   if (copytexsubimage_error_check(ctx, 3, target, level, xoffset, yoffset,
                                   zoffset, postConvWidth, postConvHeight))
      return;
d2597 6
a2602 3
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2604 2
a2605 10
   /* If we have a border, xoffset=-1 is legal.  Bias by border width */
   xoffset += texImage->Border;
   yoffset += texImage->Border;
   zoffset += texImage->Border;

   ASSERT(ctx->Driver.CopyTexSubImage3D);
   (*ctx->Driver.CopyTexSubImage3D)(ctx, target, level,
                                    xoffset, yoffset, zoffset,
                                    x, y, width, height);
   ctx->NewState |= _NEW_TEXTURE;
d2617 1
a2617 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2626 1
a2626 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage1DARB");
d2637 1
d2645 2
a2646 2
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2652 1
a2652 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage1DARB");
d2656 38
a2693 2
      else if (texImage->Data && !texImage->IsClientData) {
         MESA_PBUFFER_FREE(texImage->Data);
d2695 8
a2702 12
      texImage->Data = NULL;

      _mesa_init_teximage_fields(ctx, target, texImage, width, 1, 1,
                                 border, internalFormat);

      if (ctx->Extensions.ARB_texture_compression) {
         ASSERT(ctx->Driver.CompressedTexImage1D);
         (*ctx->Driver.CompressedTexImage1D)(ctx, target, level,
                                             internalFormat, width, border,
                                             imageSize, data,
                                             texObj, texImage);
         ASSERT(texImage->CompressedSize > 0); /* sanity */
d2706 2
a2707 2
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d2713 1
a2713 8
      if (!error) {
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, 1, 1,
                                    border, internalFormat);
         ASSERT(ctx->Driver.TestProxyTexImage);
d2720 2
a2721 2
         if (level >= 0 && level < ctx->Const.MaxTextureLevels) {
            clear_teximage_fields(ctx->Texture.Proxy1D->Image[level]);
d2724 5
d2731 1
a2731 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage1DARB(target)");
d2744 1
a2744 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2753 1
a2753 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage2DARB");
d2760 2
a2761 2
   if (target == GL_TEXTURE_2D ||
       (ctx->Extensions.ARB_texture_cube_map &&
d2763 1
a2763 3
        target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) ||
       (ctx->Extensions.NV_texture_rectangle &&
        target == GL_TEXTURE_RECTANGLE_NV)) {
d2767 1
d2770 1
a2770 1
                              GL_NONE, GL_NONE, 2, width, height, 1, border)) {
d2775 2
a2776 2
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2782 1
a2782 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage2DARB");
d2786 43
a2828 2
      else if (texImage->Data && !texImage->IsClientData) {
         MESA_PBUFFER_FREE(texImage->Data);
d2830 8
a2837 12
      texImage->Data = NULL;

      _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                 border, internalFormat);

      if (ctx->Extensions.ARB_texture_compression) {
         ASSERT(ctx->Driver.CompressedTexImage2D);
         (*ctx->Driver.CompressedTexImage2D)(ctx, target, level,
                                             internalFormat, width, height,
                                             border, imageSize, data,
                                             texObj, texImage);
         ASSERT(texImage->CompressedSize > 0); /* sanity */
d2841 2
a2842 2
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d2848 1
a2848 8
      if (!error) {
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                    border, internalFormat);
         ASSERT(ctx->Driver.TestProxyTexImage);
d2855 2
a2856 4
         const GLint maxLevels = (target == GL_PROXY_TEXTURE_2D) ?
            ctx->Const.MaxTextureLevels : ctx->Const.MaxCubeTextureLevels;
         if (level >= 0 && level < maxLevels) {
            clear_teximage_fields(ctx->Texture.Proxy2D->Image[level]);
d2859 5
d2866 1
a2866 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage2DARB(target)");
d2879 1
a2879 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2888 1
a2888 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage3DARB");
d2899 1
d2902 1
a2902 1
                          GL_NONE, GL_NONE, 3, width, height, depth, border)) {
d2907 2
a2908 2
      texObj = _mesa_select_tex_object(ctx, texUnit, target);
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d2914 1
a2914 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage3DARB");
d2918 40
a2957 2
      else if (texImage->Data && !texImage->IsClientData) {
         MESA_PBUFFER_FREE(texImage->Data);
d2959 8
a2966 13
      texImage->Data = NULL;

      _mesa_init_teximage_fields(ctx, target, texImage, width, height, depth,
                                 border, internalFormat);

      if (ctx->Extensions.ARB_texture_compression) {
         ASSERT(ctx->Driver.CompressedTexImage3D);
         (*ctx->Driver.CompressedTexImage3D)(ctx, target, level,
                                             internalFormat,
                                             width, height, depth,
                                             border, imageSize, data,
                                             texObj, texImage);
         ASSERT(texImage->CompressedSize > 0); /* sanity */
d2970 2
a2971 2
      texObj->Complete = GL_FALSE;
      ctx->NewState |= _NEW_TEXTURE;
d2976 2
a2977 10
                            GL_NONE, GL_NONE, 3, width, height, depth, border);
      if (!error) {
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage,
                                    width, height, depth,
                                    border, internalFormat);
         ASSERT(ctx->Driver.TestProxyTexImage);
d2984 2
a2985 2
         if (level >= 0 && level < ctx->Const.Max3DTextureLevels) {
            clear_teximage_fields(ctx->Texture.Proxy3D->Image[level]);
d2988 5
d2995 1
a2995 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage3DARB(target)");
d3009 1
d3011 1
a3011 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3020 1
a3020 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d3027 7
a3033 4
      (*ctx->Driver.CompressedTexSubImage1D)(ctx, target, level,
                                             xoffset, width,
                                             format, imageSize, data,
                                             texObj, texImage);
a3034 1
   ctx->NewState |= _NEW_TEXTURE;
d3047 1
d3049 1
a3049 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3058 1
a3058 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d3065 8
a3072 4
      (*ctx->Driver.CompressedTexSubImage2D)(ctx, target, level,
                                             xoffset, yoffset, width, height,
                                             format, imageSize, data,
                                             texObj, texImage);
a3073 1
   ctx->NewState |= _NEW_TEXTURE;
d3086 1
d3088 1
a3088 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3097 1
a3097 1
   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d3104 8
a3111 5
      (*ctx->Driver.CompressedTexSubImage3D)(ctx, target, level,
                                             xoffset, yoffset, zoffset,
                                             width, height, depth,
                                             format, imageSize, data,
                                             texObj, texImage);
a3112 1
   ctx->NewState |= _NEW_TEXTURE;
a3118 1
   const struct gl_texture_unit *texUnit;
a3120 1
   GLint maxLevels;
d3122 1
a3122 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d3124 2
a3125 4
   texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   if (!texObj) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetCompressedTexImageARB");
d3129 40
a3168 8
   if (target == GL_TEXTURE_1D || target == GL_TEXTURE_2D) {
      maxLevels = ctx->Const.MaxTextureLevels;
   }
   else if (target == GL_TEXTURE_3D) {
      maxLevels = ctx->Const.Max3DTextureLevels;
   }
   else {
      maxLevels = ctx->Const.MaxCubeTextureLevels;
a3170 13
   ASSERT(maxLevels > 0);

   if (level < 0 || level >= maxLevels) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetCompressedTexImageARB(level)");
      return;
   }

   if (is_proxy_target(target)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetCompressedTexImageARB(target)");
      return;
   }

   texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
d3172 2
a3173 2
      /* probably invalid mipmap level */
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetCompressedTexImageARB(level)");
d3178 1
a3178 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetCompressedTexImageARB");
d3185 1
a3185 2
   if (ctx->Extensions.ARB_texture_compression) {
      ASSERT(ctx->Driver.GetCompressedTexImage);
d3188 3
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/extras/Mesa/src/teximage.c,v 1.24 2003/10/22 15:27:40 tsi Exp $ */
d4 1
a4 1
 * Version:  5.0.2
d6 1
a6 1
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
d26 4
a33 1
#include "imports.h"
d35 1
a37 1
#include "texcompress.h"
d43 2
d57 2
a58 2
#if 0
static void PrintTexture(GLcontext *ctx, const struct gl_texture_image *img)
d67 1
a67 1
      _mesa_printf("No texture data\n");
d95 1
a95 1
            _mesa_printf("%02x  ", data[0]);
d97 1
a97 1
            _mesa_printf("%02x%02x  ", data[0], data[1]);
d99 1
a99 1
            _mesa_printf("%02x%02x%02x  ", data[0], data[1], data[2]);
d101 2
a102 2
            _mesa_printf("%02x%02x%02x%02x  ", data[0], data[1], data[2], data[3]);
         data += (img->RowStride - img->Width) * c;
d104 2
a105 1
      _mesa_printf("\n");
a145 4
 *
 * This is the format which is used during texture application (i.e. the
 * texture format and env mode determine the arithmetic used.
 *
d155 6
a228 43

      /* GL_ARB_texture_compression */
      case GL_COMPRESSED_ALPHA:
         if (ctx->Extensions.ARB_texture_compression)
            return GL_ALPHA;
         else
            return -1;
      case GL_COMPRESSED_LUMINANCE:
         if (ctx->Extensions.ARB_texture_compression)
            return GL_LUMINANCE;
         else
            return -1;
      case GL_COMPRESSED_LUMINANCE_ALPHA:
         if (ctx->Extensions.ARB_texture_compression)
            return GL_LUMINANCE_ALPHA;
         else
            return -1;
      case GL_COMPRESSED_INTENSITY:
         if (ctx->Extensions.ARB_texture_compression)
            return GL_INTENSITY;
         else
            return -1;
      case GL_COMPRESSED_RGB:
         if (ctx->Extensions.ARB_texture_compression)
            return GL_RGB;
         else
            return -1;
      case GL_COMPRESSED_RGBA:
         if (ctx->Extensions.ARB_texture_compression)
            return GL_RGBA;
         else
            return -1;
      case GL_COMPRESSED_RGB_FXT1_3DFX:
         if (ctx->Extensions.TDFX_texture_compression_FXT1)
            return GL_RGB;
         else
            return -1;
      case GL_COMPRESSED_RGBA_FXT1_3DFX:
         if (ctx->Extensions.TDFX_texture_compression_FXT1)
            return GL_RGBA;
         else
            return -1;

a233 1

d316 3
a318 4
/**
 * Return GL_TRUE if internalFormat is a supported compressed format,
 * return GL_FALSE otherwise.
 * \param - internalFormat - the internal format token provided by the user
d321 1
a321 1
is_compressed_format(GLenum internalFormat)
d323 3
a325 3
   switch (internalFormat) {
      case GL_COMPRESSED_RGB_FXT1_3DFX:
      case GL_COMPRESSED_RGBA_FXT1_3DFX:
d327 1
a327 1
      default:
d330 1
d334 1
d414 1
a414 2
           target == GL_PROXY_TEXTURE_CUBE_MAP_ARB ||
           target == GL_PROXY_TEXTURE_RECTANGLE_NV);
a544 35
/*
 * Return the maximum number of allows mipmap levels for the given
 * texture target.
 */
GLint
_mesa_max_texture_levels(GLcontext *ctx, GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
      return ctx->Const.MaxTextureLevels;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      return ctx->Const.Max3DTextureLevels;
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
      return ctx->Const.MaxCubeTextureLevels;
      break;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_PROXY_TEXTURE_RECTANGLE_NV:
      return 1;
      break;
   default:
      return 0; /* bad target */
   }
}


d650 1
a650 1
   img->RowStride = width;
d664 1
a664 19
   img->IsCompressed = is_compressed_format(internalFormat);
   if (img->IsCompressed)
      img->CompressedSize = _mesa_compressed_texture_size(ctx, width, height,
                                                       depth, internalFormat);
   else
      img->CompressedSize = 0;

   /* Compute Width/Height/DepthScale for mipmap lod computation */
   if (target == GL_TEXTURE_RECTANGLE_NV) {
      /* scale = 1.0 since texture coords directly map to texels */
      img->WidthScale = 1.0;
      img->HeightScale = 1.0;
      img->DepthScale = 1.0;
   }
   else {
      img->WidthScale = (GLfloat) img->Width;
      img->HeightScale = (GLfloat) img->Height;
      img->DepthScale = (GLfloat) img->Depth;
   }
d684 1
d771 3
a773 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%dD(border=%d)", dimensions, border);
d787 3
a789 2
            _mesa_error(ctx, GL_INVALID_VALUE,
                        "glTexImage%dD(width=%d)", dimensions, width);
d797 3
a799 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%dD(width=%d)", dimensions, width);
d809 3
a811 2
            _mesa_error(ctx, GL_INVALID_VALUE,
                        "glTexImage%dD(height=%d)", dimensions, height);
d820 3
a822 2
            _mesa_error(ctx, GL_INVALID_VALUE,
                        "glTexImage%dD(height=%d)", dimensions, height);
d844 3
a846 2
            _mesa_error( ctx, GL_INVALID_VALUE,
                         "glTexImage3D(depth=%d)", depth );
d857 3
a859 2
            _mesa_error(ctx, GL_INVALID_VALUE,
                        "glTexImage2D(level=%d)", level);
d866 3
a868 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%dD(level=%d)", dimensions, level);
d882 2
a883 1
   if (_mesa_base_tex_format(ctx, internalFormat) < 0) {
d885 4
a888 3
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glTexImage%dD(internalFormat=0x%x)",
                     dimensions, internalFormat);
d893 4
a896 1
   if (!_mesa_is_legal_format_and_type(format, type)) {
d901 3
a903 2
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexImage%dD(format or type)", dimensions);
d908 1
a908 1
   if (format == GL_YCBCR_MESA || internalFormat == GL_YCBCR_MESA) {
d911 1
a911 1
          internalFormat != GL_YCBCR_MESA ||
d914 7
a920 5
         char message[100];
         _mesa_sprintf(message,
                 "glTexImage%d(format/type/internalFormat YCBCR mismatch",
                 dimensions);
         _mesa_error(ctx, GL_INVALID_ENUM, message);
d934 1
a934 1
            _mesa_sprintf(message,
a942 26
   if (is_compressed_format(internalFormat)) {
      if (target == GL_TEXTURE_2D || target == GL_PROXY_TEXTURE_2D) {
         /* OK */
      }
      else if (ctx->Extensions.ARB_texture_cube_map &&
               (target == GL_PROXY_TEXTURE_CUBE_MAP ||
                (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X &&
                 target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z))) {
         /* OK */
      }
      else {
         if (!isProxy) {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexImage%d(target)", dimensions);
            return GL_TRUE;
         }
      }
      if (border != 0) {
         if (!isProxy) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glTexImage%D(border!=0)", dimensions);
         }
         return GL_TRUE;
      }
   }

d965 1
d1011 3
a1013 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glTexSubImage2D(level=%d)", level);
d1018 3
a1020 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexSubImage%dD(width=%d)", dimensions, width);
d1024 3
a1026 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glTexSubImage%dD(height=%d)", dimensions, height);
d1030 3
a1032 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glTexSubImage%dD(depth=%d)", dimensions, depth);
d1039 1
a1039 1
      _mesa_error(ctx, GL_INVALID_OPERATION, "glTexSubImage2D");
d1072 6
a1077 3
   if (!_mesa_is_legal_format_and_type(format, type)) {
      _mesa_error(ctx, GL_INVALID_ENUM,
                  "glTexSubImage%dD(format or type)", dimensions);
d1081 4
a1084 18
   if (destTex->IsCompressed) {
      const struct gl_texture_unit *texUnit;
      const struct gl_texture_image *texImage;
      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      texImage = _mesa_select_tex_image(ctx, texUnit, target, level);

      if (target == GL_TEXTURE_2D || target == GL_PROXY_TEXTURE_2D) {
         /* OK */
      }
      else if (ctx->Extensions.ARB_texture_cube_map &&
               (target == GL_PROXY_TEXTURE_CUBE_MAP ||
                (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X &&
                 target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z))) {
         /* OK */
      }
      else {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexSubImage%D(target)", dimensions);
d1087 1
a1087 2
      /* offset must be multiple of 4 */
      if ((xoffset & 3) || (yoffset & 3)) {
d1089 1
a1089 1
                     "glTexSubImage%D(xoffset or yoffset)", dimensions);
d1092 1
a1092 2
      /* size must be multiple of 4 or equal to whole texture size */
      if ((width & 3) && (GLuint) width != texImage->Width) {
d1094 1
a1094 1
                     "glTexSubImage%D(width)", dimensions);
d1096 1
a1096 6
      }         
      if ((height & 3) && (GLuint) height != texImage->Height) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glTexSubImage%D(width)", dimensions);
         return GL_TRUE;
      }         
d1113 1
d1154 3
a1156 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%dD(border)", dimensions);
d1163 3
a1165 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%dD(width=%d)", dimensions, width);
d1173 3
a1175 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexImage%dD(height=%d)", dimensions, height);
d1191 3
a1193 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%dD(level=%d)", dimensions, level);
d1197 5
a1201 3
   if (_mesa_base_tex_format(ctx, internalFormat) < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexImage%dD(internalFormat)", dimensions);
a1204 13
   if (is_compressed_format(internalFormat)) {
      if (target != GL_TEXTURE_2D) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glCopyTexImage%d(target)", dimensions);
         return GL_TRUE;
      }
      if (border != 0) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glCopyTexImage%D(border!=0)", dimensions);
         return GL_TRUE;
      }
   }

d1219 1
d1229 4
a1232 9
      if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
          target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage2D(target)" );
            return GL_TRUE;
         }
      }
      else if (target == GL_TEXTURE_RECTANGLE_NV) {
         if (!ctx->Extensions.NV_texture_rectangle) {
a1242 2
      else if (target == GL_TEXTURE_RECTANGLE_NV)
         maxLevels = 1;
d1257 3
a1259 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(level=%d)", dimensions, level);
d1264 3
a1266 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(width=%d)", dimensions, width);
d1270 3
a1272 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(height=%d)", dimensions, height);
d1278 3
a1280 3
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCopyTexSubImage%dD(undefined texture level: %d)",
                  dimensions, level);
d1285 3
a1287 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(xoffset=%d)", dimensions, xoffset);
d1291 3
a1293 2
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glCopyTexSubImage%dD(xoffset+width)", dimensions);
d1298 3
a1300 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(yoffset=%d)", dimensions, yoffset);
d1305 3
a1307 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(yoffset+height)", dimensions);
d1314 3
a1316 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(zoffset)", dimensions);
d1320 3
a1322 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%dD(zoffset+depth)", dimensions);
d1327 5
a1331 4
   if (teximage->IsCompressed) {
      if (target != GL_TEXTURE_2D) {
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glCopyTexSubImage%d(target)", dimensions);
d1334 3
a1336 4
      /* offset must be multiple of 4 */
      if ((xoffset & 3) || (yoffset & 3)) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%D(xoffset or yoffset)", dimensions);
d1339 3
a1341 4
      /* size must be multiple of 4 */
      if ((width & 3) != 0 && (GLuint) width != teximage->Width) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%D(width)", dimensions);
d1343 1
a1343 6
      }         
      if ((height & 3) != 0 && (GLuint) height != teximage->Height) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glCopyTexSubImage%D(height)", dimensions);
         return GL_TRUE;
      }         
d1375 14
a1388 2
   maxLevels = _mesa_max_texture_levels(ctx, target);
   ASSERT(maxLevels > 0);  /* 0 indicates bad target, caught above */
d1469 1
d1471 1
a1471 3
               const GLint rowstride = texImage->RowStride;
               MEMCPY(dest,
                      (const GLushort *) texImage->Data + row * rowstride,
d1548 1
a1548 2
      _mesa_init_teximage_fields(ctx, target, texImage,
                                 postConvWidth, 1, 1,
d1556 18
a1573 1
      /* Give the texture to the driver!  <pixels> may be null! */
d1577 1
d1586 4
d1596 3
a1598 2
      GLboolean error = texture_error_check(ctx, target, level, internalFormat,
                                 format, type, 1, postConvWidth, 1, 1, border);
d1600 6
a1616 10
      else {
         /* no error, set the tex image parameters */
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage,
                                    postConvWidth, 1, 1,
                                    border, internalFormat);
      }
d1676 2
a1677 2
                                 postConvWidth, postConvHeight, 1,
                                 border, internalFormat);
d1684 18
a1701 1
      /* Give the texture to the driver!  <pixels> may be null! */
d1705 1
d1714 4
d1728 3
a1730 2
      GLboolean error = texture_error_check(ctx, target, level, internalFormat,
                    format, type, 2, postConvWidth, postConvHeight, 1, border);
d1732 6
a1750 10
      else {
         /* no error, set the tex image parameters */
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage,
                                    postConvWidth, postConvHeight, 1,
                                    border, internalFormat);
      }
d1764 1
a1764 1
_mesa_TexImage3D( GLenum target, GLint level, GLint internalFormat,
d1799 1
a1799 2
      _mesa_init_teximage_fields(ctx, target, texImage,
                                 width, height, depth,
d1807 20
a1826 1
      /* Give the texture to the driver!  <pixels> may be null! */
d1830 1
d1839 4
d1849 1
a1849 1
      GLboolean error = texture_error_check(ctx, target, level, internalFormat,
d1852 6
a1868 9
      else {
         /* no error, set the tex image parameters */
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                    border, internalFormat);
      }
d1883 1
a1883 1
   _mesa_TexImage3D(target, level, (GLint) internalFormat, width, height,
d2161 1
d2178 1
d2197 1
d2214 1
d2235 1
d2252 1
a2268 164

/**********************************************************************/
/******                   Compressed Textures                    ******/
/**********************************************************************/


/**
 * Error checking for glCompressedTexImage[123]D().
 * \return error code or GL_NO_ERROR.
 */
static GLenum
compressed_texture_error_check(GLcontext *ctx, GLint dimensions,
                               GLenum target, GLint level,
                               GLenum internalFormat, GLsizei width,
                               GLsizei height, GLsizei depth, GLint border,
                               GLsizei imageSize)
{
   GLint expectedSize, maxLevels = 0, maxTextureSize;

   if (dimensions == 1) {
      /* 1D compressed textures not allowed */
      return GL_INVALID_ENUM;
   }
   else if (dimensions == 2) {
      if (target == GL_PROXY_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map)
            return GL_INVALID_ENUM; /*target*/
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
               target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map)
            return GL_INVALID_ENUM; /*target*/
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else {
         return GL_INVALID_ENUM; /*target*/
      }
   }
   else if (dimensions == 3) {
      /* 3D compressed textures not allowed */
      return GL_INVALID_ENUM;
   }

   maxTextureSize = 1 << (maxLevels - 1);

   if (!is_compressed_format(internalFormat))
      return GL_INVALID_ENUM;

   if (border != 0)
      return GL_INVALID_VALUE;

   if (width < 1 || width > maxTextureSize || logbase2(width) < 0)
      return GL_INVALID_VALUE;

   if ((height < 1 || height > maxTextureSize || logbase2(height) < 0)
       && dimensions > 1)
      return GL_INVALID_VALUE;

   if ((depth < 1 || depth > maxTextureSize || logbase2(depth) < 0)
       && dimensions > 2)
      return GL_INVALID_VALUE;

   /* For cube map, width must equal height */
   if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
       target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB && width != height)
      return GL_INVALID_VALUE;

   if (level < 0 || level >= maxLevels)
      return GL_INVALID_VALUE;

   expectedSize = _mesa_compressed_texture_size(ctx, width, height, depth,
                                                internalFormat);
   if (expectedSize != imageSize)
      return GL_INVALID_VALUE;

   return GL_NO_ERROR;
}


/**
 * Error checking for glCompressedTexSubImage[123]D().
 * \return error code or GL_NO_ERROR.
 */
static GLenum
compressed_subtexture_error_check(GLcontext *ctx, GLint dimensions,
                                  GLenum target, GLint level,
                                  GLint xoffset, GLint yoffset, GLint zoffset,
                                  GLsizei width, GLsizei height, GLsizei depth,
                                  GLenum format, GLsizei imageSize)
{
   GLint expectedSize, maxLevels = 0, maxTextureSize;

   if (dimensions == 1) {
      /* 1D compressed textures not allowed */
      return GL_INVALID_ENUM;
   }
   else if (dimensions == 2) {
      if (target == GL_PROXY_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_TEXTURE_2D) {
         maxLevels = ctx->Const.MaxTextureLevels;
      }
      else if (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map)
            return GL_INVALID_ENUM; /*target*/
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB &&
               target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB) {
         if (!ctx->Extensions.ARB_texture_cube_map)
            return GL_INVALID_ENUM; /*target*/
         maxLevels = ctx->Const.MaxCubeTextureLevels;
      }
      else {
         return GL_INVALID_ENUM; /*target*/
      }
   }
   else if (dimensions == 3) {
      /* 3D compressed textures not allowed */
      return GL_INVALID_ENUM;
   }

   maxTextureSize = 1 << (maxLevels - 1);

   if (!is_compressed_format(format))
      return GL_INVALID_ENUM;

   if (width < 1 || width > maxTextureSize || logbase2(width) < 0)
      return GL_INVALID_VALUE;

   if ((height < 1 || height > maxTextureSize || logbase2(height) < 0)
       && dimensions > 1)
      return GL_INVALID_VALUE;

   if (level < 0 || level >= maxLevels)
      return GL_INVALID_VALUE;

   if ((xoffset & 3) != 0 || (yoffset & 3) != 0)
      return GL_INVALID_VALUE;

   if ((width & 3) != 0 && width != 2 && width != 1)
      return GL_INVALID_VALUE;

   if ((height & 3) != 0 && height != 2 && height != 1)
      return GL_INVALID_VALUE;

   expectedSize = _mesa_compressed_texture_size(ctx, width, height, depth,
                                                format);
   if (expectedSize != imageSize)
      return GL_INVALID_VALUE;

   return GL_NO_ERROR;
}



d2278 14
d2296 4
a2299 5
      GLenum error = compressed_texture_error_check(ctx, 1, target, level,
                               internalFormat, width, 1, 1, border, imageSize);
      if (error) {
         _mesa_error(ctx, error, "glCompressedTexImage1D");
         return;
d2310 1
a2310 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage1D");
d2322 8
a2329 5
      ASSERT(ctx->Driver.CompressedTexImage1D);
      (*ctx->Driver.CompressedTexImage1D)(ctx, target, level,
                                          internalFormat, width, border,
                                          imageSize, data,
                                          texObj, texImage);
d2337 2
a2338 2
      GLenum error = compressed_texture_error_check(ctx, 1, target, level,
                               internalFormat, width, 1, 1, border, imageSize);
d2340 6
a2356 9
      else {
         /* store the teximage parameters */
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, 1, 1,
                                    border, internalFormat);
      }
d2359 1
a2359 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage1D(target)");
d2374 14
d2391 3
a2393 1
        target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB)) {
d2397 4
a2400 5
      GLenum error = compressed_texture_error_check(ctx, 2, target, level,
                          internalFormat, width, height, 1, border, imageSize);
      if (error) {
         _mesa_error(ctx, error, "glCompressedTexImage2D");
         return;
d2411 1
a2411 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage2D");
d2423 8
a2430 5
      ASSERT(ctx->Driver.CompressedTexImage2D);
      (*ctx->Driver.CompressedTexImage2D)(ctx, target, level,
                                          internalFormat, width, height,
                                          border, imageSize, data,
                                          texObj, texImage);
d2436 1
a2436 3
   else if (target == GL_PROXY_TEXTURE_2D ||
            (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB &&
             ctx->Extensions.ARB_texture_cube_map)) {
d2438 2
a2439 2
      GLenum error = compressed_texture_error_check(ctx, 2, target, level,
                          internalFormat, width, height, 1, border, imageSize);
d2441 6
a2459 9
      else {
         /* store the teximage parameters */
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, height, 1,
                                    border, internalFormat);
      }
d2462 1
a2462 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage2D(target)");
d2477 14
d2495 4
a2498 5
      GLenum error = compressed_texture_error_check(ctx, 3, target, level,
                      internalFormat, width, height, depth, border, imageSize);
      if (error) {
         _mesa_error(ctx, error, "glCompressedTexImage3D");
         return;
d2509 1
a2509 1
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexImage3D");
d2521 9
a2529 6
      ASSERT(ctx->Driver.CompressedTexImage3D);
      (*ctx->Driver.CompressedTexImage3D)(ctx, target, level,
                                          internalFormat,
                                          width, height, depth,
                                          border, imageSize, data,
                                          texObj, texImage);
d2537 2
a2538 2
      GLenum error = compressed_texture_error_check(ctx, 3, target, level,
                      internalFormat, width, height, depth, border, imageSize);
d2540 7
a2557 9
      else {
         /* store the teximage parameters */
         struct gl_texture_unit *texUnit;
         struct gl_texture_image *texImage;
         texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
         texImage = _mesa_select_tex_image(ctx, texUnit, target, level);
         _mesa_init_teximage_fields(ctx, target, texImage, width, height,
                                    depth, border, internalFormat);
      }
d2560 1
a2560 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glCompressedTexImage3D(target)");
a2573 1
   GLenum error;
d2577 3
a2579 5
   error = compressed_subtexture_error_check(ctx, 1, target, level,
                                xoffset, 0, 0, width, 1, 1, format, imageSize);
   if (error) {
      _mesa_error(ctx, error, "glCompressedTexSubImage1D");
      return;
a2586 11
   if ((GLint) format != texImage->IntFormat) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage1D(format)");
      return;
   }

   if ((width == 1 || width == 2) && (GLuint) width != texImage->Width) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage1D(width)");
      return;
   }
      
a2608 1
   GLenum error;
d2612 3
a2614 5
   error = compressed_subtexture_error_check(ctx, 2, target, level,
                     xoffset, yoffset, 0, width, height, 1, format, imageSize);
   if (error) {
      _mesa_error(ctx, error, "glCompressedTexSubImage2D");
      return;
a2621 12
   if ((GLint) format != texImage->IntFormat) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage2D(format)");
      return;
   }

   if (((width == 1 || width == 2) && (GLuint) width != texImage->Width) ||
       ((height == 1 || height == 2) && (GLuint) height != texImage->Height)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage2D(size)");
      return;
   }
      
a2643 1
   GLenum error;
d2647 3
a2649 5
   error = compressed_subtexture_error_check(ctx, 3, target, level,
           xoffset, yoffset, zoffset, width, height, depth, format, imageSize);
   if (error) {
      _mesa_error(ctx, error, "glCompressedTexSubImage2D");
      return;
a2656 13
   if ((GLint) format != texImage->IntFormat) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glCompressedTexSubImage3D(format)");
      return;
   }

   if (((width == 1 || width == 2) && (GLuint) width != texImage->Width) ||
       ((height == 1 || height == 2) && (GLuint) height != texImage->Height) ||
       ((depth == 1 || depth == 2) && (GLuint) depth != texImage->Depth)) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompressedTexSubImage3D(size)");
      return;
   }
      
d2688 11
a2698 2
   maxLevels = _mesa_max_texture_levels(ctx, target);
   ASSERT(maxLevels > 0); /* 0 indicates bad target, caught above */
d2725 5
a2729 2
   /* just memcpy, no pixelstore or pixel transfer */
   MEMCPY(img, texImage->Data, texImage->CompressedSize);
@


