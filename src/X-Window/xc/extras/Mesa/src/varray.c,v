head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.28.22;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.01.02;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.01.02;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.20.05;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.29.11;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.04.51;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@
/*
 * Mesa 3-D graphics library
 * Version:  3.3
 * 
 * Copyright (C) 1999-2000  Brian Paul   All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifdef PC_HEADER
#include "all.h"
#else
#include "glheader.h"
#include "context.h"
#include "cva.h"
#include "dlist.h"
#include "enable.h"
#include "enums.h"
#include "hash.h"
#include "light.h"
#include "macros.h"
#include "mem.h"
#include "mmath.h"
#include "pipeline.h"
#include "state.h"
#include "texstate.h"
#include "translate.h"
#include "types.h"
#include "varray.h"
#include "vb.h"
#include "vbfill.h"
#include "vbrender.h"
#include "vbindirect.h"
#include "vbxform.h"
#include "xform.h"
#endif



void
_mesa_VertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   
   if (size<2 || size>4) {
      gl_error( ctx, GL_INVALID_VALUE, "glVertexPointer(size)" );
      return;
   }
   if (stride<0) {
      gl_error( ctx, GL_INVALID_VALUE, "glVertexPointer(stride)" );
      return;
   }
   
   if (MESA_VERBOSE&(VERBOSE_VARRAY|VERBOSE_API))
      fprintf(stderr, "glVertexPointer( sz %d type %s stride %d )\n", size, 
	      gl_lookup_enum_by_nr( type ),
	      stride);

#ifdef VAO
   ctx->Array.Current->Vertex.StrideB = stride;
#else
   ctx->Array.Vertex.StrideB = stride;
#endif
   if (!stride) {
      switch (type) {
      case GL_SHORT:
#ifdef VAO
         ctx->Array.Current->Vertex.StrideB =  size*sizeof(GLshort);
#else
         ctx->Array.Vertex.StrideB =  size*sizeof(GLshort);
#endif
         break;
      case GL_INT:
#ifdef VAO
         ctx->Array.Current->Vertex.StrideB =  size*sizeof(GLint);
#else
         ctx->Array.Vertex.StrideB =  size*sizeof(GLint);
#endif
         break;
      case GL_FLOAT:
#ifdef VAO
         ctx->Array.Current->Vertex.StrideB =  size*sizeof(GLfloat);
#else
         ctx->Array.Vertex.StrideB =  size*sizeof(GLfloat);
#endif
         break;
      case GL_DOUBLE:
#ifdef VAO
         ctx->Array.Current->Vertex.StrideB =  size*sizeof(GLdouble);
#else
         ctx->Array.Vertex.StrideB =  size*sizeof(GLdouble);
#endif
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glVertexPointer(type)" );
         return;
      }
   }
#ifdef VAO
   ctx->Array.Current->Vertex.Size = size;
   ctx->Array.Current->Vertex.Type = type;
   ctx->Array.Current->Vertex.Stride = stride;
   ctx->Array.Current->Vertex.Ptr = (void *) ptr;
   ctx->Array.Current->VertexFunc = gl_trans_4f_tab[size][TYPE_IDX(type)];
   ctx->Array.Current->VertexEltFunc = gl_trans_elt_4f_tab[size][TYPE_IDX(type)];
   ctx->Array.NewArrayState |= VERT_OBJ_ANY;
#else
   ctx->Array.Vertex.Size = size;
   ctx->Array.Vertex.Type = type;
   ctx->Array.Vertex.Stride = stride;
   ctx->Array.Vertex.Ptr = (void *) ptr;
   ctx->Array.VertexFunc = gl_trans_4f_tab[size][TYPE_IDX(type)];
   ctx->Array.VertexEltFunc = gl_trans_elt_4f_tab[size][TYPE_IDX(type)];
   ctx->Array.NewArrayState |= VERT_OBJ_ANY;
#endif
   ctx->NewState |= NEW_CLIENT_STATE;
}




void
_mesa_NormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr )
{
   GET_CURRENT_CONTEXT(ctx);
   
   if (stride<0) {
      gl_error( ctx, GL_INVALID_VALUE, "glNormalPointer(stride)" );
      return;
   }

   if (MESA_VERBOSE&(VERBOSE_VARRAY|VERBOSE_API))
      fprintf(stderr, "glNormalPointer( type %s stride %d )\n", 
	      gl_lookup_enum_by_nr( type ),
	      stride);

#ifdef VAO
   ctx->Array.Current->Normal.StrideB = stride;
#else
   ctx->Array.Normal.StrideB = stride;
#endif
   if (!stride) {
      switch (type) {
      case GL_BYTE:
#ifdef VAO
         ctx->Array.Current->Normal.StrideB =  3*sizeof(GLbyte);
#else
         ctx->Array.Normal.StrideB =  3*sizeof(GLbyte);
#endif
         break;
      case GL_SHORT:
#ifdef VAO
         ctx->Array.Current->Normal.StrideB =  3*sizeof(GLshort);
#else
         ctx->Array.Normal.StrideB =  3*sizeof(GLshort);
#endif
         break;
      case GL_INT:
#ifdef VAO
         ctx->Array.Current->Normal.StrideB =  3*sizeof(GLint);
#else
         ctx->Array.Normal.StrideB =  3*sizeof(GLint);
#endif
         break;
      case GL_FLOAT:
#ifdef VAO
         ctx->Array.Current->Normal.StrideB =  3*sizeof(GLfloat);
#else
         ctx->Array.Normal.StrideB =  3*sizeof(GLfloat);
#endif
         break;
      case GL_DOUBLE:
#ifdef VAO
         ctx->Array.Current->Normal.StrideB =  3*sizeof(GLdouble);
#else
         ctx->Array.Normal.StrideB =  3*sizeof(GLdouble);
#endif
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glNormalPointer(type)" );
         return;
      }
   }
#ifdef VAO
   ctx->Array.Current->Normal.Type = type;
   ctx->Array.Current->Normal.Stride = stride;
   ctx->Array.Current->Normal.Ptr = (void *) ptr;
   ctx->Array.Current->NormalFunc = gl_trans_3f_tab[TYPE_IDX(type)];
   ctx->Array.Current->NormalEltFunc = gl_trans_elt_3f_tab[TYPE_IDX(type)];
#else
   ctx->Array.Normal.Type = type;
   ctx->Array.Normal.Stride = stride;
   ctx->Array.Normal.Ptr = (void *) ptr;
   ctx->Array.NormalFunc = gl_trans_3f_tab[TYPE_IDX(type)];
   ctx->Array.NormalEltFunc = gl_trans_elt_3f_tab[TYPE_IDX(type)];
#endif
   ctx->Array.NewArrayState |= VERT_NORM;
   ctx->NewState |= NEW_CLIENT_STATE;
}



void
_mesa_ColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);

   if (size<3 || size>4) {
      gl_error( ctx, GL_INVALID_VALUE, "glColorPointer(size)" );
      return;
   }
   if (stride<0) {
      gl_error( ctx, GL_INVALID_VALUE, "glColorPointer(stride)" );
      return;
   }

   if (MESA_VERBOSE&(VERBOSE_VARRAY|VERBOSE_API))
      fprintf(stderr, "glColorPointer( sz %d type %s stride %d )\n", size, 
	  gl_lookup_enum_by_nr( type ),
	  stride);

#ifdef VAO
   ctx->Array.Current->Color.StrideB = stride;
#else
   ctx->Array.Color.StrideB = stride;
#endif
   if (!stride) {
      switch (type) {
      case GL_BYTE:
#ifdef VAO
         ctx->Array.Current->Color.StrideB =  size*sizeof(GLbyte);
#else
         ctx->Array.Color.StrideB =  size*sizeof(GLbyte);
#endif
         break;
      case GL_UNSIGNED_BYTE:
#ifdef VAO
         ctx->Array.Current->Color.StrideB =  size*sizeof(GLubyte);
#else
         ctx->Array.Color.StrideB =  size*sizeof(GLubyte);
#endif
         break;
      case GL_SHORT:
#ifdef VAO
         ctx->Array.Current->Color.StrideB =  size*sizeof(GLshort);
#else
         ctx->Array.Color.StrideB =  size*sizeof(GLshort);
#endif
         break;
      case GL_UNSIGNED_SHORT:
#ifdef VAO
         ctx->Array.Current->Color.StrideB =  size*sizeof(GLushort);
#else
         ctx->Array.Color.StrideB =  size*sizeof(GLushort);
#endif
         break;
      case GL_INT:
#ifdef VAO
         ctx->Array.Current->Color.StrideB =  size*sizeof(GLint);
#else
         ctx->Array.Color.StrideB =  size*sizeof(GLint);
#endif
         break;
      case GL_UNSIGNED_INT:
#ifdef VAO
         ctx->Array.Current->Color.StrideB =  size*sizeof(GLuint);
#else
         ctx->Array.Color.StrideB =  size*sizeof(GLuint);
#endif
         break;
      case GL_FLOAT:
#ifdef VAO
         ctx->Array.Current->Color.StrideB =  size*sizeof(GLfloat);
#else
         ctx->Array.Color.StrideB =  size*sizeof(GLfloat);
#endif
         break;
      case GL_DOUBLE:
#ifdef VAO
         ctx->Array.Current->Color.StrideB =  size*sizeof(GLdouble);
#else
         ctx->Array.Color.StrideB =  size*sizeof(GLdouble);
#endif
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glColorPointer(type)" );
         return;
      }
   }
#ifdef VAO
   ctx->Array.Current->Color.Size = size;
   ctx->Array.Current->Color.Type = type;
   ctx->Array.Current->Color.Stride = stride;
   ctx->Array.Current->Color.Ptr = (void *) ptr;
   ctx->Array.Current->ColorFunc = gl_trans_4ub_tab[size][TYPE_IDX(type)];
   ctx->Array.Current->ColorEltFunc = gl_trans_elt_4ub_tab[size][TYPE_IDX(type)];
#else
   ctx->Array.Color.Size = size;
   ctx->Array.Color.Type = type;
   ctx->Array.Color.Stride = stride;
   ctx->Array.Color.Ptr = (void *) ptr;
   ctx->Array.ColorFunc = gl_trans_4ub_tab[size][TYPE_IDX(type)];
   ctx->Array.ColorEltFunc = gl_trans_elt_4ub_tab[size][TYPE_IDX(type)];
#endif
   ctx->Array.NewArrayState |= VERT_RGBA;
   ctx->NewState |= NEW_CLIENT_STATE;
}



void
_mesa_IndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   
   if (stride<0) {
      gl_error( ctx, GL_INVALID_VALUE, "glIndexPointer(stride)" );
      return;
   }

#ifdef VAO
   ctx->Array.Current->Index.StrideB = stride;
#else
   ctx->Array.Index.StrideB = stride;
#endif
   if (!stride) {
      switch (type) {
      case GL_UNSIGNED_BYTE:
#ifdef VAO
         ctx->Array.Current->Index.StrideB =  sizeof(GLubyte);
#else
         ctx->Array.Index.StrideB =  sizeof(GLubyte);
#endif
         break;
      case GL_SHORT:
#ifdef VAO
         ctx->Array.Current->Index.StrideB =  sizeof(GLshort);
#else
         ctx->Array.Index.StrideB =  sizeof(GLshort);
#endif
         break;
      case GL_INT:
#ifdef VAO
         ctx->Array.Current->Index.StrideB =  sizeof(GLint);
#else
         ctx->Array.Index.StrideB =  sizeof(GLint);
#endif
         break;
      case GL_FLOAT:
#ifdef VAO
         ctx->Array.Current->Index.StrideB =  sizeof(GLfloat);
#else
         ctx->Array.Index.StrideB =  sizeof(GLfloat);
#endif
         break;
      case GL_DOUBLE:
#ifdef VAO
         ctx->Array.Current->Index.StrideB =  sizeof(GLdouble);
#else
         ctx->Array.Index.StrideB =  sizeof(GLdouble);
#endif
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glIndexPointer(type)" );
         return;
      }
   }
#ifdef VAO
   ctx->Array.Current->Index.Type = type;
   ctx->Array.Current->Index.Stride = stride;
   ctx->Array.Current->Index.Ptr = (void *) ptr;
   ctx->Array.Current->IndexFunc = gl_trans_1ui_tab[TYPE_IDX(type)];
   ctx->Array.Current->IndexEltFunc = gl_trans_elt_1ui_tab[TYPE_IDX(type)];
#else
   ctx->Array.Index.Type = type;
   ctx->Array.Index.Stride = stride;
   ctx->Array.Index.Ptr = (void *) ptr;
   ctx->Array.IndexFunc = gl_trans_1ui_tab[TYPE_IDX(type)];
   ctx->Array.IndexEltFunc = gl_trans_elt_1ui_tab[TYPE_IDX(type)];
#endif
   ctx->Array.NewArrayState |= VERT_INDEX;
   ctx->NewState |= NEW_CLIENT_STATE;
}



void
_mesa_TexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint texUnit;
   
   texUnit = ctx->Array.ActiveTexture;

   if (size<1 || size>4) {
      gl_error( ctx, GL_INVALID_VALUE, "glTexCoordPointer(size)" );
      return;
   }
   if (stride<0) {
      gl_error( ctx, GL_INVALID_VALUE, "glTexCoordPointer(stride)" );
      return;
   }

   if (MESA_VERBOSE&(VERBOSE_VARRAY|VERBOSE_API))
      fprintf(stderr, "glTexCoordPointer( unit %u sz %d type %s stride %d )\n", 
	  texUnit,
	  size, 
	  gl_lookup_enum_by_nr( type ),
	  stride);

#ifdef VAO
   ctx->Array.Current->TexCoord[texUnit].StrideB = stride;
#else
   ctx->Array.TexCoord[texUnit].StrideB = stride;
#endif
   if (!stride) {
      switch (type) {
      case GL_SHORT:
#ifdef VAO
         ctx->Array.Current->TexCoord[texUnit].StrideB =  size*sizeof(GLshort);
#else
         ctx->Array.TexCoord[texUnit].StrideB =  size*sizeof(GLshort);
#endif
         break;
      case GL_INT:
#ifdef VAO
         ctx->Array.Current->TexCoord[texUnit].StrideB =  size*sizeof(GLint);
#else
         ctx->Array.TexCoord[texUnit].StrideB =  size*sizeof(GLint);
#endif
         break;
      case GL_FLOAT:
#ifdef VAO
         ctx->Array.Current->TexCoord[texUnit].StrideB =  size*sizeof(GLfloat);
#else
         ctx->Array.TexCoord[texUnit].StrideB =  size*sizeof(GLfloat);
#endif
         break;
      case GL_DOUBLE:
#ifdef VAO
         ctx->Array.Current->TexCoord[texUnit].StrideB =  size*sizeof(GLdouble);
#else
         ctx->Array.TexCoord[texUnit].StrideB =  size*sizeof(GLdouble);
#endif
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glTexCoordPointer(type)" );
         return;
      }
   }
#ifdef VAO
   ctx->Array.Current->TexCoord[texUnit].Size = size;
   ctx->Array.Current->TexCoord[texUnit].Type = type;
   ctx->Array.Current->TexCoord[texUnit].Stride = stride;
   ctx->Array.Current->TexCoord[texUnit].Ptr = (void *) ptr;

   ctx->Array.Current->TexCoordFunc[texUnit] = gl_trans_4f_tab[size][TYPE_IDX(type)];
   ctx->Array.Current->TexCoordEltFunc[texUnit] = gl_trans_elt_4f_tab[size][TYPE_IDX(type)];
#else
   ctx->Array.TexCoord[texUnit].Size = size;
   ctx->Array.TexCoord[texUnit].Type = type;
   ctx->Array.TexCoord[texUnit].Stride = stride;
   ctx->Array.TexCoord[texUnit].Ptr = (void *) ptr;

   ctx->Array.TexCoordFunc[texUnit] = gl_trans_4f_tab[size][TYPE_IDX(type)];
   ctx->Array.TexCoordEltFunc[texUnit] = gl_trans_elt_4f_tab[size][TYPE_IDX(type)];
#endif
   ctx->Array.NewArrayState |= PIPE_TEX(texUnit);
   ctx->NewState |= NEW_CLIENT_STATE;
}




void
_mesa_EdgeFlagPointer(GLsizei stride, const void *vptr)
{
   GET_CURRENT_CONTEXT(ctx);
   const GLboolean *ptr = (GLboolean *)vptr;

   if (stride<0) {
      gl_error( ctx, GL_INVALID_VALUE, "glEdgeFlagPointer(stride)" );
      return;
   }
#ifdef VAO
   ctx->Array.Current->EdgeFlag.Stride = stride;
   ctx->Array.Current->EdgeFlag.StrideB = stride ? stride : sizeof(GLboolean);
   ctx->Array.Current->EdgeFlag.Ptr = (GLboolean *) ptr;
   if (stride != sizeof(GLboolean)) {
      ctx->Array.Current->EdgeFlagFunc = gl_trans_1ub_tab[TYPE_IDX(GL_UNSIGNED_BYTE)];
   } else {
      ctx->Array.Current->EdgeFlagFunc = 0;
   }
   ctx->Array.Current->EdgeFlagEltFunc = gl_trans_elt_1ub_tab[TYPE_IDX(GL_UNSIGNED_BYTE)];
#else
   ctx->Array.EdgeFlag.Stride = stride;
   ctx->Array.EdgeFlag.StrideB = stride ? stride : sizeof(GLboolean);
   ctx->Array.EdgeFlag.Ptr = (GLboolean *) ptr;
   if (stride != sizeof(GLboolean)) {
      ctx->Array.EdgeFlagFunc = gl_trans_1ub_tab[TYPE_IDX(GL_UNSIGNED_BYTE)];
   } else {
      ctx->Array.EdgeFlagFunc = 0;
   }
   ctx->Array.EdgeFlagEltFunc = gl_trans_elt_1ub_tab[TYPE_IDX(GL_UNSIGNED_BYTE)];
#endif
   ctx->Array.NewArrayState |= VERT_EDGE;
   ctx->NewState |= NEW_CLIENT_STATE;
}


#if 0
/* Called only from gl_DrawElements
 */
static void gl_CVAEltPointer( GLcontext *ctx, GLenum type, const GLvoid *ptr )
{
   switch (type) {
      case GL_UNSIGNED_BYTE:
         ctx->CVA.Elt.StrideB = sizeof(GLubyte);
         break;
      case GL_UNSIGNED_SHORT:
         ctx->CVA.Elt.StrideB = sizeof(GLushort);
         break;
      case GL_UNSIGNED_INT:
         ctx->CVA.Elt.StrideB = sizeof(GLuint);
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glEltPointer(type)" );
         return;
   }
   ctx->CVA.Elt.Type = type;
   ctx->CVA.Elt.Stride = 0;
   ctx->CVA.Elt.Ptr = (void *) ptr;
   ctx->CVA.EltFunc = gl_trans_1ui_tab[TYPE_IDX(type)];
   ctx->Array.NewArrayState |= VERT_ELT; /* ??? */
}
#endif



void
_mesa_VertexPointerEXT(GLint size, GLenum type, GLsizei stride,
                       GLsizei count, const GLvoid *ptr)
{
   (void) count;
   _mesa_VertexPointer(size, type, stride, ptr);
}


void
_mesa_NormalPointerEXT(GLenum type, GLsizei stride, GLsizei count,
                       const GLvoid *ptr)
{
   (void) count;
   _mesa_NormalPointer(type, stride, ptr);
}


void
_mesa_ColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count,
                      const GLvoid *ptr)
{
   (void) count;
   _mesa_ColorPointer(size, type, stride, ptr);
}


void
_mesa_IndexPointerEXT(GLenum type, GLsizei stride, GLsizei count,
                      const GLvoid *ptr)
{
   (void) count;
   _mesa_IndexPointer(type, stride, ptr);
}


void
_mesa_TexCoordPointerEXT(GLint size, GLenum type, GLsizei stride,
                         GLsizei count, const GLvoid *ptr)
{
   (void) count;
   _mesa_TexCoordPointer(size, type, stride, ptr);
}


void
_mesa_EdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *ptr)
{
   (void) count;
   _mesa_EdgeFlagPointer(stride, ptr);
}





/* KW: Batch function to exec all the array elements in the input
 *     buffer prior to transform.  Done only the first time a vertex
 *     buffer is executed or compiled.
 *
 * KW: Have to do this after each glEnd if cva isn't active.  (also
 *     have to do it after each full buffer)
 */
void gl_exec_array_elements( GLcontext *ctx, struct immediate *IM,
			     GLuint start, 
			     GLuint count)
{
   GLuint *flags = IM->Flag;
   GLuint *elts = IM->Elt;
#ifdef VAO
   GLuint translate = ctx->Array.Current->Flags;
#else
   GLuint translate = ctx->Array.Flags;
#endif
   GLuint i;

   if (MESA_VERBOSE&VERBOSE_IMMEDIATE)
      fprintf(stderr, "exec_array_elements %d .. %d\n", start, count);
   
#ifdef VAO
   if (translate & VERT_OBJ_ANY) 
      (ctx->Array.Current->VertexEltFunc)( IM->Obj, 
				  &ctx->Array.Current->Vertex, 
				  flags, elts, (VERT_ELT|VERT_OBJ_ANY),
				  start, count);
   
   if (translate & VERT_NORM) 
      (ctx->Array.Current->NormalEltFunc)( IM->Normal, 
				  &ctx->Array.Current->Normal, 
				  flags, elts, (VERT_ELT|VERT_NORM),
				  start, count);

   if (translate & VERT_EDGE) 
      (ctx->Array.Current->EdgeFlagEltFunc)( IM->EdgeFlag, 
				    &ctx->Array.Current->EdgeFlag, 
				    flags, elts, (VERT_ELT|VERT_EDGE),
				    start, count);
   
   if (translate & VERT_RGBA)
      (ctx->Array.Current->ColorEltFunc)( IM->Color, 
				 &ctx->Array.Current->Color, 
				 flags, elts, (VERT_ELT|VERT_RGBA),
				 start, count);

   if (translate & VERT_INDEX)
      (ctx->Array.Current->IndexEltFunc)( IM->Index, 
				 &ctx->Array.Current->Index, 
				 flags, elts, (VERT_ELT|VERT_INDEX),
				 start, count);

   if (translate & VERT_TEX0_ANY)
      (ctx->Array.Current->TexCoordEltFunc[0])( IM->TexCoord[0], 
				       &ctx->Array.Current->TexCoord[0], 
				       flags, elts, (VERT_ELT|VERT_TEX0_ANY),
				       start, count);

   if (translate & VERT_TEX1_ANY)
      (ctx->Array.Current->TexCoordEltFunc[1])( IM->TexCoord[1], 
				       &ctx->Array.Current->TexCoord[1], 
				       flags, elts, (VERT_ELT|VERT_TEX1_ANY),
				       start, count);
#else
   if (translate & VERT_OBJ_ANY) 
      (ctx->Array.VertexEltFunc)( IM->Obj, 
				  &ctx->Array.Vertex, 
				  flags, elts, (VERT_ELT|VERT_OBJ_ANY),
				  start, count);
   
   if (translate & VERT_NORM) 
      (ctx->Array.NormalEltFunc)( IM->Normal, 
				  &ctx->Array.Normal, 
				  flags, elts, (VERT_ELT|VERT_NORM),
				  start, count);

   if (translate & VERT_EDGE) 
      (ctx->Array.EdgeFlagEltFunc)( IM->EdgeFlag, 
				    &ctx->Array.EdgeFlag, 
				    flags, elts, (VERT_ELT|VERT_EDGE),
				    start, count);
   
   if (translate & VERT_RGBA)
      (ctx->Array.ColorEltFunc)( IM->Color, 
				 &ctx->Array.Color, 
				 flags, elts, (VERT_ELT|VERT_RGBA),
				 start, count);

   if (translate & VERT_INDEX)
      (ctx->Array.IndexEltFunc)( IM->Index, 
				 &ctx->Array.Index, 
				 flags, elts, (VERT_ELT|VERT_INDEX),
				 start, count);

   if (translate & VERT_TEX0_ANY)
      (ctx->Array.TexCoordEltFunc[0])( IM->TexCoord[0], 
				       &ctx->Array.TexCoord[0], 
				       flags, elts, (VERT_ELT|VERT_TEX0_ANY),
				       start, count);

   if (translate & VERT_TEX1_ANY)
      (ctx->Array.TexCoordEltFunc[1])( IM->TexCoord[1], 
				       &ctx->Array.TexCoord[1], 
				       flags, elts, (VERT_ELT|VERT_TEX1_ANY),
				       start, count);
#endif

   for (i = start ; i < count ; i++) 
      if (flags[i] & VERT_ELT) 
	 flags[i] |= translate;

}



/* Enough funny business going on in here it might be quicker to use a
 * function pointer.
 */
#define ARRAY_ELT( IM, i )					\
{								\
   GLuint count = IM->Count;					\
   IM->Elt[count] = i;						\
   IM->Flag[count] = ((IM->Flag[count] & IM->ArrayAndFlags) |	\
		      VERT_ELT);				\
   IM->FlushElt |= IM->ArrayEltFlush;				\
   IM->Count = count += IM->ArrayIncr;				\
   if (count == VB_MAX)						\
      IM->maybe_transform_vb( IM );				\
}


void
_mesa_ArrayElement( GLint i )
{
   GET_IMMEDIATE;
   ARRAY_ELT( IM, i );
}


static void
gl_ArrayElement( GLcontext *CC, GLint i )
{
   struct immediate *im = CC->input;
   ARRAY_ELT( im, i );
}



void
_mesa_DrawArrays(GLenum mode, GLint start, GLsizei count)
{
   GET_CURRENT_CONTEXT(ctx);
   struct vertex_buffer *VB = ctx->VB;
   GLint i;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glDrawArrays");

   if (count<0) {
      gl_error( ctx, GL_INVALID_VALUE, "glDrawArrays(count)" );
      return;
   }

#ifdef VAO
   if (!ctx->CompileFlag && ctx->Array.Current->Vertex.Enabled) {
#else
   if (!ctx->CompileFlag && ctx->Array.Vertex.Enabled) {
#endif
      GLint remaining = count;
      GLint i;
      struct gl_client_array *Normal = 0;
      struct gl_client_array *Color = 0;
      struct gl_client_array *Index = 0;
      struct gl_client_array *TexCoord[MAX_TEXTURE_UNITS];
      struct gl_client_array *EdgeFlag = 0;
      struct immediate *IM = VB->IM;
      struct gl_pipeline *elt = &ctx->CVA.elt;
      GLboolean relock;
      GLuint fallback, required;

      if (ctx->NewState)
	 gl_update_state( ctx );	

      /* Just turn off cva on this path.  Could be useful for multipass
       * rendering to keep it turned on.
       */
      relock = ctx->CompileCVAFlag;

      if (relock) {
	 ctx->CompileCVAFlag = 0;
	 elt->pipeline_valid = 0;
      }

      if (!elt->pipeline_valid)
	 gl_build_immediate_pipeline( ctx );

      required = elt->inputs;
#ifdef VAO
      fallback = (elt->inputs & ~ctx->Array.Current->Summary);
#else
      fallback = (elt->inputs & ~ctx->Array.Summary);
#endif

      /* The translate function doesn't do anything about size.  It
       * just ensures that type and stride come out right.
       */
#ifdef VAO
      IM->v.Obj.size = ctx->Array.Current->Vertex.Size;

      if (required & VERT_RGBA) 
      {
	 Color = &ctx->Array.Current->Color;
	 if (fallback & VERT_RGBA) {
	    Color = &ctx->Fallback.Color;
	    ctx->Array.Current->ColorFunc = 
	       gl_trans_4ub_tab[4][TYPE_IDX(GL_UNSIGNED_BYTE)];
	 }
      }
   
      if (required & VERT_INDEX) 
      {
	 Index = &ctx->Array.Current->Index;
	 if (fallback & VERT_INDEX) {
	    Index = &ctx->Fallback.Index;
	    ctx->Array.Current->IndexFunc = gl_trans_1ui_tab[TYPE_IDX(GL_UNSIGNED_INT)];
	 }
      }

      for (i = 0 ; i < MAX_TEXTURE_UNITS ; i++) 
      {
	 GLuint flag = VERT_TEX_ANY(i);

	 if (required & flag) {
	    TexCoord[i] = &ctx->Array.Current->TexCoord[i];

	    if (fallback & flag) 
	    {
	       TexCoord[i] = &ctx->Fallback.TexCoord[i];
	       TexCoord[i]->Size = gl_texcoord_size( ctx->Current.Flag, i );

	       ctx->Array.Current->TexCoordFunc[i] = 
		  gl_trans_4f_tab[TexCoord[i]->Size][TYPE_IDX(GL_FLOAT)];
	    }
	 }
      }

      if (ctx->Array.Current->Flags != ctx->Array.Current->Flag[0])
 	 for (i = 0 ; i < VB_MAX ; i++) 
	    ctx->Array.Current->Flag[i] = ctx->Array.Current->Flags;


      if (required & VERT_NORM) 
      {
	 Normal = &ctx->Array.Current->Normal;
	 if (fallback & VERT_NORM) {
	    Normal = &ctx->Fallback.Normal;
	    ctx->Array.Current->NormalFunc = gl_trans_3f_tab[TYPE_IDX(GL_FLOAT)];
	 }
      }

      if ( required & VERT_EDGE )
      {
	 if (mode == GL_TRIANGLES || 
	     mode == GL_QUADS || 
	     mode == GL_POLYGON)
	 {
	    EdgeFlag = &ctx->Array.Current->EdgeFlag;
	    if (fallback & VERT_EDGE) {
	       EdgeFlag = &ctx->Fallback.EdgeFlag;
	       ctx->Array.Current->EdgeFlagFunc = 
		  gl_trans_1ub_tab[TYPE_IDX(GL_UNSIGNED_BYTE)];
	    }
	 }
	 else
	    required &= ~VERT_EDGE;
      }
#else
      IM->v.Obj.size = ctx->Array.Vertex.Size;

      if (required & VERT_RGBA) 
      {
	 Color = &ctx->Array.Color;
	 if (fallback & VERT_RGBA) {
	    Color = &ctx->Fallback.Color;
	    ctx->Array.ColorFunc = 
	       gl_trans_4ub_tab[4][TYPE_IDX(GL_UNSIGNED_BYTE)];
	 }
      }
   
      if (required & VERT_INDEX) 
      {
	 Index = &ctx->Array.Index;
	 if (fallback & VERT_INDEX) {
	    Index = &ctx->Fallback.Index;
	    ctx->Array.IndexFunc = gl_trans_1ui_tab[TYPE_IDX(GL_UNSIGNED_INT)];
	 }
      }

      for (i = 0 ; i < MAX_TEXTURE_UNITS ; i++) 
      {
	 GLuint flag = VERT_TEX_ANY(i);

	 if (required & flag) {
	    TexCoord[i] = &ctx->Array.TexCoord[i];

	    if (fallback & flag) 
	    {
	       TexCoord[i] = &ctx->Fallback.TexCoord[i];
	       TexCoord[i]->Size = gl_texcoord_size( ctx->Current.Flag, i );

	       ctx->Array.TexCoordFunc[i] = 
		  gl_trans_4f_tab[TexCoord[i]->Size][TYPE_IDX(GL_FLOAT)];
	    }
	 }
      }

      if (ctx->Array.Flags != ctx->Array.Flag[0])
 	 for (i = 0 ; i < VB_MAX ; i++) 
	    ctx->Array.Flag[i] = ctx->Array.Flags;


      if (required & VERT_NORM) 
      {
	 Normal = &ctx->Array.Normal;
	 if (fallback & VERT_NORM) {
	    Normal = &ctx->Fallback.Normal;
	    ctx->Array.NormalFunc = gl_trans_3f_tab[TYPE_IDX(GL_FLOAT)];
	 }
      }

      if ( required & VERT_EDGE )
      {
	 if (mode == GL_TRIANGLES || 
	     mode == GL_QUADS || 
	     mode == GL_POLYGON)
	 {
	    EdgeFlag = &ctx->Array.EdgeFlag;
	    if (fallback & VERT_EDGE) {
	       EdgeFlag = &ctx->Fallback.EdgeFlag;
	       ctx->Array.EdgeFlagFunc = 
		  gl_trans_1ub_tab[TYPE_IDX(GL_UNSIGNED_BYTE)];
	    }
	 }
	 else
	    required &= ~VERT_EDGE;
      }
#endif

      VB->Primitive = IM->Primitive; 
      VB->NextPrimitive = IM->NextPrimitive; 
      VB->MaterialMask = IM->MaterialMask;
      VB->Material = IM->Material;
      VB->BoundsPtr = 0;

      while (remaining > 0) {
         GLint vbspace = VB_MAX - VB_START;
	 GLuint count, n;
	 
	 if (vbspace >= remaining) {
	    n = remaining;
	    VB->LastPrimitive = VB_START + n;
	 } else {
	    n = vbspace;
	    VB->LastPrimitive = VB_START;
	 }
	 
	 VB->CullMode = 0;
	 
#ifdef VAO
	 ctx->Array.Current->VertexFunc( IM->Obj + VB_START, 
				&ctx->Array.Current->Vertex, start, n );
	 
	 if (required & VERT_NORM) {
	    ctx->Array.Current->NormalFunc( IM->Normal + VB_START, 
				   Normal, start, n );
	 }
	 
	 if (required & VERT_EDGE) {
	    ctx->Array.Current->EdgeFlagFunc( IM->EdgeFlag + VB_START, 
				     EdgeFlag, start, n );
	 }
	 
	 if (required & VERT_RGBA) {
	    ctx->Array.Current->ColorFunc( IM->Color + VB_START, 
				  Color, start, n );
	 }
	 
	 if (required & VERT_INDEX) {
	    ctx->Array.Current->IndexFunc( IM->Index + VB_START, 
				  Index, start, n );
	 }
	 
	 if (required & VERT_TEX0_ANY) {
	    IM->v.TexCoord[0].size = TexCoord[0]->Size;
	    ctx->Array.Current->TexCoordFunc[0]( IM->TexCoord[0] + VB_START, 
					TexCoord[0], start, n );
	 }
	 
	 if (required & VERT_TEX1_ANY) {
	    IM->v.TexCoord[1].size = TexCoord[1]->Size;
	    ctx->Array.Current->TexCoordFunc[1]( IM->TexCoord[1] + VB_START, 
					TexCoord[1], start, n );
	 }
#else
	 ctx->Array.VertexFunc( IM->Obj + VB_START, 
				&ctx->Array.Vertex, start, n );
	 
	 if (required & VERT_NORM) {
	    ctx->Array.NormalFunc( IM->Normal + VB_START, 
				   Normal, start, n );
	 }
	 
	 if (required & VERT_EDGE) {
	    ctx->Array.EdgeFlagFunc( IM->EdgeFlag + VB_START, 
				     EdgeFlag, start, n );
	 }
	 
	 if (required & VERT_RGBA) {
	    ctx->Array.ColorFunc( IM->Color + VB_START, 
				  Color, start, n );
	 }
	 
	 if (required & VERT_INDEX) {
	    ctx->Array.IndexFunc( IM->Index + VB_START, 
				  Index, start, n );
	 }
	 
	 if (required & VERT_TEX0_ANY) {
	    IM->v.TexCoord[0].size = TexCoord[0]->Size;
	    ctx->Array.TexCoordFunc[0]( IM->TexCoord[0] + VB_START, 
					TexCoord[0], start, n );
	 }
	 
	 if (required & VERT_TEX1_ANY) {
	    IM->v.TexCoord[1].size = TexCoord[1]->Size;
	    ctx->Array.TexCoordFunc[1]( IM->TexCoord[1] + VB_START, 
					TexCoord[1], start, n );
	 }
#endif
	 VB->ObjPtr = &IM->v.Obj;
	 VB->NormalPtr = &IM->v.Normal;
	 VB->ColorPtr = &IM->v.Color;
	 VB->Color[0] = VB->Color[1] = VB->ColorPtr;
	 VB->IndexPtr = &IM->v.Index;
	 VB->EdgeFlagPtr = &IM->v.EdgeFlag;
	 VB->TexCoordPtr[0] = &IM->v.TexCoord[0];
	 VB->TexCoordPtr[1] = &IM->v.TexCoord[1];

#ifdef VAO
	 VB->Flag = ctx->Array.Current->Flag;
	 VB->OrFlag = ctx->Array.Current->Flags;
#else
	 VB->Flag = ctx->Array.Flag;
	 VB->OrFlag = ctx->Array.Flags;
#endif

	 VB->Start = IM->Start = VB_START;
	 count = VB->Count = IM->Count = VB_START + n;

#define RESET_VEC(v, t, s, c) (v.start = t v.data[s], v.count = c)  

	 RESET_VEC(IM->v.Obj, (GLfloat *), VB_START, count);
	 RESET_VEC(IM->v.Normal, (GLfloat *), VB_START, count);
	 RESET_VEC(IM->v.TexCoord[0], (GLfloat *), VB_START, count);
	 RESET_VEC(IM->v.TexCoord[1], (GLfloat *), VB_START, count);
	 RESET_VEC(IM->v.Index, &, VB_START, count);
	 RESET_VEC(IM->v.Elt, &, VB_START, count);
	 RESET_VEC(IM->v.EdgeFlag, &, VB_START, count);
	 RESET_VEC(IM->v.Color, (GLubyte *), VB_START, count);
	 RESET_VEC(VB->Clip, (GLfloat *), VB_START, count);
	 RESET_VEC(VB->Eye, (GLfloat *), VB_START, count);
	 RESET_VEC(VB->Win, (GLfloat *), VB_START, count);
	 RESET_VEC(VB->BColor, (GLubyte *), VB_START, count); 
	 RESET_VEC(VB->BIndex, &, VB_START, count);

	 VB->NextPrimitive[VB->CopyStart] = VB->Count;
	 VB->Primitive[VB->CopyStart] = mode;
#ifdef VAO
	 ctx->Array.Current->Flag[count] |= VERT_END_VB;
#else
	 ctx->Array.Flag[count] |= VERT_END_VB;
#endif

         /* Transform and render.
	  */
         gl_run_pipeline( VB );
	 gl_reset_vb( VB );

#ifdef VAO
	 ctx->Array.Current->Flag[count] = ctx->Array.Current->Flags;
	 ctx->Array.Current->Flag[VB_START] = ctx->Array.Current->Flags;
#else
	 ctx->Array.Flag[count] = ctx->Array.Flags;
	 ctx->Array.Flag[VB_START] = ctx->Array.Flags;
#endif

         start += n;
         remaining -= n;
      }

      gl_reset_input( ctx );

      if (relock) {
	 ctx->CompileCVAFlag = relock;
	 elt->pipeline_valid = 0;
      }
   }
#ifdef VAO
   else if (ctx->Array.Current->Vertex.Enabled)
#else
   else if (ctx->Array.Vertex.Enabled)
#endif
   {
      /* The GL_COMPILE and GL_COMPILE_AND_EXECUTE cases.  These
       * could be handled by the above code, but it gets a little
       * complex.  The generated list is still of good quality
       * this way.
       */
      gl_Begin( ctx, mode );
      for (i=0;i<count;i++) {
         gl_ArrayElement( ctx, start+i );
      }
      gl_End( ctx );
   }
   else
   {
      /* The degenerate case where vertices are not enabled - only
       * need to process the very final array element, as all of the
       * preceding ones would be overwritten anyway. 
       */
      gl_Begin( ctx, mode );
      gl_ArrayElement( ctx, start+count );
      gl_End( ctx );
   }
}



/* KW: Exactly fakes the effects of calling glArrayElement multiple times.
 *     Compilation is handled via. the IM->maybe_transform_vb() callback.
 */
#if 1
#define DRAW_ELT(FUNC, TYPE)				\
static void FUNC( GLcontext *ctx, GLenum mode,		\
		  TYPE *indices, GLuint count )		\
{							\
   GLuint i,j;						\
							\
   gl_Begin( ctx, mode );				\
							\
   for (j = 0 ; j < count ; ) {				\
      struct immediate *IM = ctx->input;		\
      GLuint start = IM->Start;				\
      GLuint nr = MIN2( VB_MAX, count - j + start );	\
      GLuint sf = IM->Flag[start];			\
      IM->FlushElt |= IM->ArrayEltFlush;		\
							\
      for (i = start ; i < nr ; i++) {			\
	 IM->Elt[i] = (GLuint) *indices++;		\
	 IM->Flag[i] = VERT_ELT;			\
      }							\
							\
      if (j == 0) IM->Flag[start] |= sf;		\
							\
      IM->Count = nr;					\
      j += nr - start;					\
							\
      if (j == count) gl_End( ctx );			\
      IM->maybe_transform_vb( IM );			\
   }							\
}
#else 
#define DRAW_ELT(FUNC, TYPE)				\
static void FUNC( GLcontext *ctx, GLenum mode,		\
		   TYPE *indices, GLuint count )	\
{							\
  int i;						\
  glBegin(mode);					\
  for (i = 0 ; i < count ; i++)				\
    glArrayElement( indices[i] );			\
  glEnd();						\
}
#endif
	

DRAW_ELT( draw_elt_ubyte, GLubyte )
DRAW_ELT( draw_elt_ushort, GLushort )
DRAW_ELT( draw_elt_uint, GLuint )


static GLuint natural_stride[0x10] = 
{
   sizeof(GLbyte),		/* 0 */
   sizeof(GLubyte),		/* 1 */
   sizeof(GLshort),		/* 2 */
   sizeof(GLushort),		/* 3 */
   sizeof(GLint),		/* 4 */
   sizeof(GLuint),		/* 5 */
   sizeof(GLfloat),		/* 6 */
   2 * sizeof(GLbyte),		/* 7 */
   3 * sizeof(GLbyte),		/* 8 */
   4 * sizeof(GLbyte),		/* 9 */
   sizeof(GLdouble),		/* a */
   0,				/* b */
   0,				/* c */
   0,				/* d */
   0,				/* e */
   0				/* f */
};


void
_mesa_DrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_cva *cva;
      
   cva = &ctx->CVA;
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glDrawElements");

   if (count <= 0) {
      if (count < 0)
	 gl_error( ctx, GL_INVALID_VALUE, "glDrawElements(count)" );
      return;
   }

   if (mode < 0 || mode > GL_POLYGON) {
      gl_error( ctx, GL_INVALID_ENUM, "glDrawArrays(mode)" );
      return;
   }
   
   if (type != GL_UNSIGNED_INT && type != GL_UNSIGNED_BYTE && type != GL_UNSIGNED_SHORT)
   {
       gl_error( ctx, GL_INVALID_ENUM, "glDrawElements(type)" );
       return;
   }

   if (ctx->NewState)
      gl_update_state(ctx);

   if (ctx->CompileCVAFlag) 
   {
#if defined(MESA_CVA_PROF)
      force_init_prof(); 
#endif

      /* Treat VERT_ELT like a special client array.
       */
      ctx->Array.NewArrayState |= VERT_ELT;
#ifdef VAO
      ctx->Array.Current->Summary |= VERT_ELT;
      ctx->Array.Current->Flags |= VERT_ELT;
#else
      ctx->Array.Summary |= VERT_ELT;
      ctx->Array.Flags |= VERT_ELT;
#endif

      cva->elt_mode = mode;
      cva->elt_count = count;
      cva->Elt.Type = type;
      cva->Elt.Ptr = (void *) indices;
      cva->Elt.StrideB = natural_stride[TYPE_IDX(type)];
      cva->EltFunc = gl_trans_1ui_tab[TYPE_IDX(type)];

      if (!cva->pre.pipeline_valid) 
	 gl_build_precalc_pipeline( ctx );
      else if (MESA_VERBOSE & VERBOSE_PIPELINE)
	 fprintf(stderr, ": dont rebuild\n");

      gl_cva_force_precalc( ctx );

      /* Did we 'precalculate' the render op?
       */
      if (ctx->CVA.pre.ops & PIPE_OP_RENDER) {
	 ctx->Array.NewArrayState |= VERT_ELT;
#ifdef VAO
	 ctx->Array.Current->Summary &= ~VERT_ELT;
	 ctx->Array.Current->Flags &= ~VERT_ELT;
#else
	 ctx->Array.Summary &= ~VERT_ELT;
	 ctx->Array.Flags &= ~VERT_ELT;
#endif
	 return;
      } 

      if ( (MESA_VERBOSE&VERBOSE_VARRAY) )
	 printf("using immediate\n");
   }


   /* Otherwise, have to use the immediate path to render.
    */
   switch (type) {
   case GL_UNSIGNED_BYTE:
   {
      GLubyte *ub_indices = (GLubyte *) indices;
#ifdef VAO
      if (ctx->Array.Current->Summary & VERT_OBJ_ANY) {
#else
      if (ctx->Array.Summary & VERT_OBJ_ANY) {
#endif
	 draw_elt_ubyte( ctx, mode, ub_indices, count );
      } else {
	 gl_ArrayElement( ctx, (GLuint) ub_indices[count-1] );
      }
   }
   break;
   case GL_UNSIGNED_SHORT:
   {
      GLushort *us_indices = (GLushort *) indices;
#ifdef VAO
      if (ctx->Array.Current->Summary & VERT_OBJ_ANY) {
#else
      if (ctx->Array.Summary & VERT_OBJ_ANY) {
#endif
	 draw_elt_ushort( ctx, mode, us_indices, count );
      } else {
	 gl_ArrayElement( ctx, (GLuint) us_indices[count-1] );
      }
   }
   break;
   case GL_UNSIGNED_INT:
   {
      GLuint *ui_indices = (GLuint *) indices;
#ifdef VAO
      if (ctx->Array.Current->Summary & VERT_OBJ_ANY) {
#else
      if (ctx->Array.Summary & VERT_OBJ_ANY) {
#endif
	 draw_elt_uint( ctx, mode, ui_indices, count );
      } else {
	 gl_ArrayElement( ctx, ui_indices[count-1] );
      }
   }
   break;
   default:
      gl_error( ctx, GL_INVALID_ENUM, "glDrawElements(type)" );
      break;
   }

   if (ctx->CompileCVAFlag) {
      ctx->Array.NewArrayState |= VERT_ELT;
#ifdef VAO
      ctx->Array.Current->Summary &= ~VERT_ELT;
#else
      ctx->Array.Summary &= ~VERT_ELT;
#endif
   }
}



void
_mesa_InterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
   GET_CURRENT_CONTEXT(ctx);
   GLboolean tflag, cflag, nflag;              /* enable/disable flags */
   GLint tcomps, ccomps, vcomps;               /* components per texcoord, color, vertex */

   GLenum ctype = 0;                           /* color type */
   GLint coffset = 0, noffset = 0, voffset = 0;/* color, normal, vertex offsets */
   GLint defstride;                            /* default stride */
   GLint c, f;
   GLint coordUnitSave;
   
   f = sizeof(GLfloat);
   c = f * ((4*sizeof(GLubyte) + (f-1)) / f);

   if (stride<0) {
      gl_error( ctx, GL_INVALID_VALUE, "glInterleavedArrays(stride)" );
      return;
   }

   switch (format) {
      case GL_V2F:
         tflag = GL_FALSE;  cflag = GL_FALSE;  nflag = GL_FALSE;
         tcomps = 0;  ccomps = 0;  vcomps = 2;
         voffset = 0;
         defstride = 2*f;
         break;
      case GL_V3F:
         tflag = GL_FALSE;  cflag = GL_FALSE;  nflag = GL_FALSE;
         tcomps = 0;  ccomps = 0;  vcomps = 3;
         voffset = 0;
         defstride = 3*f;
         break;
      case GL_C4UB_V2F:
         tflag = GL_FALSE;  cflag = GL_TRUE;  nflag = GL_FALSE;
         tcomps = 0;  ccomps = 4;  vcomps = 2;
         ctype = GL_UNSIGNED_BYTE;
         coffset = 0;
         voffset = c;
         defstride = c + 2*f;
         break;
      case GL_C4UB_V3F:
         tflag = GL_FALSE;  cflag = GL_TRUE;  nflag = GL_FALSE;
         tcomps = 0;  ccomps = 4;  vcomps = 3;
         ctype = GL_UNSIGNED_BYTE;
         coffset = 0;
         voffset = c;
         defstride = c + 3*f;
         break;
      case GL_C3F_V3F:
         tflag = GL_FALSE;  cflag = GL_TRUE;  nflag = GL_FALSE;
         tcomps = 0;  ccomps = 3;  vcomps = 3;
         ctype = GL_FLOAT;
         coffset = 0;
         voffset = 3*f;
         defstride = 6*f;
         break;
      case GL_N3F_V3F:
         tflag = GL_FALSE;  cflag = GL_FALSE;  nflag = GL_TRUE;
         tcomps = 0;  ccomps = 0;  vcomps = 3;
         noffset = 0;
         voffset = 3*f;
         defstride = 6*f;
         break;
      case GL_C4F_N3F_V3F:
         tflag = GL_FALSE;  cflag = GL_TRUE;  nflag = GL_TRUE;
         tcomps = 0;  ccomps = 4;  vcomps = 3;
         ctype = GL_FLOAT;
         coffset = 0;
         noffset = 4*f;
         voffset = 7*f;
         defstride = 10*f;
         break;
      case GL_T2F_V3F:
         tflag = GL_TRUE;  cflag = GL_FALSE;  nflag = GL_FALSE;
         tcomps = 2;  ccomps = 0;  vcomps = 3;
         voffset = 2*f;
         defstride = 5*f;
         break;
      case GL_T4F_V4F:
         tflag = GL_TRUE;  cflag = GL_FALSE;  nflag = GL_FALSE;
         tcomps = 4;  ccomps = 0;  vcomps = 4;
         voffset = 4*f;
         defstride = 8*f;
         break;
      case GL_T2F_C4UB_V3F:
         tflag = GL_TRUE;  cflag = GL_TRUE;  nflag = GL_FALSE;
         tcomps = 2;  ccomps = 4;  vcomps = 3;
         ctype = GL_UNSIGNED_BYTE;
         coffset = 2*f;
         voffset = c+2*f;
         defstride = c+5*f;
         break;
      case GL_T2F_C3F_V3F:
         tflag = GL_TRUE;  cflag = GL_TRUE;  nflag = GL_FALSE;
         tcomps = 2;  ccomps = 3;  vcomps = 3;
         ctype = GL_FLOAT;
         coffset = 2*f;
         voffset = 5*f;
         defstride = 8*f;
         break;
      case GL_T2F_N3F_V3F:
         tflag = GL_TRUE;  cflag = GL_FALSE;  nflag = GL_TRUE;
         tcomps = 2;  ccomps = 0;  vcomps = 3;
         noffset = 2*f;
         voffset = 5*f;
         defstride = 8*f;
         break;
      case GL_T2F_C4F_N3F_V3F:
         tflag = GL_TRUE;  cflag = GL_TRUE;  nflag = GL_TRUE;
         tcomps = 2;  ccomps = 4;  vcomps = 3;
         ctype = GL_FLOAT;
         coffset = 2*f;
         noffset = 6*f;
         voffset = 9*f;
         defstride = 12*f;
         break;
      case GL_T4F_C4F_N3F_V4F:
         tflag = GL_TRUE;  cflag = GL_TRUE;  nflag = GL_TRUE;
         tcomps = 4;  ccomps = 4;  vcomps = 4;
         ctype = GL_FLOAT;
         coffset = 4*f;
         noffset = 8*f;
         voffset = 11*f;
         defstride = 15*f;
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glInterleavedArrays(format)" );
         return;
   }

   if (stride==0) {
      stride = defstride;
   }

   _mesa_DisableClientState( GL_EDGE_FLAG_ARRAY );
   _mesa_DisableClientState( GL_INDEX_ARRAY );

   /* Texcoords */
   coordUnitSave = ctx->Array.ActiveTexture;
   if (tflag) {
      GLint i;
#ifdef VAO
      GLint factor = ctx->Array.Current->TexCoordInterleaveFactor;
#else
      GLint factor = ctx->Array.TexCoordInterleaveFactor;
#endif
      for (i = 0; i < factor; i++) {
         _mesa_ClientActiveTextureARB( (GLenum) (GL_TEXTURE0_ARB + i) );
         _mesa_EnableClientState( GL_TEXTURE_COORD_ARRAY );
         glTexCoordPointer( tcomps, GL_FLOAT, stride,
                             (GLubyte *) pointer + i * coffset );
      }
      for (i = factor; i < (GLint) ctx->Const.MaxTextureUnits; i++) {
         _mesa_ClientActiveTextureARB( (GLenum) (GL_TEXTURE0_ARB + i) );
         _mesa_DisableClientState( GL_TEXTURE_COORD_ARRAY );
      }
   }
   else {
      GLint i;
      for (i = 0; i < (GLint) ctx->Const.MaxTextureUnits; i++) {
         _mesa_ClientActiveTextureARB( (GLenum) (GL_TEXTURE0_ARB + i) );
         _mesa_DisableClientState( GL_TEXTURE_COORD_ARRAY );
      }
   }
   /* Restore texture coordinate unit index */
   _mesa_ClientActiveTextureARB( (GLenum) (GL_TEXTURE0_ARB + coordUnitSave) );


   /* Color */
   if (cflag) {
      _mesa_EnableClientState( GL_COLOR_ARRAY );
      glColorPointer( ccomps, ctype, stride,
                       (GLubyte*) pointer + coffset );
   }
   else {
      _mesa_DisableClientState( GL_COLOR_ARRAY );
   }


   /* Normals */
   if (nflag) {
      _mesa_EnableClientState( GL_NORMAL_ARRAY );
      glNormalPointer( GL_FLOAT, stride,
                        (GLubyte*) pointer + noffset );
   }
   else {
      _mesa_DisableClientState( GL_NORMAL_ARRAY );
   }

   _mesa_EnableClientState( GL_VERTEX_ARRAY );
   glVertexPointer( vcomps, GL_FLOAT, stride,
                     (GLubyte *) pointer + voffset );
}



void
_mesa_DrawRangeElements(GLenum mode, GLuint start,
                        GLuint end, GLsizei count,
                        GLenum type, const GLvoid *indices)
{
   GET_CURRENT_CONTEXT(ctx);

   if (end < start) {
      gl_error(ctx, GL_INVALID_VALUE, "glDrawRangeElements( end < start )");
      return;
   }

#if 0
   /*
    * XXX something in locked arrays is broken!  If start = 0,
    * end = 1 and count = 2 we'll take the LockArrays path and
    * get incorrect results.  See Scott McMillan's bug of 3 Jan 2000.
    * For now, don't use locked arrays.
    */
   if (!ctx->Array.LockCount && 2*count > (GLint) 3*(end-start)) {
      glLockArraysEXT( start, end );
      glDrawElements( mode, count, type, indices );
      glUnlockArraysEXT();
   } else {
      glDrawElements( mode, count, type, indices );
   }
#else
   glDrawElements( mode, count, type, indices );
#endif
}



void gl_update_client_state( GLcontext *ctx )
{
   static GLuint sz_flags[5] = { 0, 
				 0,
				 VERT_OBJ_2, 
				 VERT_OBJ_23, 
				 VERT_OBJ_234 };

   static GLuint tc_flags[5] = { 0, 
				 VERT_TEX0_1,
				 VERT_TEX0_12, 
				 VERT_TEX0_123, 
				 VERT_TEX0_1234 };

#ifdef VAO
   ctx->Array.Current->Flags = 0;
   ctx->Array.Current->Summary = 0;
#else
   ctx->Array.Flags = 0;
   ctx->Array.Summary = 0;
#endif
   ctx->input->ArrayIncr = 0;
   
#ifdef VAO
   if (ctx->Array.Current->Normal.Enabled)      ctx->Array.Current->Flags |= VERT_NORM;
   if (ctx->Array.Current->Color.Enabled)       ctx->Array.Current->Flags |= VERT_RGBA;
   if (ctx->Array.Current->Index.Enabled)       ctx->Array.Current->Flags |= VERT_INDEX;
   if (ctx->Array.Current->EdgeFlag.Enabled)    ctx->Array.Current->Flags |= VERT_EDGE;
   if (ctx->Array.Current->Vertex.Enabled) {
      ctx->Array.Current->Flags |= sz_flags[ctx->Array.Current->Vertex.Size];
      ctx->input->ArrayIncr = 1;
   }
   if (ctx->Array.Current->TexCoord[0].Enabled) {
      ctx->Array.Current->Flags |= tc_flags[ctx->Array.Current->TexCoord[0].Size];
   }
   if (ctx->Array.Current->TexCoord[1].Enabled) {
      ctx->Array.Current->Flags |= (tc_flags[ctx->Array.Current->TexCoord[1].Size] << NR_TEXSIZE_BITS);
   }
#else
   if (ctx->Array.Normal.Enabled)      ctx->Array.Flags |= VERT_NORM;
   if (ctx->Array.Color.Enabled)       ctx->Array.Flags |= VERT_RGBA;
   if (ctx->Array.Index.Enabled)       ctx->Array.Flags |= VERT_INDEX;
   if (ctx->Array.EdgeFlag.Enabled)    ctx->Array.Flags |= VERT_EDGE;
   if (ctx->Array.Vertex.Enabled) {
      ctx->Array.Flags |= sz_flags[ctx->Array.Vertex.Size];
      ctx->input->ArrayIncr = 1;
   }
   if (ctx->Array.TexCoord[0].Enabled) {
      ctx->Array.Flags |= tc_flags[ctx->Array.TexCoord[0].Size];
   }
   if (ctx->Array.TexCoord[1].Enabled) {
      ctx->Array.Flags |= (tc_flags[ctx->Array.TexCoord[1].Size] << NR_TEXSIZE_BITS);
   }
#endif

   /* Not really important any more:
    */
#ifdef VAO
   ctx->Array.Current->Summary = ctx->Array.Current->Flags & VERT_DATA;
   ctx->input->ArrayAndFlags = ~ctx->Array.Current->Flags;
#else
   ctx->Array.Summary = ctx->Array.Flags & VERT_DATA;
   ctx->input->ArrayAndFlags = ~ctx->Array.Flags;
#endif
   ctx->input->ArrayEltFlush = !(ctx->CompileCVAFlag);
}



/**********************************************************************/
/* Vertex Array Objects extension                                     */
/**********************************************************************/

#ifdef VAO

struct gl_array_object *
_mesa_alloc_vertex_array_object(GLcontext *ctx, GLuint name)
{
   struct gl_array_object *arrayObj;

   arrayObj = MALLOC_STRUCT(gl_array_object);
   if (arrayObj) {
      GLuint i;
      arrayObj->Name = name;
      arrayObj->RefCount = 1;
      arrayObj->Vertex.Size = 4;
      arrayObj->Vertex.Type = GL_FLOAT;
      arrayObj->Vertex.Stride = 0;
      arrayObj->Vertex.StrideB = 0;
      arrayObj->Vertex.Ptr = NULL;
      arrayObj->Vertex.Enabled = GL_FALSE;
      arrayObj->Normal.Type = GL_FLOAT;
      arrayObj->Normal.Stride = 0;
      arrayObj->Normal.StrideB = 0;
      arrayObj->Normal.Ptr = NULL;
      arrayObj->Normal.Enabled = GL_FALSE;
      arrayObj->Color.Size = 4;
      arrayObj->Color.Type = GL_FLOAT;
      arrayObj->Color.Stride = 0;
      arrayObj->Color.StrideB = 0;
      arrayObj->Color.Ptr = NULL;
      arrayObj->Color.Enabled = GL_FALSE;
      arrayObj->Index.Type = GL_FLOAT;
      arrayObj->Index.Stride = 0;
      arrayObj->Index.StrideB = 0;
      arrayObj->Index.Ptr = NULL;
      arrayObj->Index.Enabled = GL_FALSE;
      for (i = 0; i < MAX_TEXTURE_UNITS; i++) {
         arrayObj->TexCoord[i].Size = 4;
         arrayObj->TexCoord[i].Type = GL_FLOAT;
         arrayObj->TexCoord[i].Stride = 0;
         arrayObj->TexCoord[i].StrideB = 0;
         arrayObj->TexCoord[i].Ptr = NULL;
         arrayObj->TexCoord[i].Enabled = GL_FALSE;
      }
      arrayObj->TexCoordInterleaveFactor = 1;
      arrayObj->EdgeFlag.Stride = 0;
      arrayObj->EdgeFlag.StrideB = 0;
      arrayObj->EdgeFlag.Ptr = NULL;
      arrayObj->EdgeFlag.Enabled = GL_FALSE;

      /* Put into hash table */
      _mesa_HashInsert(ctx->Shared->ArrayObjects, name, arrayObj);
   }
   return arrayObj;
}


void
glGenArraySetsEXT(GLsizei n, GLuint *arrayset)
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint first;
   GLint i;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGenArraySetsEXT");

   if (n < 0) {
      gl_error(ctx, GL_INVALID_VALUE, "glGenArraySetsEXT");
      return;
   }

   if (!arrayset)
      return;

   /*
    * This must be atomic (generation and allocation of texture IDs)
    */
   /*XXX _glthread_LOCK_MUTEX(GenTexturesLock);*/

   first = _mesa_HashFindFreeKeyBlock(ctx->Shared->ArrayObjects, n);

   /* Return the object names */
   for (i = 0; i < n; i++) {
      arrayset[i] = first + i;
   }

   /* Allocate new array objects */
   for (i = 0; i < n; i++) {
      struct gl_array_object *arrayObj;
      GLuint name = first + i;
      arrayObj = _mesa_alloc_vertex_array_object(ctx, name);
      if (!arrayObj) {
         gl_error(ctx, GL_OUT_OF_MEMORY, "glGenArraySetsEXT");
         break;
      }
   }

   /*XXX _glthread_UNLOCK_MUTEX(GenTexturesLock);*/
}


void
glBindArraySetEXT(GLuint arraySet)
{
   struct gl_array_object *arrayObj;
   GET_CURRENT_CONTEXT(ctx);

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glBindArraySetEXT");

   if (arraySet < 0) {
      gl_error(ctx, GL_INVALID_OPERATION, "glBindArraySetEXT");
      return;
   }

   ctx->Array.Current->RefCount--;
   if (ctx->Array.Current->RefCount == 0) {
      _mesa_HashRemove(ctx->Shared->ArrayObjects, arraySet);
      FREE(ctx->Array.Current);
   }

   arrayObj = (struct gl_array_object *) _mesa_HashLookup(ctx->Shared->ArrayObjects, arraySet);
   if (arrayObj) {
      ctx->Array.Current = arrayObj;
   }
   else {
      /* create the array object and insert into hash table */
      arrayObj = _mesa_alloc_vertex_array_object(ctx, arraySet);
      if (!arrayObj) {
         gl_error(ctx, GL_OUT_OF_MEMORY, "glBindArraySetEXT");
         return;
      }
      ctx->Array.Current = (struct gl_array_object *) _mesa_HashLookup(ctx->Shared->ArrayObjects, 0);
   }

   ctx->Array.Current->RefCount++;

   /* Signal new state */
   /*   ctx->Array.NewArrayState = ~0;*/
   ctx->NewState |= NEW_CLIENT_STATE;

#if 0
   printf("Bind %d\n", ctx->Array.Current->Name);
   printf("Vertex array size: %d\n", ctx->Array.Current->Vertex.Size);
   printf("Vertex array enable: %d\n", ctx->Array.Current->Vertex.Enabled);

   printf("Normal array size: %d\n", ctx->Array.Current->Normal.Size);
   printf("Normal array enable: %d\n", ctx->Array.Current->Normal.Enabled);
   printf("Lock first %d  count %d\n", ctx->Array.Current->LockFirst,
          ctx->Array.Current->LockCount);
#endif
}


void
glDeleteArraySetsEXT(GLsizei n, const GLuint *arraySet)
{
   GLint i;
   GET_CURRENT_CONTEXT(ctx);
   
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glDeleteArraySetsEXT");

   if (n < 0) {
      gl_error(ctx, GL_INVALID_OPERATION, "glDeleteArraySetEXT");
      return;
   }

   for (i = 0; i < n; i++) {
      if (arraySet[i] > 0) {
         struct gl_array_object *arrayObj;
         arrayObj = (struct gl_array_object *) _mesa_HashLookup(ctx->Shared->ArrayObjects, arraySet[i]);
         if (arrayObj) {
            arrayObj->RefCount--;
            if (arrayObj->RefCount == 0) {
               _mesa_HashRemove(ctx->Shared->ArrayObjects, arraySet[i]);
               FREE(arrayObj);
            }
         }
      }
   }
}


GLboolean
glIsArraySetEXT(GLuint arraySet)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH_WITH_RETVAL(ctx, "glIsArraySetEXT",
						  GL_FALSE);

   if (arraySet > 0 && _mesa_HashLookup(ctx->Shared->ArrayObjects, arraySet)) {
      return GL_TRUE;
   }
   else {
      return GL_FALSE;
   }
}

#endif
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d4 4
a7 4
 * Version:  4.1
 *
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
 *
d14 1
a14 1
 *
d17 1
a17 1
 *
d26 3
d31 2
d35 1
a35 1
#include "dlist.h"
d38 1
d40 1
d43 2
a44 1
#include "mtypes.h"
d46 7
a52 1
#include "math/m_translate.h"
d60 3
a62 4
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (size < 2 || size > 4) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glVertexPointer(size)" );
d65 2
a66 2
   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glVertexPointer(stride)" );
d69 1
a69 1

d71 11
a81 5
      _mesa_debug(ctx, "glVertexPointer( sz %d type %s stride %d )\n", size,
                  _mesa_lookup_enum_by_nr( type ), stride);

   /* always need to check that <type> is legal */
   switch (type) {
d83 5
a87 1
         ctx->Array.Vertex.StrideB = size * sizeof(GLshort);
d90 5
a94 1
         ctx->Array.Vertex.StrideB = size * sizeof(GLint);
d97 5
a101 1
         ctx->Array.Vertex.StrideB = size * sizeof(GLfloat);
d104 5
a108 1
         ctx->Array.Vertex.StrideB = size * sizeof(GLdouble);
d111 1
a111 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glVertexPointer(type)" );
d113 1
d115 9
a123 4

   if (stride)
      ctx->Array.Vertex.StrideB = stride;

d128 5
a132 5
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_VERTEX;

   if (ctx->Driver.VertexPointer)
      ctx->Driver.VertexPointer( ctx, size, type, stride, ptr );
d142 3
a144 4
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glNormalPointer(stride)" );
d149 11
a159 4
      _mesa_debug(ctx, "glNormalPointer( type %s stride %d )\n",
                  _mesa_lookup_enum_by_nr( type ), stride);

   switch (type) {
d161 5
a165 1
         ctx->Array.Normal.StrideB = 3 * sizeof(GLbyte);
d168 5
a172 1
         ctx->Array.Normal.StrideB = 3 * sizeof(GLshort);
d175 5
a179 1
         ctx->Array.Normal.StrideB = 3 * sizeof(GLint);
d182 5
a186 1
         ctx->Array.Normal.StrideB = 3 * sizeof(GLfloat);
d189 5
a193 1
         ctx->Array.Normal.StrideB = 3 * sizeof(GLdouble);
d196 1
a196 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glNormalPointer(type)" );
d198 1
d200 7
a206 4
   if (stride)
      ctx->Array.Normal.StrideB = stride;

   ctx->Array.Normal.Size = 3;
d210 5
a214 5
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_NORMAL;

   if (ctx->Driver.NormalPointer)
      ctx->Driver.NormalPointer( ctx, type, stride, ptr );
a222 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d224 2
a225 2
   if (size < 3 || size > 4) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glColorPointer(size)" );
d229 1
a229 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glColorPointer(stride)" );
d234 11
a244 4
      _mesa_debug(ctx, "glColorPointer( sz %d type %s stride %d )\n", size,
                  _mesa_lookup_enum_by_nr( type ), stride);

   switch (type) {
d246 5
a250 1
         ctx->Array.Color.StrideB = size * sizeof(GLbyte);
d253 5
a257 1
         ctx->Array.Color.StrideB = size * sizeof(GLubyte);
d260 5
a264 1
         ctx->Array.Color.StrideB = size * sizeof(GLshort);
d267 5
a271 1
         ctx->Array.Color.StrideB = size * sizeof(GLushort);
d274 5
a278 1
         ctx->Array.Color.StrideB = size * sizeof(GLint);
d281 5
a285 1
         ctx->Array.Color.StrideB = size * sizeof(GLuint);
d288 5
a292 1
         ctx->Array.Color.StrideB = size * sizeof(GLfloat);
d295 5
a299 1
         ctx->Array.Color.StrideB = size * sizeof(GLdouble);
d302 1
a302 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glColorPointer(type)" );
d304 1
d306 8
a313 4

   if (stride)
      ctx->Array.Color.StrideB = stride;

d318 5
a322 5
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_COLOR0;

   if (ctx->Driver.ColorPointer)
      ctx->Driver.ColorPointer( ctx, size, type, stride, ptr );
a327 38
_mesa_FogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glFogCoordPointer(stride)" );
      return;
   }

   switch (type) {
      case GL_FLOAT:
         ctx->Array.FogCoord.StrideB =  sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         ctx->Array.FogCoord.StrideB =  sizeof(GLdouble);
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glFogCoordPointer(type)" );
         return;
   }

   if (stride)
      ctx->Array.FogCoord.StrideB = stride;

   ctx->Array.FogCoord.Size = 1;
   ctx->Array.FogCoord.Type = type;
   ctx->Array.FogCoord.Stride = stride;
   ctx->Array.FogCoord.Ptr = (void *) ptr;
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_FOGCOORD;

   if (ctx->Driver.FogCoordPointer)
      ctx->Driver.FogCoordPointer( ctx, type, stride, ptr );
}


void
d331 3
a333 4
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glIndexPointer(stride)" );
d337 7
a343 1
   switch (type) {
d345 3
d349 1
d352 3
d356 1
d359 3
d363 1
d366 3
d370 1
d373 3
d377 1
d380 1
a380 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glIndexPointer(type)" );
d382 1
d384 7
a390 5

   if (stride)
      ctx->Array.Index.StrideB = stride;

   ctx->Array.Index.Size = 1;
d394 5
a398 70
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_INDEX;

   if (ctx->Driver.IndexPointer)
      ctx->Driver.IndexPointer( ctx, type, stride, ptr );
}


void
_mesa_SecondaryColorPointerEXT(GLint size, GLenum type,
			       GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (size != 3 && size != 4) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glSecondaryColorPointer(size)" );
      return;
   }
   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glSecondaryColorPointer(stride)" );
      return;
   }

   if (MESA_VERBOSE&(VERBOSE_VARRAY|VERBOSE_API))
      _mesa_debug(ctx, "glSecondaryColorPointer( sz %d type %s stride %d )\n",
                  size, _mesa_lookup_enum_by_nr( type ), stride);

   switch (type) {
      case GL_BYTE:
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLbyte);
         break;
      case GL_UNSIGNED_BYTE:
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLubyte);
         break;
      case GL_SHORT:
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLshort);
         break;
      case GL_UNSIGNED_SHORT:
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLushort);
         break;
      case GL_INT:
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLint);
         break;
      case GL_UNSIGNED_INT:
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLuint);
         break;
      case GL_FLOAT:
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLdouble);
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glSecondaryColorPointer(type)" );
         return;
   }

   if (stride)
      ctx->Array.SecondaryColor.StrideB = stride;

   ctx->Array.SecondaryColor.Size = 3; /* hardwire */
   ctx->Array.SecondaryColor.Type = type;
   ctx->Array.SecondaryColor.Stride = stride;
   ctx->Array.SecondaryColor.Ptr = (void *) ptr;
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_COLOR1;

   if (ctx->Driver.SecondaryColorPointer)
      ctx->Driver.SecondaryColorPointer( ctx, size, type, stride, ptr );
d404 1
a404 2
_mesa_TexCoordPointer(GLint size, GLenum type, GLsizei stride,
                      const GLvoid *ptr)
d407 3
a409 2
   GLuint texUnit = ctx->Array.ActiveTexture;
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d411 2
a412 2
   if (size < 1 || size > 4) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glTexCoordPointer(size)" );
d415 2
a416 2
   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glTexCoordPointer(stride)" );
d421 13
a433 5
      _mesa_debug(ctx, "glTexCoordPointer(unit %u sz %d type %s stride %d)\n",
                  texUnit, size, _mesa_lookup_enum_by_nr( type ), stride);

   /* always need to check that <type> is legal */
   switch (type) {
d435 5
a439 1
         ctx->Array.TexCoord[texUnit].StrideB = size * sizeof(GLshort);
d442 5
a446 1
         ctx->Array.TexCoord[texUnit].StrideB = size * sizeof(GLint);
d449 5
a453 1
         ctx->Array.TexCoord[texUnit].StrideB = size * sizeof(GLfloat);
d456 5
a460 1
         ctx->Array.TexCoord[texUnit].StrideB = size * sizeof(GLdouble);
d463 1
a463 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexCoordPointer(type)" );
d465 1
d467 9
a475 4

   if (stride)
      ctx->Array.TexCoord[texUnit].StrideB = stride;

a479 2
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_TEXCOORD(texUnit);
d481 5
a485 2
   if (ctx->Driver.TexCoordPointer)
      ctx->Driver.TexCoordPointer( ctx, size, type, stride, ptr );
d489 2
d492 1
a492 1
_mesa_EdgeFlagPointer(GLsizei stride, const GLvoid *vptr)
a495 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d498 1
a498 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glEdgeFlagPointer(stride)" );
d501 11
d515 9
a523 5
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_EDGEFLAG;

   if (ctx->Driver.EdgeFlagPointer)
      ctx->Driver.EdgeFlagPointer( ctx, stride, ptr );
d527 4
a530 2
void _mesa_VertexAttribPointerNV(GLuint index, GLint size, GLenum type,
                                 GLsizei stride, const GLvoid *ptr)
a531 24
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (index >= VERT_ATTRIB_MAX) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerNV(index)");
      return;
   }

   if (size < 1 || size > 4) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerNV(size)");
      return;
   }

   if (stride < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerNV(stride)");
      return;
   }

   if (type == GL_UNSIGNED_BYTE && size != 4) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerNV(size!=4)");
      return;
   }

   /* check for valid 'type' and compute StrideB right away */
d534 1
a534 1
         ctx->Array.VertexAttrib[index].StrideB = size * sizeof(GLubyte);
d536 2
a537 2
      case GL_SHORT:
         ctx->Array.VertexAttrib[index].StrideB = size * sizeof(GLshort);
d539 2
a540 5
      case GL_FLOAT:
         ctx->Array.VertexAttrib[index].StrideB = size * sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         ctx->Array.VertexAttrib[index].StrideB = size * sizeof(GLdouble);
d543 1
a543 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glVertexAttribPointerNV(type)" );
d546 7
a553 14
   if (stride)
      ctx->Array.VertexAttrib[index].StrideB = stride;

   ctx->Array.VertexAttrib[index].Stride = stride;
   ctx->Array.VertexAttrib[index].Size = size;
   ctx->Array.VertexAttrib[index].Type = type;
   ctx->Array.VertexAttrib[index].Ptr = (void *) ptr;

   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_ATTRIB(index);

   if (ctx->Driver.VertexAttribPointer)
      ctx->Driver.VertexAttribPointer( ctx, index, size, type, stride, ptr );
}
d611 754
d1369 2
a1370 2
   GLboolean tflag, cflag, nflag;  /* enable/disable flags */
   GLint tcomps, ccomps, vcomps;   /* components per texcoord, color, vertex */
d1372 3
a1374 3
   GLenum ctype = 0;               /* color type */
   GLint coffset = 0, noffset = 0, voffset;/* color, normal, vertex offsets */
   GLint defstride;                /* default stride */
d1377 1
a1377 3

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

d1382 1
a1382 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glInterleavedArrays(stride)" );
d1493 1
a1493 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glInterleavedArrays(format)" );
d1508 3
d1512 1
d1516 2
a1517 2
         _mesa_TexCoordPointer( tcomps, GL_FLOAT, stride,
				(GLubyte *) pointer + i * coffset );
d1538 2
a1539 2
      _mesa_ColorPointer( ccomps, ctype, stride,
			  (GLubyte*) pointer + coffset );
d1549 2
a1550 2
      _mesa_NormalPointer( GL_FLOAT, stride,
			   (GLubyte*) pointer + noffset );
d1557 2
a1558 2
   _mesa_VertexPointer( vcomps, GL_FLOAT, stride,
			(GLubyte *) pointer + voffset );
d1564 3
a1566 1
_mesa_LockArraysEXT(GLint first, GLsizei count)
a1568 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1570 4
a1573 2
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glLockArrays %d %d\n", first, count);
d1575 100
a1674 9
   if (first == 0 && count > 0 &&
       count <= (GLint) ctx->Const.MaxArrayLockSize) {
      ctx->Array.LockFirst = first;
      ctx->Array.LockCount = count;
   }
   else {
      ctx->Array.LockFirst = 0;
      ctx->Array.LockCount = 0;
   }
d1676 40
a1715 2
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_ALL;
d1717 4
a1720 2
   if (ctx->Driver.LockArraysEXT)
      ctx->Driver.LockArraysEXT( ctx, first, count );
d1725 1
a1725 1
_mesa_UnlockArraysEXT( void )
d1728 2
a1729 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1731 1
a1731 2
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glUnlockArrays\n");
d1733 4
a1736 4
   ctx->Array.LockFirst = 0;
   ctx->Array.LockCount = 0;
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_ALL;
d1738 27
a1764 2
   if (ctx->Driver.UnlockArraysEXT)
      ctx->Driver.UnlockArraysEXT( ctx );
a1767 3

/* GL_EXT_multi_draw_arrays */
/* Somebody forgot to spec the first and count parameters as const! <sigh> */
d1769 1
a1769 2
_mesa_MultiDrawArraysEXT( GLenum mode, GLint *first,
                          GLsizei *count, GLsizei primcount )
d1771 1
a1772 1
   GLint i;
d1774 1
a1774 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1776 21
a1796 3
   for (i = 0; i < primcount; i++) {
      if (count[i] > 0) {
         (ctx->Exec->DrawArrays)(mode, first[i], count[i]);
d1798 1
d1800 17
a1819 1
/* GL_EXT_multi_draw_arrays */
d1821 1
a1821 2
_mesa_MultiDrawElementsEXT( GLenum mode, const GLsizei *count, GLenum type,
                            const GLvoid **indices, GLsizei primcount )
d1823 1
d1825 2
a1826 1
   GLint i;
d1828 4
a1831 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1833 11
a1843 3
   for (i = 0; i < primcount; i++) {
      if (count[i] > 0) {
         (ctx->Exec->DrawElements)(mode, count[i], type, indices[i]);
d1847 18
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d4 4
a7 4
 * Version:  4.0.3
 *
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
 *
d14 1
a14 1
 *
d17 1
a17 1
 *
d31 2
d35 1
a35 1
#include "dlist.h"
d38 1
d40 1
d43 2
a44 1
#include "mtypes.h"
d46 6
a51 1
#include "math/m_translate.h"
d60 1
a60 2
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

d62 1
a62 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glVertexPointer(size)" );
d66 1
a66 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glVertexPointer(stride)" );
d69 1
a69 1

d71 2
a72 2
      fprintf(stderr, "glVertexPointer( sz %d type %s stride %d )\n", size,
	      _mesa_lookup_enum_by_nr( type ),
d75 3
d79 1
d83 3
d87 1
d90 3
d94 1
d97 3
d101 1
d104 3
d108 1
d111 1
a111 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glVertexPointer(type)" );
d115 9
d128 5
a132 5
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_VERTEX;

   if (ctx->Driver.VertexPointer)
      ctx->Driver.VertexPointer( ctx, size, type, stride, ptr );
d142 1
a142 2
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

d144 1
a144 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glNormalPointer(stride)" );
d149 2
a150 2
      fprintf(stderr, "glNormalPointer( type %s stride %d )\n",
	      _mesa_lookup_enum_by_nr( type ),
d153 3
d157 1
d161 3
d165 1
d168 3
d172 1
d175 3
d179 1
d182 3
d186 1
d189 3
d193 1
d196 1
a196 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glNormalPointer(type)" );
d200 7
d210 5
a214 5
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_NORMAL;

   if (ctx->Driver.NormalPointer)
      ctx->Driver.NormalPointer( ctx, type, stride, ptr );
a222 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d225 1
a225 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glColorPointer(size)" );
d229 1
a229 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glColorPointer(stride)" );
d234 2
a235 2
      fprintf(stderr, "glColorPointer( sz %d type %s stride %d )\n", size,
	  _mesa_lookup_enum_by_nr( type ),
d238 3
d242 1
d246 3
d250 1
d253 3
d257 1
d260 3
d264 1
d267 3
d271 1
d274 3
d278 1
d281 3
d285 1
d288 3
d292 1
d295 3
d299 1
d302 1
a302 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glColorPointer(type)" );
d306 8
d318 5
a322 5
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_COLOR;

   if (ctx->Driver.ColorPointer)
      ctx->Driver.ColorPointer( ctx, size, type, stride, ptr );
a327 36
_mesa_FogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (stride<0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glFogCoordPointer(stride)" );
      return;
   }

   ctx->Array.FogCoord.StrideB = stride;
   if (!stride) {
      switch (type) {
      case GL_FLOAT:
         ctx->Array.FogCoord.StrideB =  sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         ctx->Array.FogCoord.StrideB =  sizeof(GLdouble);
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glFogCoordPointer(type)" );
         return;
      }
   }
   ctx->Array.FogCoord.Type = type;
   ctx->Array.FogCoord.Stride = stride;
   ctx->Array.FogCoord.Ptr = (void *) ptr;
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_FOGCOORD;

   if (ctx->Driver.FogCoordPointer)
      ctx->Driver.FogCoordPointer( ctx, type, stride, ptr );
}


void
d331 1
a331 2
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

d333 1
a333 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glIndexPointer(stride)" );
d337 3
d341 1
d345 3
d349 1
d352 3
d356 1
d359 3
d363 1
d366 3
d370 1
d373 3
d377 1
d380 1
a380 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glIndexPointer(type)" );
d384 7
d394 5
a398 70
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_INDEX;

   if (ctx->Driver.IndexPointer)
      ctx->Driver.IndexPointer( ctx, type, stride, ptr );
}


void
_mesa_SecondaryColorPointerEXT(GLint size, GLenum type,
			       GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   if (size != 3 && size != 4) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glColorPointer(size)" );
      return;
   }
   if (stride<0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glColorPointer(stride)" );
      return;
   }

   if (MESA_VERBOSE&(VERBOSE_VARRAY|VERBOSE_API))
      fprintf(stderr, "glColorPointer( sz %d type %s stride %d )\n", size,
	  _mesa_lookup_enum_by_nr( type ),
	  stride);

   ctx->Array.SecondaryColor.StrideB = stride;
   if (!stride) {
      switch (type) {
      case GL_BYTE:
         ctx->Array.SecondaryColor.StrideB =  size*sizeof(GLbyte);
         break;
      case GL_UNSIGNED_BYTE:
         ctx->Array.SecondaryColor.StrideB =  size*sizeof(GLubyte);
         break;
      case GL_SHORT:
         ctx->Array.SecondaryColor.StrideB =  size*sizeof(GLshort);
         break;
      case GL_UNSIGNED_SHORT:
         ctx->Array.SecondaryColor.StrideB =  size*sizeof(GLushort);
         break;
      case GL_INT:
         ctx->Array.SecondaryColor.StrideB =  size*sizeof(GLint);
         break;
      case GL_UNSIGNED_INT:
         ctx->Array.SecondaryColor.StrideB =  size*sizeof(GLuint);
         break;
      case GL_FLOAT:
         ctx->Array.SecondaryColor.StrideB =  size*sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         ctx->Array.SecondaryColor.StrideB =  size*sizeof(GLdouble);
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glSecondaryColorPointer(type)" );
         return;
      }
   }
   ctx->Array.SecondaryColor.Size = 3; /* hardwire */
   ctx->Array.SecondaryColor.Type = type;
   ctx->Array.SecondaryColor.Stride = stride;
   ctx->Array.SecondaryColor.Ptr = (void *) ptr;
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_SECONDARYCOLOR;

   if (ctx->Driver.SecondaryColorPointer)
      ctx->Driver.SecondaryColorPointer( ctx, size, type, stride, ptr );
d407 3
a409 2
   GLuint texUnit = ctx->Array.ActiveTexture;
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d412 1
a412 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glTexCoordPointer(size)" );
d416 1
a416 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glTexCoordPointer(stride)" );
d421 1
a421 1
      fprintf(stderr, "glTexCoordPointer( unit %u sz %d type %s stride %d )\n",
d423 2
a424 2
	  size,
	  _mesa_lookup_enum_by_nr( type ),
d427 3
d431 1
d435 3
d439 1
d442 3
d446 1
d449 3
d453 1
d456 3
d460 1
d463 1
a463 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexCoordPointer(type)" );
d467 9
a479 2
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_TEXCOORD(texUnit);
d481 5
a485 4
/*     fprintf(stderr, "%s ptr %p\n", __FUNCTION__, ptr); */

   if (ctx->Driver.TexCoordPointer)
      ctx->Driver.TexCoordPointer( ctx, size, type, stride, ptr );
a495 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d498 1
a498 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glEdgeFlagPointer(stride)" );
d501 11
d515 9
a523 5
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_EDGEFLAG;

   if (ctx->Driver.EdgeFlagPointer)
      ctx->Driver.EdgeFlagPointer( ctx, stride, ptr );
d527 26
d612 752
d1369 2
a1370 2
   GLboolean tflag, cflag, nflag;  /* enable/disable flags */
   GLint tcomps, ccomps, vcomps;   /* components per texcoord, color, vertex */
d1372 3
a1374 3
   GLenum ctype = 0;               /* color type */
   GLint coffset = 0, noffset = 0, voffset;/* color, normal, vertex offsets */
   GLint defstride;                /* default stride */
d1377 1
a1377 3

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

d1382 1
a1382 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glInterleavedArrays(stride)" );
d1493 1
a1493 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glInterleavedArrays(format)" );
d1508 3
d1512 1
d1516 2
a1517 2
         _mesa_TexCoordPointer( tcomps, GL_FLOAT, stride,
				(GLubyte *) pointer + i * coffset );
d1538 2
a1539 2
      _mesa_ColorPointer( ccomps, ctype, stride,
			  (GLubyte*) pointer + coffset );
d1549 2
a1550 2
      _mesa_NormalPointer( GL_FLOAT, stride,
			   (GLubyte*) pointer + noffset );
d1557 164
a1720 2
   _mesa_VertexPointer( vcomps, GL_FLOAT, stride,
			(GLubyte *) pointer + voffset );
d1724 43
d1769 1
a1769 1
_mesa_LockArraysEXT(GLint first, GLsizei count)
d1771 1
a1772 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1774 6
a1779 2
   if (MESA_VERBOSE & VERBOSE_API)
      fprintf(stderr, "glLockArrays %d %d\n", first, count);
d1781 9
a1789 4
   if (first == 0 && count > 0 &&
       count <= (GLint) ctx->Const.MaxArrayLockSize) {
      ctx->Array.LockFirst = first;
      ctx->Array.LockCount = count;
d1792 7
a1798 2
      ctx->Array.LockFirst = 0;
      ctx->Array.LockCount = 0;
d1801 10
a1810 2
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_ALL;
d1812 5
a1816 2
   if (ctx->Driver.LockArraysEXT)
      ctx->Driver.LockArraysEXT( ctx, first, count );
d1821 1
a1821 1
_mesa_UnlockArraysEXT( void )
d1823 1
d1825 2
a1826 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d1828 4
a1831 2
   if (MESA_VERBOSE & VERBOSE_API)
      fprintf(stderr, "glUnlockArrays\n");
d1833 22
a1854 4
   ctx->Array.LockFirst = 0;
   ctx->Array.LockCount = 0;
   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_ALL;
d1856 6
a1861 2
   if (ctx->Driver.UnlockArraysEXT)
      ctx->Driver.UnlockArraysEXT( ctx );
d1863 2
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d4 1
a4 1
 * Version:  4.1
d26 3
d42 1
d52 1
a52 1
   if (size < 2 || size > 4) {
d56 1
a56 1
   if (stride < 0) {
d62 7
a68 5
      _mesa_debug(ctx, "glVertexPointer( sz %d type %s stride %d )\n", size,
                  _mesa_lookup_enum_by_nr( type ), stride);

   /* always need to check that <type> is legal */
   switch (type) {
d70 1
a70 1
         ctx->Array.Vertex.StrideB = size * sizeof(GLshort);
d73 1
a73 1
         ctx->Array.Vertex.StrideB = size * sizeof(GLint);
d76 1
a76 1
         ctx->Array.Vertex.StrideB = size * sizeof(GLfloat);
d79 1
a79 1
         ctx->Array.Vertex.StrideB = size * sizeof(GLdouble);
d84 1
a85 4

   if (stride)
      ctx->Array.Vertex.StrideB = stride;

d106 1
a106 1
   if (stride < 0) {
d112 7
a118 4
      _mesa_debug(ctx, "glNormalPointer( type %s stride %d )\n",
                  _mesa_lookup_enum_by_nr( type ), stride);

   switch (type) {
d120 1
a120 1
         ctx->Array.Normal.StrideB = 3 * sizeof(GLbyte);
d123 1
a123 1
         ctx->Array.Normal.StrideB = 3 * sizeof(GLshort);
d126 1
a126 1
         ctx->Array.Normal.StrideB = 3 * sizeof(GLint);
d129 1
a129 1
         ctx->Array.Normal.StrideB = 3 * sizeof(GLfloat);
d132 1
a132 1
         ctx->Array.Normal.StrideB = 3 * sizeof(GLdouble);
d137 1
a138 4
   if (stride)
      ctx->Array.Normal.StrideB = stride;

   ctx->Array.Normal.Size = 3;
d157 1
a157 1
   if (size < 3 || size > 4) {
d167 7
a173 4
      _mesa_debug(ctx, "glColorPointer( sz %d type %s stride %d )\n", size,
                  _mesa_lookup_enum_by_nr( type ), stride);

   switch (type) {
d175 1
a175 1
         ctx->Array.Color.StrideB = size * sizeof(GLbyte);
d178 1
a178 1
         ctx->Array.Color.StrideB = size * sizeof(GLubyte);
d181 1
a181 1
         ctx->Array.Color.StrideB = size * sizeof(GLshort);
d184 1
a184 1
         ctx->Array.Color.StrideB = size * sizeof(GLushort);
d187 1
a187 1
         ctx->Array.Color.StrideB = size * sizeof(GLint);
d190 1
a190 1
         ctx->Array.Color.StrideB = size * sizeof(GLuint);
d193 1
a193 1
         ctx->Array.Color.StrideB = size * sizeof(GLfloat);
d196 1
a196 1
         ctx->Array.Color.StrideB = size * sizeof(GLdouble);
d201 1
a202 4

   if (stride)
      ctx->Array.Color.StrideB = stride;

d208 1
a208 1
   ctx->Array.NewState |= _NEW_ARRAY_COLOR0;
d222 1
a222 1
   if (stride < 0) {
d227 3
a229 1
   switch (type) {
d239 1
a240 5

   if (stride)
      ctx->Array.FogCoord.StrideB = stride;

   ctx->Array.FogCoord.Size = 1;
d258 1
a258 1
   if (stride < 0) {
d263 3
a265 1
   switch (type) {
d284 1
a285 5

   if (stride)
      ctx->Array.Index.StrideB = stride;

   ctx->Array.Index.Size = 1;
d305 1
a305 1
      _mesa_error( ctx, GL_INVALID_VALUE, "glSecondaryColorPointer(size)" );
d308 2
a309 2
   if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glSecondaryColorPointer(stride)" );
d314 7
a320 4
      _mesa_debug(ctx, "glSecondaryColorPointer( sz %d type %s stride %d )\n",
                  size, _mesa_lookup_enum_by_nr( type ), stride);

   switch (type) {
d322 1
a322 1
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLbyte);
d325 1
a325 1
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLubyte);
d328 1
a328 1
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLshort);
d331 1
a331 1
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLushort);
d334 1
a334 1
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLint);
d337 1
a337 1
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLuint);
d340 1
a340 1
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLfloat);
d343 1
a343 1
         ctx->Array.SecondaryColor.StrideB = size * sizeof(GLdouble);
d348 1
a349 4

   if (stride)
      ctx->Array.SecondaryColor.StrideB = stride;

d355 1
a355 1
   ctx->Array.NewState |= _NEW_ARRAY_COLOR1;
d364 1
a364 2
_mesa_TexCoordPointer(GLint size, GLenum type, GLsizei stride,
                      const GLvoid *ptr)
d370 1
a370 1
   if (size < 1 || size > 4) {
d374 1
a374 1
   if (stride < 0) {
d380 9
a388 5
      _mesa_debug(ctx, "glTexCoordPointer(unit %u sz %d type %s stride %d)\n",
                  texUnit, size, _mesa_lookup_enum_by_nr( type ), stride);

   /* always need to check that <type> is legal */
   switch (type) {
d390 1
a390 1
         ctx->Array.TexCoord[texUnit].StrideB = size * sizeof(GLshort);
d393 1
a393 1
         ctx->Array.TexCoord[texUnit].StrideB = size * sizeof(GLint);
d396 1
a396 1
         ctx->Array.TexCoord[texUnit].StrideB = size * sizeof(GLfloat);
d399 1
a399 1
         ctx->Array.TexCoord[texUnit].StrideB = size * sizeof(GLdouble);
d404 1
a405 4

   if (stride)
      ctx->Array.TexCoord[texUnit].StrideB = stride;

d413 2
d420 2
d423 1
a423 1
_mesa_EdgeFlagPointer(GLsizei stride, const GLvoid *vptr)
a443 5
void _mesa_VertexAttribPointerNV(GLuint index, GLint size, GLenum type,
                                 GLsizei stride, const GLvoid *ptr)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a444 53
   if (index >= VERT_ATTRIB_MAX) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerNV(index)");
      return;
   }

   if (size < 1 || size > 4) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerNV(size)");
      return;
   }

   if (stride < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerNV(stride)");
      return;
   }

   if (type == GL_UNSIGNED_BYTE && size != 4) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerNV(size!=4)");
      return;
   }

   /* check for valid 'type' and compute StrideB right away */
   switch (type) {
      case GL_UNSIGNED_BYTE:
         ctx->Array.VertexAttrib[index].StrideB = size * sizeof(GLubyte);
         break;
      case GL_SHORT:
         ctx->Array.VertexAttrib[index].StrideB = size * sizeof(GLshort);
         break;
      case GL_FLOAT:
         ctx->Array.VertexAttrib[index].StrideB = size * sizeof(GLfloat);
         break;
      case GL_DOUBLE:
         ctx->Array.VertexAttrib[index].StrideB = size * sizeof(GLdouble);
         break;
      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glVertexAttribPointerNV(type)" );
         return;
   }

   if (stride)
      ctx->Array.VertexAttrib[index].StrideB = stride;

   ctx->Array.VertexAttrib[index].Stride = stride;
   ctx->Array.VertexAttrib[index].Size = size;
   ctx->Array.VertexAttrib[index].Type = type;
   ctx->Array.VertexAttrib[index].Ptr = (void *) ptr;

   ctx->NewState |= _NEW_ARRAY;
   ctx->Array.NewState |= _NEW_ARRAY_ATTRIB(index);

   if (ctx->Driver.VertexAttribPointer)
      ctx->Driver.VertexAttribPointer( ctx, index, size, type, stride, ptr );
}
d502 2
d707 1
a707 1
      _mesa_debug(ctx, "glLockArrays %d %d\n", first, count);
d734 1
a734 1
      _mesa_debug(ctx, "glUnlockArrays\n");
a742 38
}



/* GL_EXT_multi_draw_arrays */
/* Somebody forgot to spec the first and count parameters as const! <sigh> */
void
_mesa_MultiDrawArraysEXT( GLenum mode, GLint *first,
                          GLsizei *count, GLsizei primcount )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   for (i = 0; i < primcount; i++) {
      if (count[i] > 0) {
         (ctx->Exec->DrawArrays)(mode, first[i], count[i]);
      }
   }
}


/* GL_EXT_multi_draw_arrays */
void
_mesa_MultiDrawElementsEXT( GLenum mode, const GLsizei *count, GLenum type,
                            const GLvoid **indices, GLsizei primcount )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);

   for (i = 0; i < primcount; i++) {
      if (count[i] > 0) {
         (ctx->Exec->DrawElements)(mode, count[i], type, indices[i]);
      }
   }
@


