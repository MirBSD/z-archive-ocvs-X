head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.28.22;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.01.02;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.01.02;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.20.05;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.29.09;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.04.50;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@
/*
 * Mesa 3-D graphics library
 * Version:  3.4
 *
 * Copyright (C) 1999-2000  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Gareth Hughes <gareth@@valinux.com>
 */

#ifdef PC_HEADER
#include "all.h"
#else
#include "glheader.h"
#include "context.h"
#include "enums.h"
#include "image.h"
#include "mem.h"
#include "texformat.h"
#include "texutil.h"
#include "types.h"
#endif

#define DEBUG_TEXUTIL 0


struct gl_texture_convert {
   GLint xoffset, yoffset, zoffset;	/* Subimage offset */
   GLint width, height, depth;		/* Subimage region */

   GLint imageWidth, imageHeight;	/* Full image dimensions */
   GLenum format, type;

   const struct gl_pixelstore_attrib *packing;

   const GLvoid *srcImage;
   GLvoid *dstImage;

   GLint index;
};

typedef GLboolean (*convert_func)( struct gl_texture_convert *convert );
typedef void (*unconvert_func)( struct gl_texture_convert *convert );

#define CONVERT_STRIDE_BIT	0x1
#define CONVERT_PACKING_BIT	0x2


/* ================================================================
 * RGBA8888 textures:
 */

#define DST_TYPE		GLuint
#define DST_TEXELS_PER_DWORD	1

#define CONVERT_TEXEL( src )						\
		PACK_COLOR_8888( src[3], src[2], src[1], src[0] )

#define CONVERT_DIRECT

#define SRC_TEXEL_BYTES		4

#define TAG(x) x##_rgba8888_direct
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( src )						\
		PACK_COLOR_8888( src[0], src[1], src[2], src[3] )

#define CONVERT_TEXEL_DWORD( src )	CONVERT_TEXEL( src )

#define SRC_TEXEL_BYTES		4

#define TAG(x) x##_abgr8888_to_rgba8888
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( src )						\
		PACK_COLOR_8888( src[0], src[1], src[2], 0xff )

#define CONVERT_TEXEL_DWORD( src )	CONVERT_TEXEL( src )

#define SRC_TEXEL_BYTES		3

#define TAG(x) x##_bgr888_to_rgba8888
#include "texutil_tmp.h"


#define CONVERT_RGBA8888( name )					\
static GLboolean							\
convert_##name##_rgba8888( struct gl_texture_convert *convert )		\
{									\
   convert_func *tab;							\
   GLint index = convert->index;					\
									\
   if ( convert->format == GL_ABGR_EXT &&				\
	convert->type == GL_UNSIGNED_INT_8_8_8_8_REV )			\
   {									\
      tab = name##_tab_rgba8888_direct;					\
   }									\
   else if ( convert->format == GL_RGBA &&				\
	     ( convert->type == GL_UNSIGNED_BYTE ||			\
	       convert->type == GL_UNSIGNED_INT_8_8_8_8 ) )		\
   {									\
      tab = name##_tab_abgr8888_to_rgba8888;				\
   }									\
   else if ( convert->format == GL_RGB &&				\
	     convert->type == GL_UNSIGNED_BYTE )			\
   {									\
      tab = name##_tab_bgr888_to_rgba8888;				\
   }									\
   else									\
   {									\
      /* Can't handle this source format/type combination */		\
      return GL_FALSE;							\
   }									\
									\
   return tab[index]( convert );					\
}

CONVERT_RGBA8888( texsubimage2d )
CONVERT_RGBA8888( texsubimage3d )


static void
unconvert_teximage_rgba8888( struct gl_texture_convert *convert )
{
   const GLubyte *src = (const GLubyte *)convert->srcImage;
   GLint texels, i;

   texels = convert->width * convert->height * convert->depth;

   switch ( convert->format ) {
   case GL_RGBA: {
      GLuint *dst = (GLuint *)convert->dstImage;
      for ( i = 0 ; i < texels ; i++ ) {
	 *dst++ = PACK_COLOR_8888( src[0], src[1], src[2], src[3] );
	 src += 4;
      }
      break;
   }
   case GL_RGB: {
      GLubyte *dst = (GLubyte *)convert->dstImage;
      for ( i = 0 ; i < texels ; i++ ) {
	 *dst++ = src[3];
	 *dst++ = src[2];
	 *dst++ = src[1];
	 src += 4;
      }
      break;
   }
   default:
      gl_problem(NULL, "texture unconvert error");
   }
}



/* ================================================================
 * ABGR8888 textures:
 */

#define DST_TYPE		GLuint
#define DST_TEXELS_PER_DWORD	1

#define CONVERT_TEXEL( src )						\
		PACK_COLOR_8888( src[3], src[2], src[1], src[0] )

#define CONVERT_DIRECT

#define SRC_TEXEL_BYTES		4

#define TAG(x) x##_abgr8888_direct
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( src )						\
		PACK_COLOR_8888( 0xff, src[2], src[1], src[0] )

#define CONVERT_TEXEL_DWORD( src )	CONVERT_TEXEL( src )

#define SRC_TEXEL_BYTES		3

#define TAG(x) x##_bgr888_to_abgr8888
#include "texutil_tmp.h"


#define CONVERT_ABGR8888( name )					\
static GLboolean							\
convert_##name##_abgr8888( struct gl_texture_convert *convert )		\
{									\
   convert_func *tab;							\
   GLint index = convert->index;					\
									\
   if ( convert->format == GL_RGBA &&					\
	convert->type == GL_UNSIGNED_BYTE )				\
   {									\
      tab = name##_tab_abgr8888_direct;					\
   }									\
   else if ( convert->format == GL_RGB &&				\
	     convert->type == GL_UNSIGNED_BYTE )			\
   {									\
      tab = name##_tab_bgr888_to_abgr8888;				\
   }									\
   else									\
   {									\
      /* Can't handle this source format/type combination */		\
      return GL_FALSE;							\
   }									\
									\
   return tab[index]( convert );					\
}

CONVERT_ABGR8888( texsubimage2d )
CONVERT_ABGR8888( texsubimage3d )


static void
unconvert_teximage_abgr8888( struct gl_texture_convert *convert )
{
   const GLubyte *src = (const GLubyte *)convert->srcImage;
   GLint texels, i;

   texels = convert->width * convert->height * convert->depth;

   switch ( convert->format ) {
   case GL_RGBA:
      MEMCPY( convert->dstImage, src, texels * 4 );
      break;
   case GL_RGB: {
      GLubyte *dst = (GLubyte *)convert->dstImage;
      for ( i = 0 ; i < texels ; i++ ) {
	 *dst++ = src[0];
	 *dst++ = src[1];
	 *dst++ = src[2];
	 src += 4;
      }
      break;
   }
   default:
      gl_problem(NULL, "texture unconvert error");
   }
}



/* ================================================================
 * ARGB8888 textures:
 */

#define DST_TYPE		GLuint
#define DST_TEXELS_PER_DWORD	1

#define CONVERT_TEXEL( src )						\
		PACK_COLOR_8888( src[3], src[2], src[1], src[0] )

#define CONVERT_DIRECT

#define SRC_TEXEL_BYTES		4

#define TAG(x) x##_argb8888_direct
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( src )						\
		PACK_COLOR_8888( src[3], src[0], src[1], src[2] )

#define CONVERT_TEXEL_DWORD( src )	CONVERT_TEXEL( src )

#define SRC_TEXEL_BYTES		4

#define TAG(x) x##_abgr8888_to_argb8888
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( src )						\
		PACK_COLOR_8888( 0xff, src[0], src[1], src[2] )

#define CONVERT_TEXEL_DWORD( src )	CONVERT_TEXEL( src )

#define SRC_TEXEL_BYTES		3

#define TAG(x) x##_bgr888_to_argb8888
#include "texutil_tmp.h"


#define CONVERT_ARGB8888( name )					\
static GLboolean							\
convert_##name##_argb8888( struct gl_texture_convert *convert )		\
{									\
   convert_func *tab;							\
   GLint index = convert->index;					\
									\
   if ( convert->format == GL_BGRA &&					\
	convert->type == GL_UNSIGNED_INT_8_8_8_8_REV )			\
   {									\
      tab = name##_tab_argb8888_direct;					\
   }									\
   else if ( convert->format == GL_RGBA &&				\
	     convert->type == GL_UNSIGNED_BYTE )			\
   {									\
      tab = name##_tab_abgr8888_to_argb8888;				\
   }									\
   else if ( convert->format == GL_RGB &&				\
	     convert->type == GL_UNSIGNED_BYTE )			\
   {									\
      tab = name##_tab_bgr888_to_argb8888;				\
   }									\
   else									\
   {									\
      /* Can't handle this source format/type combination */		\
      return GL_FALSE;							\
   }									\
									\
   return tab[index]( convert );					\
}

CONVERT_ARGB8888( texsubimage2d )
CONVERT_ARGB8888( texsubimage3d )


static void
unconvert_teximage_argb8888( struct gl_texture_convert *convert )
{
   const GLubyte *src = (const GLubyte *)convert->srcImage;
   GLint texels, i;

   texels = convert->width * convert->height * convert->depth;

   switch ( convert->format ) {
   case GL_RGBA: {
      GLuint *dst = (GLuint *)convert->dstImage;
      for ( i = 0 ; i < texels ; i++ ) {
	 *dst++ = PACK_COLOR_8888( src[3], src[0], src[1], src[2] );
	 src += 4;
      }
      break;
   }
   case GL_RGB: {
      GLubyte *dst = (GLubyte *)convert->dstImage;
      for ( i = 0 ; i < texels ; i++ ) {
	 *dst++ = src[2];
	 *dst++ = src[1];
	 *dst++ = src[0];
	 src += 4;
      }
      break;
   }
   default:
      gl_problem(NULL, "texture unconvert error");
   }
}



/* ================================================================
 * RGB888 textures:
 */

static GLboolean
convert_texsubimage2d_rgb888( struct gl_texture_convert *convert )
{
   /* This is a placeholder for now...
    */
   return GL_FALSE;
}

static GLboolean
convert_texsubimage3d_rgb888( struct gl_texture_convert *convert )
{
   /* This is a placeholder for now...
    */
   return GL_FALSE;
}


static void
unconvert_teximage_rgb888( struct gl_texture_convert *convert )
{
   gl_problem(NULL, "texture unconvert error");
}



/* ================================================================
 * BGR888 textures:
 */

static GLboolean
convert_texsubimage2d_bgr888( struct gl_texture_convert *convert )
{
   /* This is a placeholder for now...
    */
   return GL_FALSE;
}

static GLboolean
convert_texsubimage3d_bgr888( struct gl_texture_convert *convert )
{
   /* This is a placeholder for now...
    */
   return GL_FALSE;
}


static void
unconvert_teximage_bgr888( struct gl_texture_convert *convert )
{
   gl_problem(NULL, "texture unconvert error");
}



/* ================================================================
 * RGB565 textures:
 */

#define DST_TYPE		GLushort
#define DST_TEXELS_PER_DWORD	2

#define CONVERT_TEXEL( src )						\
		PACK_COLOR_565( src[0], src[1], src[2] )

#define CONVERT_DIRECT

#define SRC_TEXEL_BYTES		2

#define TAG(x) x##_rgb565_direct
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( src )						\
		PACK_COLOR_565( src[0], src[1], src[2] )

#define CONVERT_TEXEL_DWORD( src )					\
		((PACK_COLOR_565( src[0], src[1], src[2] )) |		\
		 (PACK_COLOR_565( src[3], src[4], src[5] ) << 16))

#define SRC_TEXEL_BYTES		3

#define TAG(x) x##_bgr888_to_rgb565
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( src )						\
		PACK_COLOR_565( src[0], src[1], src[2] )

#define CONVERT_TEXEL_DWORD( src )					\
		((PACK_COLOR_565( src[0], src[1], src[2] )) |		\
		 (PACK_COLOR_565( src[4], src[5], src[6] ) << 16))

#define SRC_TEXEL_BYTES		4

#define TAG(x) x##_abgr8888_to_rgb565
#include "texutil_tmp.h"


#define CONVERT_RGB565( name )						\
static GLboolean							\
convert_##name##_rgb565( struct gl_texture_convert *convert )		\
{									\
   convert_func *tab;							\
   GLint index = convert->index;					\
									\
   if ( convert->format == GL_RGB &&					\
	convert->type == GL_UNSIGNED_SHORT_5_6_5 )			\
   {									\
      tab = name##_tab_rgb565_direct;					\
   }									\
   else if ( convert->format == GL_RGB &&				\
	     convert->type == GL_UNSIGNED_BYTE )			\
   {									\
      tab = name##_tab_bgr888_to_rgb565;				\
   }									\
   else if ( convert->format == GL_RGBA &&				\
	     convert->type == GL_UNSIGNED_BYTE )			\
   {									\
      tab = name##_tab_abgr8888_to_rgb565;				\
   }									\
   else									\
   {									\
      /* Can't handle this source format/type combination */		\
      return GL_FALSE;							\
   }									\
									\
   return tab[index]( convert );					\
}

CONVERT_RGB565( texsubimage2d )
CONVERT_RGB565( texsubimage3d )


static void
unconvert_teximage_rgb565( struct gl_texture_convert *convert )
{
   const GLushort *src = (const GLushort *)convert->srcImage;
   GLubyte *dst = (GLubyte *)convert->dstImage;
   GLint texels, i;

   texels = convert->width * convert->height * convert->depth;

   switch ( convert->format ) {
   case GL_RGBA:
      for ( i = 0 ; i < texels ; i++ ) {
	 GLushort s = *src++;
	 *dst++ = ((s >> 8) & 0xf8) * 255 / 0xf8;
	 *dst++ = ((s >> 3) & 0xfc) * 255 / 0xfc;
	 *dst++ = ((s << 3) & 0xf8) * 255 / 0xf8;
	 *dst++ = 0xff;
      }
      break;
   case GL_RGB:
      for ( i = 0 ; i < texels ; i++ ) {
	 GLushort s = *src++;
	 *dst++ = ((s >> 8) & 0xf8) * 255 / 0xf8;
	 *dst++ = ((s >> 3) & 0xfc) * 255 / 0xfc;
	 *dst++ = ((s << 3) & 0xf8) * 255 / 0xf8;
      }
      break;
   default:
      gl_problem(NULL, "texture unconvert error");
   }
}



/* ================================================================
 * ARGB4444 textures:
 */

#define DST_TYPE		GLushort
#define DST_TEXELS_PER_DWORD	2

#define CONVERT_TEXEL( src )						\
		PACK_COLOR_4444( src[3], src[0], src[1], src[2] )

#define CONVERT_DIRECT

#define SRC_TEXEL_BYTES		2

#define TAG(x) x##_argb4444_direct
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( src )						\
		PACK_COLOR_4444( src[3], src[0], src[1], src[2] )

#define CONVERT_TEXEL_DWORD( src )					\
		((PACK_COLOR_4444( src[3], src[0], src[1], src[2] )) |	\
		 (PACK_COLOR_4444( src[7], src[4], src[5], src[6] ) << 16))

#define SRC_TEXEL_BYTES		4

#define TAG(x) x##_rgba8888_to_argb4444
#include "texutil_tmp.h"


#define CONVERT_ARGB4444( name )					\
static GLboolean							\
convert_##name##_argb4444( struct gl_texture_convert *convert )		\
{									\
   convert_func *tab;							\
   GLint index = convert->index;					\
									\
   if ( convert->format == GL_BGRA &&					\
	convert->type == GL_UNSIGNED_SHORT_4_4_4_4_REV )		\
   {									\
      tab = name##_tab_argb4444_direct;					\
   }									\
   else if ( convert->format == GL_RGBA &&				\
	     convert->type == GL_UNSIGNED_BYTE )			\
   {									\
      tab = name##_tab_rgba8888_to_argb4444;				\
   }									\
   else									\
   {									\
      /* Can't handle this source format/type combination */		\
      return GL_FALSE;							\
   }									\
									\
   return tab[index]( convert );					\
}

CONVERT_ARGB4444( texsubimage2d )
CONVERT_ARGB4444( texsubimage3d )


static void
unconvert_teximage_argb4444( struct gl_texture_convert *convert )
{
   const GLushort *src = (const GLushort *)convert->srcImage;
   GLubyte *dst = (GLubyte *)convert->dstImage;
   GLint texels, i;

   texels = convert->width * convert->height * convert->depth;

   switch ( convert->format ) {
   case GL_RGBA:
      for ( i = 0 ; i < texels ; i++ ) {
	 GLushort s = *src++;
	 *dst++ = ((s >>  8) & 0xf) * 255 / 0xf;
	 *dst++ = ((s >>  4) & 0xf) * 255 / 0xf;
	 *dst++ = ((s      ) & 0xf) * 255 / 0xf;
	 *dst++ = ((s >> 12) & 0xf) * 255 / 0xf;
      }
      break;
   default:
      gl_problem(NULL, "texture unconvert error");
   }
}



/* ================================================================
 * ARGB1555 textures:
 */

#define DST_TYPE		GLushort
#define DST_TEXELS_PER_DWORD	2

#define CONVERT_TEXEL( src )						\
		PACK_COLOR_1555( src[3], src[0], src[1], src[2] )

#define CONVERT_DIRECT

#define SRC_TEXEL_BYTES		2

#define TAG(x) x##_argb1555_direct
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( src )						\
		PACK_COLOR_1555( src[3], src[0], src[1], src[2] )

#define CONVERT_TEXEL_DWORD( src )					\
		((PACK_COLOR_1555( src[3], src[0], src[1], src[2] )) |	\
		 (PACK_COLOR_1555( src[7], src[4], src[5], src[6] ) << 16))

#define SRC_TEXEL_BYTES		4

#define TAG(x) x##_rgba8888_to_argb1555
#include "texutil_tmp.h"


#define CONVERT_ARGB1555( name )					\
static GLboolean							\
convert_##name##_argb1555( struct gl_texture_convert *convert )		\
{									\
   convert_func *tab;							\
   GLint index = convert->index;					\
									\
   if ( convert->format == GL_BGRA &&					\
	convert->type == GL_UNSIGNED_SHORT_1_5_5_5_REV )		\
   {									\
      tab = name##_tab_argb1555_direct;					\
   }									\
   else if ( convert->format == GL_RGBA &&				\
	     convert->type == GL_UNSIGNED_BYTE )			\
   {									\
      tab = name##_tab_rgba8888_to_argb1555;				\
   }									\
   else									\
   {									\
      /* Can't handle this source format/type combination */		\
      return GL_FALSE;							\
   }									\
									\
   return tab[index]( convert );					\
}

CONVERT_ARGB1555( texsubimage2d )
CONVERT_ARGB1555( texsubimage3d )


static void
unconvert_teximage_argb1555( struct gl_texture_convert *convert )
{
   const GLushort *src = (const GLushort *)convert->srcImage;
   GLubyte *dst = (GLubyte *)convert->dstImage;
   GLint texels, i;

   texels = convert->width * convert->height * convert->depth;

   switch ( convert->format ) {
   case GL_RGBA:
      for ( i = 0 ; i < texels ; i++ ) {
	 GLushort s = *src++;
	 *dst++ = ((s >> 10) & 0xf8) * 255 / 0xf8;
	 *dst++ = ((s >>  5) & 0xf8) * 255 / 0xf8;
	 *dst++ = ((s      ) & 0xf8) * 255 / 0xf8;
	 *dst++ = ((s >> 15) & 0x01) * 255;
      }
      break;
   default:
      gl_problem(NULL, "texture unconvert error");
   }
}



/* ================================================================
 * AL88 textures:
 */

#define DST_TYPE		GLushort
#define DST_TEXELS_PER_DWORD	2

#define CONVERT_TEXEL( src )						\
		PACK_COLOR_88( src[0], src[1] )

#define CONVERT_DIRECT

#define SRC_TEXEL_BYTES		2

#define TAG(x) x##_al88_direct
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( src )						\
		PACK_COLOR_88( src[0], 0x00 )

#define CONVERT_TEXEL_DWORD( src )					\
		((PACK_COLOR_88( src[0], 0x00 )) |			\
		 (PACK_COLOR_88( src[1], 0x00 ) << 16))

#define SRC_TEXEL_BYTES		1

#define TAG(x) x##_a8_to_al88
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( src )						\
		PACK_COLOR_88( 0xff, src[0] )

#define CONVERT_TEXEL_DWORD( src )					\
		((PACK_COLOR_88( 0xff, src[0] )) |			\
		 (PACK_COLOR_88( 0xff, src[1] ) << 16))

#define SRC_TEXEL_BYTES		1

#define TAG(x) x##_l8_to_al88
#include "texutil_tmp.h"


#define CONVERT_AL88( name )						\
static GLboolean							\
convert_##name##_al88( struct gl_texture_convert *convert )		\
{									\
   convert_func *tab;							\
   GLint index = convert->index;					\
									\
   if ( convert->format == GL_LUMINANCE_ALPHA &&			\
	convert->type == GL_UNSIGNED_BYTE )				\
   {									\
      tab = name##_tab_al88_direct;					\
   }									\
   else if ( convert->format == GL_ALPHA &&				\
	     convert->type == GL_UNSIGNED_BYTE )			\
   {									\
      tab = name##_tab_a8_to_al88;					\
   }									\
   else if ( convert->format == GL_LUMINANCE &&				\
	     convert->type == GL_UNSIGNED_BYTE )			\
   {									\
      tab = name##_tab_l8_to_al88;					\
   }									\
   else									\
   {									\
      /* Can't handle this source format/type combination */		\
      return GL_FALSE;							\
   }									\
									\
   return tab[index]( convert );					\
}

CONVERT_AL88( texsubimage2d )
CONVERT_AL88( texsubimage3d )


static void
unconvert_teximage_al88( struct gl_texture_convert *convert )
{
   const GLubyte *src = (const GLubyte *)convert->srcImage;
   GLint texels, i;

   texels = convert->width * convert->height * convert->depth;

   switch ( convert->format ) {
   case GL_LUMINANCE_ALPHA:
      MEMCPY( convert->dstImage, src, texels * 2 );
      break;
   case GL_ALPHA: {
      GLubyte *dst = (GLubyte *)convert->dstImage;
      for ( i = 0 ; i < texels ; i++ ) {
	 *dst++ = src[1];
	 src += 2;
      }
      break;
   }
   case GL_LUMINANCE: {
      GLubyte *dst = (GLubyte *)convert->dstImage;
      for ( i = 0 ; i < texels ; i++ ) {
	 *dst++ = src[0];
	 src += 2;
      }
      break;
   }
   default:
      gl_problem(NULL, "texture unconvert error");
   }
}



/* ================================================================
 * RGB332 textures:
 */

static GLboolean
convert_texsubimage2d_rgb332( struct gl_texture_convert *convert )
{
   /* This is a placeholder for now...
    */
   return GL_FALSE;
}

static GLboolean
convert_texsubimage3d_rgb332( struct gl_texture_convert *convert )
{
   /* This is a placeholder for now...
    */
   return GL_FALSE;
}


static void
unconvert_teximage_rgb332( struct gl_texture_convert *convert )
{
   gl_problem(NULL, "texture unconvert error");
}



/* ================================================================
 * CI8 (and all other single-byte texel) textures:
 */

#define DST_TYPE		GLubyte
#define DST_TEXELS_PER_DWORD	4

#define CONVERT_TEXEL( src )	src[0]

#define CONVERT_DIRECT

#define SRC_TEXEL_BYTES		1

#define TAG(x) x##_ci8_direct
#include "texutil_tmp.h"


#define CONVERT_CI8( name )						\
static GLboolean							\
convert_##name##_ci8( struct gl_texture_convert *convert )		\
{									\
   convert_func *tab;							\
   GLint index = convert->index;					\
									\
   if ( ( convert->format == GL_ALPHA ||				\
	  convert->format == GL_LUMINANCE ||				\
	  convert->format == GL_INTENSITY ||				\
	  convert->format == GL_COLOR_INDEX ) &&			\
	convert->type == GL_UNSIGNED_BYTE )				\
   {									\
      tab = name##_tab_ci8_direct;					\
   }									\
   else									\
   {									\
      /* Can't handle this source format/type combination */		\
      return GL_FALSE;							\
   }									\
									\
   return tab[index]( convert );					\
}

CONVERT_CI8( texsubimage2d )
CONVERT_CI8( texsubimage3d )


static void
unconvert_teximage_ci8( struct gl_texture_convert *convert )
{
   const GLubyte *src = (const GLubyte *)convert->srcImage;
   GLint texels;

   texels = convert->width * convert->height * convert->depth;

   switch ( convert->format ) {
   case GL_ALPHA:
   case GL_LUMINANCE:
   case GL_INTENSITY:
   case GL_COLOR_INDEX:
      MEMCPY( convert->dstImage, src, texels );
      break;
   default:
      gl_problem(NULL, "texture unconvert error");
   }
}



/* ================================================================
 * Global entry points
 */

static convert_func gl_convert_texsubimage2d_tab[] = {
   convert_texsubimage2d_rgba8888,
   convert_texsubimage2d_abgr8888,
   convert_texsubimage2d_argb8888,
   convert_texsubimage2d_rgb888,
   convert_texsubimage2d_bgr888,
   convert_texsubimage2d_rgb565,
   convert_texsubimage2d_argb4444,
   convert_texsubimage2d_argb1555,
   convert_texsubimage2d_al88,
   convert_texsubimage2d_rgb332,
   convert_texsubimage2d_ci8,		/* These are all the same... */
   convert_texsubimage2d_ci8,
   convert_texsubimage2d_ci8,
   convert_texsubimage2d_ci8,
};

static convert_func gl_convert_texsubimage3d_tab[] = {
   convert_texsubimage3d_rgba8888,
   convert_texsubimage3d_abgr8888,
   convert_texsubimage3d_argb8888,
   convert_texsubimage3d_rgb888,
   convert_texsubimage3d_bgr888,
   convert_texsubimage3d_rgb565,
   convert_texsubimage3d_argb4444,
   convert_texsubimage3d_argb1555,
   convert_texsubimage3d_al88,
   convert_texsubimage3d_rgb332,
   convert_texsubimage3d_ci8,		/* These are all the same... */
   convert_texsubimage3d_ci8,
   convert_texsubimage3d_ci8,
   convert_texsubimage3d_ci8,
};

static unconvert_func gl_unconvert_teximage_tab[] = {
   unconvert_teximage_rgba8888,
   unconvert_teximage_abgr8888,
   unconvert_teximage_argb8888,
   unconvert_teximage_rgb888,
   unconvert_teximage_bgr888,
   unconvert_teximage_rgb565,
   unconvert_teximage_argb4444,
   unconvert_teximage_argb1555,
   unconvert_teximage_al88,
   unconvert_teximage_rgb332,
   unconvert_teximage_ci8,		/* These are all the same... */
   unconvert_teximage_ci8,
   unconvert_teximage_ci8,
   unconvert_teximage_ci8,
};


/* See if we need to care about the pixel store attributes when we're
 * converting the texture image.  This should be stored as
 * packing->_SomeBoolean and updated when the values change, to avoid
 * testing every time...
 */
static INLINE GLboolean
convert_needs_packing( const struct gl_pixelstore_attrib *packing,
		       GLenum format, GLenum type )
{
   if ( ( packing->Alignment == 1 ||
	  ( packing->Alignment == 4 &&	/* Pick up the common Q3A case... */
	    format == GL_RGBA && type == GL_UNSIGNED_BYTE ) ) &&
	packing->RowLength == 0 &&
	packing->SkipPixels == 0 &&
	packing->SkipRows == 0 &&
	packing->ImageHeight == 0 &&
	packing->SkipImages == 0 &&
	packing->SwapBytes == GL_FALSE &&
	packing->LsbFirst == GL_FALSE ) {
      return GL_FALSE;
   } else {
      return GL_TRUE;
   }
}


GLboolean
_mesa_convert_texsubimage1d( GLint mesaFormat,
			     GLint xoffset,
			     GLint width,
			     GLenum format, GLenum type,
			     const struct gl_pixelstore_attrib *packing,
			     const GLvoid *srcImage, GLvoid *dstImage )
{
   struct gl_texture_convert convert;

   ASSERT( packing );
   ASSERT( srcImage );
   ASSERT( dstImage );

   ASSERT( mesaFormat >= MESA_FORMAT_RGBA8888 );
   ASSERT( mesaFormat <= MESA_FORMAT_CI8 );

   /* Make it easier to pass all the parameters around.
    */
   convert.xoffset = xoffset;
   convert.yoffset = 0;
   convert.width = width;
   convert.height = 1;
   convert.format = format;
   convert.type = type;
   convert.packing = packing;
   convert.srcImage = srcImage;
   convert.dstImage = dstImage;

   convert.index = 0;

   if ( convert_needs_packing( packing, format, type ) )
      convert.index |= CONVERT_PACKING_BIT;

   return gl_convert_texsubimage2d_tab[mesaFormat]( &convert );
}

GLboolean
_mesa_convert_texsubimage2d( GLint mesaFormat,
			     GLint xoffset, GLint yoffset,
			     GLint width, GLint height,
			     GLint imageWidth,
			     GLenum format, GLenum type,
			     const struct gl_pixelstore_attrib *packing,
			     const GLvoid *srcImage, GLvoid *dstImage )
{
   struct gl_texture_convert convert;

   ASSERT( packing );
   ASSERT( srcImage );
   ASSERT( dstImage );

   ASSERT( mesaFormat >= MESA_FORMAT_RGBA8888 );
   ASSERT( mesaFormat <= MESA_FORMAT_CI8 );

   /* Make it easier to pass all the parameters around.
    */
   convert.xoffset = xoffset;
   convert.yoffset = yoffset;
   convert.width = width;
   convert.height = height;
   convert.imageWidth = imageWidth;
   convert.format = format;
   convert.type = type;
   convert.packing = packing;
   convert.srcImage = srcImage;
   convert.dstImage = dstImage;

   convert.index = 0;

   if ( convert_needs_packing( packing, format, type ) )
      convert.index |= CONVERT_PACKING_BIT;

   if ( width != imageWidth )
      convert.index |= CONVERT_STRIDE_BIT;

   return gl_convert_texsubimage2d_tab[mesaFormat]( &convert );
}

GLboolean
_mesa_convert_texsubimage3d( GLint mesaFormat,
			     GLint xoffset, GLint yoffset, GLint zoffset,
			     GLint width, GLint height, GLint depth,
			     GLint imageWidth, GLint imageHeight,
			     GLenum format, GLenum type,
			     const struct gl_pixelstore_attrib *packing,
			     const GLvoid *srcImage, GLvoid *dstImage )
{
   struct gl_texture_convert convert;

   ASSERT( packing );
   ASSERT( srcImage );
   ASSERT( dstImage );

   ASSERT( mesaFormat >= MESA_FORMAT_RGBA8888 );
   ASSERT( mesaFormat <= MESA_FORMAT_CI8 );

   /* Make it easier to pass all the parameters around.
    */
   convert.xoffset = xoffset;
   convert.yoffset = yoffset;
   convert.zoffset = zoffset;
   convert.width = width;
   convert.height = height;
   convert.depth = depth;
   convert.imageWidth = imageWidth;
   convert.imageHeight = imageHeight;
   convert.format = format;
   convert.type = type;
   convert.packing = packing;
   convert.srcImage = srcImage;
   convert.dstImage = dstImage;

   convert.index = 0;

   if ( convert_needs_packing( packing, format, type ) )
      convert.index |= CONVERT_PACKING_BIT;

   if ( width != imageWidth || height != imageHeight )
      convert.index |= CONVERT_STRIDE_BIT;

   return gl_convert_texsubimage3d_tab[mesaFormat]( &convert );
}



void _mesa_unconvert_teximage1d( GLint mesaFormat, GLenum format, GLint width,
				 const GLvoid *srcImage, GLvoid *dstImage )
{
   struct gl_texture_convert convert;

   ASSERT( srcImage );
   ASSERT( dstImage );

   ASSERT( mesaFormat >= MESA_FORMAT_RGBA8888 );
   ASSERT( mesaFormat <= MESA_FORMAT_CI8 );

   /* Make it easier to pass all the parameters around.
    */
   convert.width = width;
   convert.height = 1;
   convert.depth = 1;
   convert.format = format;
   convert.srcImage = srcImage;
   convert.dstImage = dstImage;

   gl_unconvert_teximage_tab[mesaFormat]( &convert );
}

void _mesa_unconvert_teximage2d( GLint mesaFormat, GLenum format,
				 GLint width, GLint height,
				 const GLvoid *srcImage, GLvoid *dstImage )
{
   struct gl_texture_convert convert;

   ASSERT( srcImage );
   ASSERT( dstImage );

   ASSERT( mesaFormat >= MESA_FORMAT_RGBA8888 );
   ASSERT( mesaFormat <= MESA_FORMAT_CI8 );

   /* Make it easier to pass all the parameters around.
    */
   convert.width = width;
   convert.height = height;
   convert.depth = 1;
   convert.format = format;
   convert.srcImage = srcImage;
   convert.dstImage = dstImage;

   gl_unconvert_teximage_tab[mesaFormat]( &convert );
}

void _mesa_unconvert_teximage3d( GLint mesaFormat, GLenum format,
				 GLint width, GLint height, GLint depth,
				 const GLvoid *srcImage, GLvoid *dstImage )
{
   struct gl_texture_convert convert;

   ASSERT( srcImage );
   ASSERT( dstImage );

   ASSERT( mesaFormat >= MESA_FORMAT_RGBA8888 );
   ASSERT( mesaFormat <= MESA_FORMAT_CI8 );

   /* Make it easier to pass all the parameters around.
    */
   convert.width = width;
   convert.height = height;
   convert.depth = depth;
   convert.format = format;
   convert.srcImage = srcImage;
   convert.dstImage = dstImage;

   gl_unconvert_teximage_tab[mesaFormat]( &convert );
}



/* Nearest filtering only (for broken hardware that can't support
 * all aspect ratios).  This can be made a lot faster, but I don't
 * really care enough...
 */
void _mesa_rescale_teximage2d( GLint texelBytes,
			       GLint srcWidth, GLint srcHeight,
			       GLint dstWidth, GLint dstHeight,
			       const GLvoid *srcImage, GLvoid *dstImage )
{
   GLint row, col;

#define INNER_LOOP( HOP, WOP )						\
   for ( row = 0 ; row < dstHeight ; row++ ) {				\
      GLint srcRow = row HOP hScale;					\
      for ( col = 0 ; col < dstWidth ; col++ ) {			\
	 GLint srcCol = col WOP wScale;					\
	 *dst++ = src[srcRow * srcWidth + srcCol];			\
      }									\
   }									\

#define RESCALE_IMAGE( TYPE )						\
do {									\
   const TYPE *src = (const TYPE *)srcImage;				\
   TYPE *dst = (TYPE *)dstImage;					\
									\
   if ( srcHeight <= dstHeight ) {					\
      const GLint hScale = dstHeight / srcHeight;			\
      if ( srcWidth <= dstWidth ) {					\
	 const GLint wScale = dstWidth / srcWidth;			\
	 INNER_LOOP( /, / );						\
      }									\
      else {								\
	 const GLint wScale = srcWidth / dstWidth;			\
	 INNER_LOOP( /, * );						\
      }									\
   }									\
   else {								\
      const GLint hScale = srcHeight / dstHeight;			\
      if ( srcWidth <= dstWidth ) {					\
	 const GLint wScale = dstWidth / srcWidth;			\
	 INNER_LOOP( *, / );						\
      }									\
      else {								\
	 const GLint wScale = srcWidth / dstWidth;			\
	 INNER_LOOP( *, * );						\
      }									\
   }									\
} while (0)

   switch ( texelBytes ) {
   case 4:
      RESCALE_IMAGE( GLuint );
      break;

   case 2:
      RESCALE_IMAGE( GLushort );
      break;

   case 1:
      RESCALE_IMAGE( GLubyte );
      break;
   }
}
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d4 1
a4 1
 * Version:  4.1
d6 1
a6 1
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
d26 1
a26 1
 *    Gareth Hughes
d29 3
a31 8
/*
 * Description:
 * Functions for texture image conversion.  This takes care of converting
 * typical GL_RGBA/GLubyte textures into hardware-specific formats.
 * We can handle non-standard row strides and pixel unpacking parameters.
 */


d36 1
a36 3
#include "imports.h"
#include "macros.h"
#include "mtypes.h"
d39 2
a40 1

d45 1
a45 8
#ifdef MESA_BIG_ENDIAN
#define APPEND16( a, b )	( (a) << 16 | (b) )
#else
#define APPEND16( a, b )	( (a) | (b) << 16 )
#endif


struct convert_info {
d49 2
a50 3
   GLint dstImageWidth, dstImageHeight;	/* Dest image size */
                                        /* Needed for subimage replacement */
   GLenum format, type;                 /* Source (user) format and type */
d52 1
a52 1
   const struct gl_pixelstore_attrib *unpacking;
d60 2
a61 1
typedef GLboolean (*convert_func)( const struct convert_info *convert );
a62 1
/* bitvalues for convert->index */
d64 1
a64 1
#define CONVERT_UNPACKING_BIT	0x2
d67 2
a68 3

/* =============================================================
 * Convert to RGBA8888 textures:
d74 2
a75 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_8888_LE( src[3], src[2], src[1], src[0] )
d86 2
a87 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_8888_LE( src[0], src[1], src[2], src[3] )
d89 1
a89 1
#define CONVERT_TEXEL_DWORD( dst, src )		CONVERT_TEXEL( dst, src )
d98 2
a99 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_8888_LE( src[0], src[1], src[2], 0xff )
d101 1
a101 1
#define CONVERT_TEXEL_DWORD( dst, src )		CONVERT_TEXEL( dst, src )
d111 1
a111 1
convert_##name##_rgba8888( const struct convert_info *convert )		\
d145 122
d268 2
a269 2
/* =============================================================
 * Convert to ARGB8888 textures:
d275 2
a276 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_8888_LE( src[3], src[2], src[1], src[0] )
d287 2
a288 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_8888_LE( src[3], src[0], src[1], src[2] )
d290 1
a290 1
#define CONVERT_TEXEL_DWORD( dst, src )		CONVERT_TEXEL( dst, src )
d299 2
a300 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_8888_LE( 0xff, src[0], src[1], src[2] )
d302 1
a302 1
#define CONVERT_TEXEL_DWORD( dst, src )		CONVERT_TEXEL( dst, src )
d312 1
a312 1
convert_##name##_argb8888( const struct convert_info *convert )		\
d345 7
d353 28
a380 2
/* =============================================================
 * Convert to RGB888 textures:
d384 1
a384 1
convert_texsubimage2d_rgb888( const struct convert_info *convert )
d392 1
a392 1
convert_texsubimage3d_rgb888( const struct convert_info *convert )
d400 7
d408 31
a438 2
/* =============================================================
 * Convert to RGB565 textures:
d444 2
a445 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_565_LE( src[0], src[1], src[2] )
d456 2
a457 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_565_LE( src[0], src[1], src[2] )
d459 3
a461 3
#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_565_LE( src[0], src[1], src[2] ),	\
			PACK_COLOR_565_LE( src[3], src[4], src[5] ) )
d470 2
a471 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_565_LE( src[0], src[1], src[2] )
d473 3
a475 3
#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_565_LE( src[0], src[1], src[2] ),	\
			PACK_COLOR_565_LE( src[4], src[5], src[6] ) )
d485 1
a485 1
convert_##name##_rgb565( const struct convert_info *convert )		\
d518 31
d550 4
a553 2
/* =============================================================
 * Convert to ARGB4444 textures:
d559 2
a560 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_4444_LE( src[3], src[0], src[1], src[2] )
d571 2
a572 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_4444_LE( src[3], src[0], src[1], src[2] )
d574 3
a576 3
#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_4444_LE( src[3], src[0], src[1], src[2] ),	\
			PACK_COLOR_4444_LE( src[7], src[4], src[5], src[6] ) )
d580 1
a580 1
#define TAG(x) x##_abgr8888_to_argb4444
d586 1
a586 1
convert_##name##_argb4444( const struct convert_info *convert )		\
d599 1
a599 1
      tab = name##_tab_abgr8888_to_argb4444;				\
d614 25
d640 2
a641 2
/* =============================================================
 * Convert to ARGB1555 textures:
d647 2
a648 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_1555_LE( src[3], src[0], src[1], src[2] )
d659 2
a660 1
#ifdef MESA_BIG_ENDIAN
d662 3
a664 35
#define CONVERT_TEXEL( dst, src )					\
	{ const GLushort s = *(GLushort *)src;				\
	  dst = (s >> 9) | ((s & 0x1ff) << 7); }

#define CONVERT_TEXEL_DWORD( dst, src )					\
	{ const GLuint s = ((fi_type *)src)->i;				\
	  dst = (((s & 0xfe00fe00) >> 9) |				\
		 ((s & 0x01ff01ff) << 7)); }

#else

#define CONVERT_TEXEL( dst, src )					\
	{ const GLushort s = *(GLushort *)src;				\
	  dst = (s >> 1) | ((s & 1) << 15); }

#define CONVERT_TEXEL_DWORD( dst, src )					\
	{ const GLuint s = ((fi_type *)src)->i;				\
	  dst = (((s & 0xfffefffe) >> 1) |				\
		 ((s & 0x00010001) << 15)); }

#endif

#define SRC_TEXEL_BYTES		2

#define TAG(x) x##_rgba5551_to_argb1555
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_1555_LE( src[3], src[0], src[1], src[2] )

#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_1555_LE( src[3], src[0], src[1], src[2] ),	\
			PACK_COLOR_1555_LE( src[7], src[4], src[5], src[6] ) )
d668 1
a668 1
#define TAG(x) x##_abgr8888_to_argb1555
d674 1
a674 1
convert_##name##_argb1555( const struct convert_info *convert )		\
a684 5
	     convert->type == GL_UNSIGNED_SHORT_5_5_5_1 )		\
   {									\
      tab = name##_tab_rgba5551_to_argb1555;				\
   }									\
   else if ( convert->format == GL_RGBA &&				\
d687 1
a687 1
      tab = name##_tab_abgr8888_to_argb1555;				\
d702 25
d728 1
a728 1
/* =============================================================
d735 2
a736 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_88_LE( src[0], src[1] )
d747 2
a748 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_88_LE( src[0], 0x00 )
d750 3
a752 3
#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_88_LE( src[0], 0x00 ),			\
			PACK_COLOR_88_LE( src[1], 0x00 ) )
d761 2
a762 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_88_LE( 0xff, src[0] )
d764 3
a766 3
#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_88_LE( 0xff, src[0] ),			\
			PACK_COLOR_88_LE( 0xff, src[1] ) )
a770 14
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_88_LE( src[3], src[0] )

#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_88_LE( src[3], src[0] ),		\
			PACK_COLOR_88_LE( src[7], src[4] ) )

#define SRC_TEXEL_BYTES		4

#define TAG(x) x##_abgr8888_to_al88
d776 1
a776 1
convert_##name##_al88( const struct convert_info *convert )		\
a795 5
   else if ( convert->format == GL_RGBA &&				\
	     convert->type == GL_UNSIGNED_BYTE )			\
   {									\
      tab = name##_tab_abgr8888_to_al88;				\
   }									\
d809 33
d843 3
a845 2
/* =============================================================
 * Convert to RGB332 textures:
d849 1
a849 1
convert_texsubimage2d_rgb332( const struct convert_info *convert )
d857 1
a857 1
convert_texsubimage3d_rgb332( const struct convert_info *convert )
d865 7
d873 1
a873 1
/* =============================================================
d880 1
a880 1
#define CONVERT_TEXEL( dst, src )	dst = src[0]
d892 1
a892 1
convert_##name##_ci8( const struct convert_info *convert )		\
d918 5
a922 3
/* =============================================================
 * convert to YCBCR textures:
 */
d924 1
a924 2
#define DST_TYPE		GLushort
#define DST_TEXELS_PER_DWORD	2
d926 10
a935 63
#define CONVERT_TEXEL( dst, src ) \
   dst = (src[0] << 8) | src[1];

#define CONVERT_DIRECT

#define SRC_TEXEL_BYTES		2

#define TAG(x) x##_ycbcr_direct
#include "texutil_tmp.h"


#define CONVERT_YCBCR( name )						\
static GLboolean							\
convert_##name##_ycbcr( const struct convert_info *convert )		\
{									\
   convert_func *tab;							\
   GLint index = convert->index;					\
									\
   if (convert->format != GL_YCBCR_MESA) {				\
      /* Can't handle this source format/type combination */		\
      return GL_FALSE;							\
   }      								\
   tab = name##_tab_ycbcr_direct;					\
									\
   return tab[index]( convert );					\
}

CONVERT_YCBCR( texsubimage2d )
CONVERT_YCBCR( texsubimage3d )


/* =============================================================
 * convert to YCBCR_REV textures:
 */

#define DST_TYPE		GLushort
#define DST_TEXELS_PER_DWORD	2

#define CONVERT_TEXEL( dst, src ) \
   dst = (src[1] << 8) | src[0];

#define CONVERT_DIRECT

#define SRC_TEXEL_BYTES		2

#define TAG(x) x##_ycbcr_rev_direct
#include "texutil_tmp.h"


#define CONVERT_YCBCR_REV( name )					\
static GLboolean							\
convert_##name##_ycbcr_rev( const struct convert_info *convert )	\
{									\
   convert_func *tab;							\
   GLint index = convert->index;					\
									\
   if (convert->format != GL_YCBCR_MESA) {				\
      /* Can't handle this source format/type combination */		\
      return GL_FALSE;							\
   }      								\
   tab = name##_tab_ycbcr_rev_direct;					\
									\
   return tab[index]( convert );					\
a937 3
CONVERT_YCBCR_REV( texsubimage2d )
CONVERT_YCBCR_REV( texsubimage3d )

d940 1
a940 1
/* =============================================================
d944 1
a944 1
static convert_func convert_texsubimage2d_tab[] = {
d946 1
d949 1
a958 2
   convert_texsubimage2d_ycbcr,
   convert_texsubimage2d_ycbcr_rev,
d961 1
a961 1
static convert_func convert_texsubimage3d_tab[] = {
d963 1
d966 1
d976 17
a992 2
   convert_texsubimage3d_ycbcr,
   convert_texsubimage3d_ycbcr_rev,
d998 1
a998 1
 * unpacking->_SomeBoolean and updated when the values change, to avoid
d1002 1
a1002 1
convert_needs_unpacking( const struct gl_pixelstore_attrib *unpacking,
d1005 2
a1006 2
   if ( ( unpacking->Alignment == 1 ||
	  ( unpacking->Alignment == 4 &&   /* Pick up the common Q3A case... */
d1008 7
a1014 7
	unpacking->RowLength == 0 &&
	unpacking->SkipPixels == 0 &&
	unpacking->SkipRows == 0 &&
	unpacking->ImageHeight == 0 &&
	unpacking->SkipImages == 0 &&
	unpacking->SwapBytes == GL_FALSE &&
	unpacking->LsbFirst == GL_FALSE ) {
d1027 1
a1027 1
			     const struct gl_pixelstore_attrib *unpacking,
d1030 1
a1030 1
   struct convert_info convert;
d1032 1
a1032 1
   ASSERT( unpacking );
d1037 1
a1037 1
   ASSERT( mesaFormat <= MESA_FORMAT_YCBCR_REV );
d1047 1
a1047 1
   convert.unpacking = unpacking;
d1053 2
a1054 4
   if ( convert_needs_unpacking( unpacking, format, type ) )
      convert.index |= CONVERT_UNPACKING_BIT;

   ASSERT(convert.index < 4);
d1056 1
a1056 1
   return convert_texsubimage2d_tab[mesaFormat]( &convert );
a1058 26

/* Convert a user's 2D image into a texture image.  This basically
 * repacks pixel data into the special texture formats used by core Mesa
 * and the DRI drivers.  This function can do full images or subimages.
 *
 * We return a boolean because this function may not accept some kinds
 * of source image formats and/or types.  For example, if the incoming
 * format/type = GL_BGR, GL_UNSIGNED_INT this function probably won't
 * be able to do the conversion.
 *
 * In that case, the incoming image should first be simplified to one of
 * the "canonical" formats (GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA,
 * GL_INTENSITY, GL_RGB, GL_RGBA) and types (GL_CHAN).  We can do that
 * with the _mesa_transfer_teximage() function.  That function will also
 * do image transfer operations such as scale/bias and convolution.
 *
 * Input:
 *   mesaFormat - one of the MESA_FORMAT_* values from texformat.h
 *   xoffset, yoffset - position in dest image to put data
 *   width, height - incoming image size, also size of dest region.
 *   dstImageWidth - width (row stride) of dest image in pixels
 *   format, type - incoming image format and type
 *   unpacking - describes incoming image unpacking
 *   srcImage - pointer to source image
 *   destImage - pointer to dest image
 */
d1060 1
a1060 1
_mesa_convert_texsubimage2d( GLint mesaFormat,  /* dest */
d1063 3
a1065 3
			     GLint destImageWidth,
			     GLenum format, GLenum type,  /* source */
			     const struct gl_pixelstore_attrib *unpacking,
d1068 1
a1068 1
   struct convert_info convert;
d1070 1
a1070 1
   ASSERT( unpacking );
d1075 1
a1075 1
   ASSERT( mesaFormat <= MESA_FORMAT_YCBCR_REV );
d1083 1
a1083 1
   convert.dstImageWidth = destImageWidth;
d1086 1
a1086 1
   convert.unpacking = unpacking;
d1092 2
a1093 2
   if ( convert_needs_unpacking( unpacking, format, type ) )
      convert.index |= CONVERT_UNPACKING_BIT;
d1095 1
a1095 1
   if ( width != destImageWidth )
d1098 1
a1098 1
   return convert_texsubimage2d_tab[mesaFormat]( &convert );
d1102 1
a1102 1
_mesa_convert_texsubimage3d( GLint mesaFormat,  /* dest */
d1105 3
a1107 3
			     GLint dstImageWidth, GLint dstImageHeight,
			     GLenum format, GLenum type,  /* source */
			     const struct gl_pixelstore_attrib *unpacking,
d1110 1
a1110 1
   struct convert_info convert;
d1112 1
a1112 1
   ASSERT( unpacking );
d1117 1
a1117 1
   ASSERT( mesaFormat <= MESA_FORMAT_YCBCR_REV );
d1127 2
a1128 2
   convert.dstImageWidth = dstImageWidth;
   convert.dstImageHeight = dstImageHeight;
d1131 1
a1131 1
   convert.unpacking = unpacking;
d1137 2
a1138 2
   if ( convert_needs_unpacking( unpacking, format, type ) )
      convert.index |= CONVERT_UNPACKING_BIT;
d1140 1
a1140 1
   if ( width != dstImageWidth || height != dstImageHeight )
d1143 74
a1216 1
   return convert_texsubimage3d_tab[mesaFormat]( &convert );
d1225 1
a1225 1
void _mesa_rescale_teximage2d( GLuint bytesPerPixel, GLuint dstRowStride,
d1232 1
a1232 1
#define INNER_LOOP( TYPE, HOP, WOP )					\
d1237 1
a1237 1
	 dst[col] = src[srcRow * srcWidth + srcCol];			\
a1238 1
      dst = (TYPE *) ((GLubyte *) dst + dstRowStride);			\
d1250 1
a1250 1
	 INNER_LOOP( TYPE, /, / );					\
d1254 1
a1254 1
	 INNER_LOOP( TYPE, /, * );					\
d1261 1
a1261 1
	 INNER_LOOP( TYPE, *, / );					\
d1265 1
a1265 1
	 INNER_LOOP( TYPE, *, * );					\
d1270 1
a1270 1
   switch ( bytesPerPixel ) {
a1281 2
   default:
      _mesa_problem(NULL,"unexpected bytes/pixel in _mesa_rescale_teximage2d");
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d4 1
a4 1
 * Version:  4.0.3
d6 1
a6 1
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
a28 8
/*
 * Description:
 * Functions for texture image conversion.  This takes care of converting
 * typical GL_RGBA/GLubyte textures into hardware-specific formats.
 * We can handle non-standard row strides and pixel unpacking parameters.
 */


a35 1
#include "macros.h"
a36 1
#include "mtypes.h"
d39 1
d45 1
a45 8
#ifdef MESA_BIG_ENDIAN
#define APPEND16( a, b )	( (a) << 16 | (b) )
#else
#define APPEND16( a, b )	( (a) | (b) << 16 )
#endif


struct convert_info {
d49 2
a50 3
   GLint dstImageWidth, dstImageHeight;	/* Dest image size */
                                        /* Needed for subimage replacement */
   GLenum format, type;                 /* Source (user) format and type */
d52 1
a52 1
   const struct gl_pixelstore_attrib *unpacking;
d60 2
a61 1
typedef GLboolean (*convert_func)( const struct convert_info *convert );
a62 1
/* bitvalues for convert->index */
d64 1
a64 2
#define CONVERT_UNPACKING_BIT	0x2

d67 2
a68 2
/* =============================================================
 * Convert to RGBA8888 textures:
d74 2
a75 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_8888_LE( src[3], src[2], src[1], src[0] )
d86 2
a87 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_8888_LE( src[0], src[1], src[2], src[3] )
d89 1
a89 1
#define CONVERT_TEXEL_DWORD( dst, src )		CONVERT_TEXEL( dst, src )
d98 2
a99 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_8888_LE( src[0], src[1], src[2], 0xff )
d101 1
a101 1
#define CONVERT_TEXEL_DWORD( dst, src )		CONVERT_TEXEL( dst, src )
d111 1
a111 1
convert_##name##_rgba8888( const struct convert_info *convert )		\
d145 33
d179 2
a180 2
/* =============================================================
 * Convert to ARGB8888 textures:
d186 91
a276 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_8888_LE( src[3], src[2], src[1], src[0] )
d287 2
a288 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_8888_LE( src[3], src[0], src[1], src[2] )
d290 1
a290 1
#define CONVERT_TEXEL_DWORD( dst, src )		CONVERT_TEXEL( dst, src )
d299 2
a300 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_8888_LE( 0xff, src[0], src[1], src[2] )
d302 1
a302 1
#define CONVERT_TEXEL_DWORD( dst, src )		CONVERT_TEXEL( dst, src )
d312 1
a312 1
convert_##name##_argb8888( const struct convert_info *convert )		\
d345 7
d353 28
a380 2
/* =============================================================
 * Convert to RGB888 textures:
d384 1
a384 1
convert_texsubimage2d_rgb888( const struct convert_info *convert )
d392 1
a392 1
convert_texsubimage3d_rgb888( const struct convert_info *convert )
d400 36
d437 2
a438 2
/* =============================================================
 * Convert to RGB565 textures:
d444 2
a445 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_565_LE( src[0], src[1], src[2] )
d456 2
a457 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_565_LE( src[0], src[1], src[2] )
d459 3
a461 3
#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_565_LE( src[0], src[1], src[2] ),	\
			PACK_COLOR_565_LE( src[3], src[4], src[5] ) )
d470 2
a471 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_565_LE( src[0], src[1], src[2] )
d473 3
a475 3
#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_565_LE( src[0], src[1], src[2] ),	\
			PACK_COLOR_565_LE( src[4], src[5], src[6] ) )
d485 1
a485 1
convert_##name##_rgb565( const struct convert_info *convert )		\
d518 33
d552 2
a553 2
/* =============================================================
 * Convert to ARGB4444 textures:
d559 2
a560 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_4444_LE( src[3], src[0], src[1], src[2] )
d571 2
a572 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_4444_LE( src[3], src[0], src[1], src[2] )
d574 3
a576 3
#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_4444_LE( src[3], src[0], src[1], src[2] ),	\
			PACK_COLOR_4444_LE( src[7], src[4], src[5], src[6] ) )
d580 1
a580 1
#define TAG(x) x##_abgr8888_to_argb4444
d586 1
a586 1
convert_##name##_argb4444( const struct convert_info *convert )		\
d599 1
a599 1
      tab = name##_tab_abgr8888_to_argb4444;				\
d614 23
d638 4
a641 2
/* =============================================================
 * Convert to ARGB1555 textures:
d647 2
a648 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_1555_LE( src[3], src[0], src[1], src[2] )
d659 2
a660 1
#ifdef MESA_BIG_ENDIAN
d662 3
a664 35
#define CONVERT_TEXEL( dst, src )					\
	{ const GLushort s = *(GLushort *)src;				\
	  dst = (s >> 9) | ((s & 0x1ff) << 7); }

#define CONVERT_TEXEL_DWORD( dst, src )					\
	{ const GLuint s = ((fi_type *)src)->i;				\
	  dst = (((s & 0xfe00fe00) >> 9) |				\
		 ((s & 0x01ff01ff) << 7)); }

#else

#define CONVERT_TEXEL( dst, src )					\
	{ const GLushort s = *(GLushort *)src;				\
	  dst = (s >> 1) | ((s & 1) << 15); }

#define CONVERT_TEXEL_DWORD( dst, src )					\
	{ const GLuint s = ((fi_type *)src)->i;				\
	  dst = (((s & 0xfffefffe) >> 1) |				\
		 ((s & 0x00010001) << 15)); }

#endif

#define SRC_TEXEL_BYTES		2

#define TAG(x) x##_rgba5551_to_argb1555
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_1555_LE( src[3], src[0], src[1], src[2] )

#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_1555_LE( src[3], src[0], src[1], src[2] ),	\
			PACK_COLOR_1555_LE( src[7], src[4], src[5], src[6] ) )
d668 1
a668 1
#define TAG(x) x##_abgr8888_to_argb1555
d674 1
a674 1
convert_##name##_argb1555( const struct convert_info *convert )		\
a684 5
	     convert->type == GL_UNSIGNED_SHORT_5_5_5_1 )		\
   {									\
      tab = name##_tab_rgba5551_to_argb1555;				\
   }									\
   else if ( convert->format == GL_RGBA &&				\
d687 1
a687 1
      tab = name##_tab_abgr8888_to_argb1555;				\
d702 25
d728 2
a729 2
/* =============================================================
 * Conver to AL88 textures:
d735 2
a736 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_88_LE( src[0], src[1] )
d747 2
a748 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_88_LE( src[0], 0x00 )
d750 3
a752 3
#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_88_LE( src[0], 0x00 ),		\
			PACK_COLOR_88_LE( src[1], 0x00 ) )
d761 2
a762 2
#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_88_LE( 0xff, src[0] )
d764 3
a766 3
#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_88_LE( 0xff, src[0] ),			\
			PACK_COLOR_88_LE( 0xff, src[1] ) )
a770 14
#define PRESERVE_DST_TYPE
#include "texutil_tmp.h"


#define CONVERT_TEXEL( dst, src )					\
	dst = PACK_COLOR_88_LE( src[3], src[0] )

#define CONVERT_TEXEL_DWORD( dst, src )					\
	dst = APPEND16( PACK_COLOR_88_LE( src[3], src[0] ),		\
			PACK_COLOR_88_LE( src[7], src[4] ) )

#define SRC_TEXEL_BYTES		4

#define TAG(x) x##_abgr8888_to_al88
d776 1
a776 1
convert_##name##_al88( const struct convert_info *convert )		\
a795 5
   else if ( convert->format == GL_RGBA &&				\
	     convert->type == GL_UNSIGNED_BYTE )			\
   {									\
      tab = name##_tab_abgr8888_to_al88;				\
   }									\
d809 33
d843 3
a845 2
/* =============================================================
 * Convert to RGB332 textures:
d849 1
a849 1
convert_texsubimage2d_rgb332( const struct convert_info *convert )
d857 1
a857 1
convert_texsubimage3d_rgb332( const struct convert_info *convert )
d865 7
d873 2
a874 2
/* =============================================================
 * Convert to CI8 (and all other single-byte texel) textures:
d880 1
a880 1
#define CONVERT_TEXEL( dst, src )	dst = src[0]
d892 1
a892 1
convert_##name##_ci8( const struct convert_info *convert )		\
d918 5
a922 3
/* =============================================================
 * convert to YCBCR textures:
 */
d924 1
a924 2
#define DST_TYPE		GLushort
#define DST_TEXELS_PER_DWORD	2
d926 10
a935 25
#define CONVERT_TEXEL( dst, src ) \
   dst = (src[0] << 8) | src[1];

#define CONVERT_DIRECT

#define SRC_TEXEL_BYTES		2

#define TAG(x) x##_ycbcr_direct
#include "texutil_tmp.h"


#define CONVERT_YCBCR( name )						\
static GLboolean							\
convert_##name##_ycbcr( const struct convert_info *convert )		\
{									\
   convert_func *tab;							\
   GLint index = convert->index;					\
									\
   if (convert->format != GL_YCBCR_MESA) {				\
      /* Can't handle this source format/type combination */		\
      return GL_FALSE;							\
   }      								\
   tab = name##_tab_ycbcr_direct;					\
									\
   return tab[index]( convert );					\
a937 2
CONVERT_YCBCR( texsubimage2d )
CONVERT_YCBCR( texsubimage3d )
d940 2
a941 2
/* =============================================================
 * convert to YCBCR_REV textures:
d944 1
a944 40
#define DST_TYPE		GLushort
#define DST_TEXELS_PER_DWORD	2

#define CONVERT_TEXEL( dst, src ) \
   dst = (src[1] << 8) | src[0];

#define CONVERT_DIRECT

#define SRC_TEXEL_BYTES		2

#define TAG(x) x##_ycbcr_rev_direct
#include "texutil_tmp.h"


#define CONVERT_YCBCR_REV( name )					\
static GLboolean							\
convert_##name##_ycbcr_rev( const struct convert_info *convert )	\
{									\
   convert_func *tab;							\
   GLint index = convert->index;					\
									\
   if (convert->format != GL_YCBCR_MESA) {				\
      /* Can't handle this source format/type combination */		\
      return GL_FALSE;							\
   }      								\
   tab = name##_tab_ycbcr_rev_direct;					\
									\
   return tab[index]( convert );					\
}

CONVERT_YCBCR_REV( texsubimage2d )
CONVERT_YCBCR_REV( texsubimage3d )



/* =============================================================
 * Tables of texture conversion/packing functions.
 */

static convert_func convert_texsubimage2d_table[] = {
d946 1
d949 1
a958 2
   convert_texsubimage2d_ycbcr,
   convert_texsubimage2d_ycbcr_rev,
d961 1
a961 1
static convert_func convert_texsubimage3d_table[] = {
d963 1
d966 1
d976 17
a992 2
   convert_texsubimage3d_ycbcr,
   convert_texsubimage3d_ycbcr_rev,
d998 1
a998 1
 * unpacking->_SomeBoolean and updated when the values change, to avoid
d1002 1
a1002 1
convert_needs_unpacking( const struct gl_pixelstore_attrib *unpacking,
d1005 2
a1006 2
   if ( ( unpacking->Alignment == 1 ||
	  ( unpacking->Alignment == 4 &&   /* Pick up the common Q3A case... */
d1008 7
a1014 7
	unpacking->RowLength == 0 &&
	unpacking->SkipPixels == 0 &&
	unpacking->SkipRows == 0 &&
	unpacking->ImageHeight == 0 &&
	unpacking->SkipImages == 0 &&
	unpacking->SwapBytes == GL_FALSE &&
	unpacking->LsbFirst == GL_FALSE ) {
d1023 1
a1023 1
_mesa_convert_texsubimage1d( GLint mesaFormat,  /* dest */
d1026 2
a1027 2
			     GLenum format, GLenum type,  /* source */
			     const struct gl_pixelstore_attrib *unpacking,
d1030 1
a1030 1
   struct convert_info convert;
d1032 1
a1032 1
   ASSERT( unpacking );
d1037 1
a1037 1
   ASSERT( mesaFormat <= MESA_FORMAT_YCBCR_REV );
d1047 1
a1047 1
   convert.unpacking = unpacking;
d1053 2
a1054 2
   if ( convert_needs_unpacking( unpacking, format, type ) )
      convert.index |= CONVERT_UNPACKING_BIT;
d1056 1
a1056 3
   ASSERT(convert.index < 4);

   return convert_texsubimage2d_table[mesaFormat]( &convert );
a1058 26

/* Convert a user's 2D image into a texture image.  This basically
 * repacks pixel data into the special texture formats used by core Mesa
 * and the DRI drivers.  This function can do full images or subimages.
 *
 * We return a boolean because this function may not accept some kinds
 * of source image formats and/or types.  For example, if the incoming
 * format/type = GL_BGR, GL_UNSIGNED_INT this function probably won't
 * be able to do the conversion.
 *
 * In that case, the incoming image should first be simplified to one of
 * the "canonical" formats (GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA,
 * GL_INTENSITY, GL_RGB, GL_RGBA) and types (GL_CHAN).  We can do that
 * with the _mesa_transfer_teximage() function.  That function will also
 * do image transfer operations such as scale/bias and convolution.
 *
 * Input:
 *   mesaFormat - one of the MESA_FORMAT_* values from texformat.h
 *   xoffset, yoffset - position in dest image to put data
 *   width, height - incoming image size, also size of dest region.
 *   dstImageWidth - width (row stride) of dest image in pixels
 *   format, type - incoming image format and type
 *   unpacking - describes incoming image unpacking
 *   srcImage - pointer to source image
 *   destImage - pointer to dest image
 */
d1060 1
a1060 1
_mesa_convert_texsubimage2d( GLint mesaFormat,  /* dest */
d1063 3
a1065 3
			     GLint destImageWidth,
			     GLenum format, GLenum type,  /* source */
			     const struct gl_pixelstore_attrib *unpacking,
d1068 1
a1068 1
   struct convert_info convert;
d1070 1
a1070 1
   ASSERT( unpacking );
d1075 1
a1075 1
   ASSERT( mesaFormat <= MESA_FORMAT_YCBCR_REV );
d1083 4
a1086 4
   convert.dstImageWidth = destImageWidth;
   convert.format = format;  /* src */
   convert.type = type;      /* src */
   convert.unpacking = unpacking;
d1092 2
a1093 2
   if ( convert_needs_unpacking( unpacking, format, type ) )
      convert.index |= CONVERT_UNPACKING_BIT;
d1095 1
a1095 1
   if ( width != destImageWidth )
d1098 1
a1098 6
   ASSERT(convert.index < 4);

   ASSERT(mesaFormat < sizeof(convert_texsubimage2d_table) /
                       sizeof(convert_texsubimage2d_table[0]));

   return convert_texsubimage2d_table[mesaFormat]( &convert );
d1102 1
a1102 1
_mesa_convert_texsubimage3d( GLint mesaFormat,  /* dest */
d1105 3
a1107 3
			     GLint dstImageWidth, GLint dstImageHeight,
			     GLenum format, GLenum type,  /* source */
			     const struct gl_pixelstore_attrib *unpacking,
d1110 1
a1110 1
   struct convert_info convert;
d1112 1
a1112 1
   ASSERT( unpacking );
d1117 1
a1117 1
   ASSERT( mesaFormat <= MESA_FORMAT_YCBCR_REV );
d1127 2
a1128 2
   convert.dstImageWidth = dstImageWidth;
   convert.dstImageHeight = dstImageHeight;
d1131 1
a1131 1
   convert.unpacking = unpacking;
d1137 2
a1138 2
   if ( convert_needs_unpacking( unpacking, format, type ) )
      convert.index |= CONVERT_UNPACKING_BIT;
d1140 1
a1140 1
   if ( width != dstImageWidth || height != dstImageHeight )
d1143 39
a1181 1
   ASSERT(convert.index < 4);
d1183 34
a1216 1
   return convert_texsubimage3d_table[mesaFormat]( &convert );
d1225 1
a1225 1
void _mesa_rescale_teximage2d( GLuint bytesPerPixel, GLuint dstRowStride,
d1232 1
a1232 1
#define INNER_LOOP( TYPE, HOP, WOP )					\
d1237 1
a1237 1
	 dst[col] = src[srcRow * srcWidth + srcCol];			\
a1238 1
      dst = (TYPE *) ((GLubyte *) dst + dstRowStride);			\
d1250 1
a1250 1
	 INNER_LOOP( TYPE, /, / );					\
d1254 1
a1254 1
	 INNER_LOOP( TYPE, /, * );					\
d1261 1
a1261 1
	 INNER_LOOP( TYPE, *, / );					\
d1265 1
a1265 1
	 INNER_LOOP( TYPE, *, * );					\
d1270 1
a1270 1
   switch ( bytesPerPixel ) {
a1281 2
   default:
      _mesa_problem(NULL,"unexpected bytes/pixel in _mesa_rescale_teximage2d");
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d4 1
a4 1
 * Version:  4.1
d26 1
a26 1
 *    Gareth Hughes
d37 3
a43 1
#include "imports.h"
d45 1
d49 1
a49 1

d509 1
a509 1
 * AL88 textures:
d531 1
a531 1
	dst = APPEND16( PACK_COLOR_88_LE( src[0], 0x00 ),			\
d632 1
a632 1
 * CI8 (and all other single-byte texel) textures:
d754 1
a754 1
 * Global entry points
d757 1
a757 1
static convert_func convert_texsubimage2d_tab[] = {
d774 1
a774 1
static convert_func convert_texsubimage3d_tab[] = {
d819 1
a819 1
_mesa_convert_texsubimage1d( GLint mesaFormat,
d822 1
a822 1
			     GLenum format, GLenum type,
d854 1
a854 1
   return convert_texsubimage2d_tab[mesaFormat]( &convert );
d908 2
a909 2
   convert.format = format;
   convert.type = type;
d922 6
a927 1
   return convert_texsubimage2d_tab[mesaFormat]( &convert );
d972 3
a974 1
   return convert_texsubimage3d_tab[mesaFormat]( &convert );
@


