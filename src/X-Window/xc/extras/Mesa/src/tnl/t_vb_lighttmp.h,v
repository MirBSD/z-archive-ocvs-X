head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.2
	cvs-200410241530:1.1.1.2
	cvs-200410012000:1.1.1.2
	cvs-200407141120:1.1.1.2
	cvs-200406231010:1.1.1.2
	MIRBSD_7quater:1.1.1.1
	cvs-200405271510:1.1.1.2
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.2
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.4
	MIRBSD_7:1.1.1.1.0.2
	MIRBSD_7ter:1.1.1.1
	cvs-20011091815:1.1.1.1
	cvs-200309162130:1.1.1.1
	cvs-200308302005:1.1.1.1
	ctmx-0387:1.1.1.1
	ctmx-0384:1.1.1.1
	MIRBSD_5:1.1.1.1
	ctmx-0375:1.1.1.1
	ctmx-0373:1.1.1.1
	ctm-0371:1.1.1.1
	ctm-0370:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-0363:1.1.1.1
	ctm-0359:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.29.00;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.04.08.18.20.16;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.04.08.18.20.16;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.03.02.17.30.28;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.05.18;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@
/*
 * Mesa 3-D graphics library
 * Version:  3.5
 *
 * Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *
 * Authors:
 *    Brian Paul <brianp@@valinux.com>
 *    Keith Whitwell <keithw@@valinux.com>
 */


#if (IDX & LIGHT_FLAGS)
#  define VSTRIDE (4 * sizeof(GLfloat))
#  define NSTRIDE (3 * sizeof(GLfloat))
#  define CHECK_MATERIAL(x)  (flags[x] & VERT_MATERIAL)
#  define CHECK_END_VB(x)    (flags[x] & VERT_END_VB)
#  if (IDX & LIGHT_COLORMATERIAL)
#    define CMSTRIDE STRIDE_F(CMcolor, CMstride)
#    define CHECK_COLOR_MATERIAL(x) (flags[x] & VERT_RGBA)
#    define CHECK_VALIDATE(x) (flags[x] & (VERT_RGBA|VERT_MATERIAL))
#    define DO_ANOTHER_NORMAL(x) \
     ((flags[x] & (VERT_RGBA|VERT_NORM|VERT_END_VB|VERT_MATERIAL)) == VERT_NORM)
#    define REUSE_LIGHT_RESULTS(x) \
     ((flags[x] & (VERT_RGBA|VERT_NORM|VERT_END_VB|VERT_MATERIAL)) == 0)
#  else
#    define CMSTRIDE (void)0
#    define CHECK_COLOR_MATERIAL(x) 0
#    define CHECK_VALIDATE(x) (flags[x] & (VERT_MATERIAL))
#    define DO_ANOTHER_NORMAL(x) \
      ((flags[x] & (VERT_NORM|VERT_END_VB|VERT_MATERIAL)) == VERT_NORM)
#    define REUSE_LIGHT_RESULTS(x) \
      ((flags[x] & (VERT_NORM|VERT_END_VB|VERT_MATERIAL)) == 0)
#  endif
#else
#  define VSTRIDE vstride
#  define NSTRIDE nstride
#  define CHECK_MATERIAL(x)   0	           /* no materials on array paths */
#  define CHECK_END_VB(XX)     (XX >= nr)
#  if (IDX & LIGHT_COLORMATERIAL)
#     define CMSTRIDE STRIDE_F(CMcolor, CMstride)
#     define CHECK_COLOR_MATERIAL(x) (x < nr) /* always have colormaterial */
#     define CHECK_VALIDATE(x) (x < nr)
#     define DO_ANOTHER_NORMAL(x) 0        /* always stop to recalc colormat */
#  else
#     define CMSTRIDE (void)0
#     define CHECK_COLOR_MATERIAL(x) 0        /* no colormaterial */
#     define CHECK_VALIDATE(x) (0)
#     define DO_ANOTHER_NORMAL(XX) (XX < nr) /* keep going to end of vb */
#  endif
#  define REUSE_LIGHT_RESULTS(x) 0         /* always have a new normal */
#endif



#if (IDX & LIGHT_TWOSIDE)
#  define NR_SIDES 2
#else
#  define NR_SIDES 1
#endif



static void TAG(light_rgba_spec)( GLcontext *ctx,
				  struct vertex_buffer *VB,
				  struct gl_pipeline_stage *stage,
				  GLvector4f *input )
{
   struct light_stage_data *store = LIGHT_STAGE_DATA(stage);
   GLfloat (*base)[3] = ctx->Light._BaseColor;
   GLchan sumA[2];

   GLuint j;

   GLuint  vstride = input->stride;
   const GLfloat *vertex = (GLfloat *)input->data;
   GLuint  nstride = VB->NormalPtr->stride;
   const GLfloat *normal = (GLfloat *)VB->NormalPtr->data;

   GLfloat *CMcolor;
   GLuint CMstride;

   GLchan (*Fcolor)[4] = (GLchan (*)[4]) store->LitColor[0].Ptr;
   GLchan (*Bcolor)[4] = (GLchan (*)[4]) store->LitColor[1].Ptr;
   GLchan (*Fspec)[4] = (GLchan (*)[4]) store->LitSecondary[0].Ptr;
   GLchan (*Bspec)[4] = (GLchan (*)[4]) store->LitSecondary[1].Ptr;
   GLchan (*spec[2])[4];

   GLuint nr = VB->Count;
   GLuint *flags = VB->Flag;
   struct gl_material (*new_material)[2] = VB->Material;
   GLuint *new_material_mask = VB->MaterialMask;

   (void) flags;
   (void) nstride;
   (void) vstride;


   if (MESA_VERBOSE & VERBOSE_LIGHTING)
      fprintf(stderr, "%s\n", __FUNCTION__ );   

   spec[0] = Fspec;
   spec[1] = Bspec;

   if (IDX & LIGHT_COLORMATERIAL) {
      if (VB->ColorPtr[0]->Type != GL_FLOAT || 
	  VB->ColorPtr[0]->Size != 4)
	 import_color_material( ctx, stage );

      CMcolor = (GLfloat *) VB->ColorPtr[0]->Ptr;
      CMstride = VB->ColorPtr[0]->StrideB;
   }

   VB->ColorPtr[0] = &store->LitColor[0];
   VB->SecondaryColorPtr[0] = &store->LitSecondary[0];
   UNCLAMPED_FLOAT_TO_CHAN(sumA[0], ctx->Light.Material[0].Diffuse[3]);

   if (IDX & LIGHT_TWOSIDE) {
      VB->ColorPtr[1] = &store->LitColor[1];
      VB->SecondaryColorPtr[1] = &store->LitSecondary[1];
      UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
   }

   /* Side-effects done, can we finish now?
    */
   if (stage->changed_inputs == 0)
      return;

   for ( j=0 ;
	 j<nr ;
	 j++,STRIDE_F(vertex,VSTRIDE),STRIDE_F(normal,NSTRIDE),CMSTRIDE)
   {
      GLfloat sum[2][3], spec[2][3];
      struct gl_light *light;

      if ( CHECK_COLOR_MATERIAL(j) )
	 _mesa_update_color_material( ctx, CMcolor );

      if ( CHECK_MATERIAL(j) )
	 _mesa_update_material( ctx, new_material[j], new_material_mask[j] );

      if ( CHECK_VALIDATE(j) ) {
	 TNL_CONTEXT(ctx)->Driver.NotifyMaterialChange( ctx );
	 UNCLAMPED_FLOAT_TO_CHAN(sumA[0], ctx->Light.Material[0].Diffuse[3]);
	 if (IDX & LIGHT_TWOSIDE) 
	    UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
      }

      COPY_3V(sum[0], base[0]);
      ZERO_3V(spec[0]);

      if (IDX & LIGHT_TWOSIDE) {
	 COPY_3V(sum[1], base[1]);
	 ZERO_3V(spec[1]);
      }

      /* Add contribution from each enabled light source */
      foreach (light, &ctx->Light.EnabledList) {
	 GLfloat n_dot_h;
	 GLfloat correction;
	 GLint side;
	 GLfloat contrib[3];
	 GLfloat attenuation;
	 GLfloat VP[3];  /* unit vector from vertex to light */
	 GLfloat n_dot_VP;       /* n dot VP */
	 GLfloat *h;

	 /* compute VP and attenuation */
	 if (!(light->_Flags & LIGHT_POSITIONAL)) {
	    /* directional light */
	    COPY_3V(VP, light->_VP_inf_norm);
	    attenuation = light->_VP_inf_spot_attenuation;
	 }
	 else {
	    GLfloat d;     /* distance from vertex to light */

	    SUB_3V(VP, light->_Position, vertex);

	    d = (GLfloat) LEN_3FV( VP );

	    if (d > 1e-6) {
	       GLfloat invd = 1.0F / d;
	       SELF_SCALE_SCALAR_3V(VP, invd);
	    }

	    attenuation = 1.0F / (light->ConstantAttenuation + d *
				  (light->LinearAttenuation + d *
				   light->QuadraticAttenuation));

	    /* spotlight attenuation */
	    if (light->_Flags & LIGHT_SPOT) {
	       GLfloat PV_dot_dir = - DOT3(VP, light->_NormDirection);

	       if (PV_dot_dir<light->_CosCutoff) {
		  continue; /* this light makes no contribution */
	       }
	       else {
		  GLdouble x = PV_dot_dir * (EXP_TABLE_SIZE-1);
		  GLint k = (GLint) x;
		  GLfloat spot = (GLfloat) (light->_SpotExpTable[k][0]
				    + (x-k)*light->_SpotExpTable[k][1]);
		  attenuation *= spot;
	       }
	    }
	 }

	 if (attenuation < 1e-3)
	    continue;		/* this light makes no contribution */

	 /* Compute dot product or normal and vector from V to light pos */
	 n_dot_VP = DOT3( normal, VP );

	 /* Which side gets the diffuse & specular terms? */
	 if (n_dot_VP < 0.0F) {
	    ACC_SCALE_SCALAR_3V(sum[0], attenuation, light->_MatAmbient[0]);
	    if (!(IDX & LIGHT_TWOSIDE)) {
	       continue;
	    }
	    side = 1;
	    correction = -1;
	    n_dot_VP = -n_dot_VP;
	 }
         else {
	    if (IDX & LIGHT_TWOSIDE) {
	       ACC_SCALE_SCALAR_3V( sum[1], attenuation, light->_MatAmbient[1]);
	    }
	    side = 0;
	    correction = 1;
	 }

	 /* diffuse term */
	 COPY_3V(contrib, light->_MatAmbient[side]);
	 ACC_SCALE_SCALAR_3V(contrib, n_dot_VP, light->_MatDiffuse[side]);
	 ACC_SCALE_SCALAR_3V(sum[side], attenuation, contrib );

	 /* specular term - cannibalize VP... */
	 if (ctx->Light.Model.LocalViewer) {
	    GLfloat v[3];
	    COPY_3V(v, vertex);
	    NORMALIZE_3FV(v);
	    SUB_3V(VP, VP, v);                /* h = VP + VPe */
	    h = VP;
	    NORMALIZE_3FV(h);
	 }
	 else if (light->_Flags & LIGHT_POSITIONAL) {
	    h = VP;
	    ACC_3V(h, ctx->_EyeZDir);
	    NORMALIZE_3FV(h);
	 }
         else {
	    h = light->_h_inf_norm;
	 }

	 n_dot_h = correction * DOT3(normal, h);

	 if (n_dot_h > 0.0F) {
	    GLfloat spec_coef;
	    struct gl_shine_tab *tab = ctx->_ShineTable[side];
	    GET_SHINE_TAB_ENTRY( tab, n_dot_h, spec_coef );

	    if (spec_coef > 1.0e-10) {
	       spec_coef *= attenuation;
	       ACC_SCALE_SCALAR_3V( spec[side], spec_coef,
				    light->_MatSpecular[side]);
	    }
	 }
      } /*loop over lights*/

      UNCLAMPED_FLOAT_TO_RGB_CHAN( Fcolor[j], sum[0] );
      UNCLAMPED_FLOAT_TO_RGB_CHAN( Fspec[j], spec[0] );
      Fcolor[j][3] = sumA[0];

      if (IDX & LIGHT_TWOSIDE) {
	 UNCLAMPED_FLOAT_TO_RGB_CHAN( Bcolor[j], sum[1] );
	 UNCLAMPED_FLOAT_TO_RGB_CHAN( Bspec[j], spec[1] );
	 Bcolor[j][3] = sumA[1];
      }
   }
}


static void TAG(light_rgba)( GLcontext *ctx,
			     struct vertex_buffer *VB,
			     struct gl_pipeline_stage *stage,
			     GLvector4f *input )
{
   struct light_stage_data *store = LIGHT_STAGE_DATA(stage);
   GLuint j;

   GLfloat (*base)[3] = ctx->Light._BaseColor;
   GLchan sumA[2];

   GLuint  vstride = input->stride;
   const GLfloat *vertex = (GLfloat *) input->data;
   GLuint  nstride = VB->NormalPtr->stride;
   const GLfloat *normal = (GLfloat *)VB->NormalPtr->data;

   GLfloat *CMcolor;
   GLuint CMstride;

   GLchan (*Fcolor)[4] = (GLchan (*)[4]) store->LitColor[0].Ptr;
   GLchan (*Bcolor)[4] = (GLchan (*)[4]) store->LitColor[1].Ptr;
   GLchan (*color[2])[4];
   GLuint *flags = VB->Flag;

   struct gl_material (*new_material)[2] = VB->Material;
   GLuint *new_material_mask = VB->MaterialMask;
   GLuint nr = VB->Count;

   if (MESA_VERBOSE & VERBOSE_LIGHTING)
      fprintf(stderr, "%s\n", __FUNCTION__ );   

   (void) flags;
   (void) nstride;
   (void) vstride;

   color[0] = Fcolor;
   color[1] = Bcolor;

   if (IDX & LIGHT_COLORMATERIAL) {
      if (VB->ColorPtr[0]->Type != GL_FLOAT || 
	  VB->ColorPtr[0]->Size != 4)
	 import_color_material( ctx, stage );

      CMcolor = (GLfloat *)VB->ColorPtr[0]->Ptr;
      CMstride = VB->ColorPtr[0]->StrideB;
   }

   VB->ColorPtr[0] = &store->LitColor[0];
   UNCLAMPED_FLOAT_TO_CHAN(sumA[0], ctx->Light.Material[0].Diffuse[3]);

   if (IDX & LIGHT_TWOSIDE) {
      VB->ColorPtr[1] = &store->LitColor[1];
      UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
   }

   if (stage->changed_inputs == 0)
      return;

   for ( j=0 ;
	 j<nr ;
	 j++,STRIDE_F(vertex,VSTRIDE), STRIDE_F(normal,NSTRIDE),CMSTRIDE)
   {
      GLfloat sum[2][3];
      struct gl_light *light;

      if ( CHECK_COLOR_MATERIAL(j) )
	 _mesa_update_color_material( ctx, CMcolor );

      if ( CHECK_MATERIAL(j) )
	 _mesa_update_material( ctx, new_material[j], new_material_mask[j] );

      if ( CHECK_VALIDATE(j) ) {
	 TNL_CONTEXT(ctx)->Driver.NotifyMaterialChange( ctx );
	 UNCLAMPED_FLOAT_TO_CHAN(sumA[0], ctx->Light.Material[0].Diffuse[3]);
	 if (IDX & LIGHT_TWOSIDE)
	    UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
      }

      COPY_3V(sum[0], base[0]);

      if ( IDX & LIGHT_TWOSIDE )
	 COPY_3V(sum[1], base[1]);

      /* Add contribution from each enabled light source */
      foreach (light, &ctx->Light.EnabledList) {

	 GLfloat n_dot_h;
	 GLfloat correction;
	 GLint side;
	 GLfloat contrib[3];
	 GLfloat attenuation = 1.0;
	 GLfloat VP[3];          /* unit vector from vertex to light */
	 GLfloat n_dot_VP;       /* n dot VP */
	 GLfloat *h;

	 /* compute VP and attenuation */
	 if (!(light->_Flags & LIGHT_POSITIONAL)) {
	    /* directional light */
	    COPY_3V(VP, light->_VP_inf_norm);
	    attenuation = light->_VP_inf_spot_attenuation;
	 }
	 else {
	    GLfloat d;     /* distance from vertex to light */


	    SUB_3V(VP, light->_Position, vertex);

	    d = (GLfloat) LEN_3FV( VP );

	    if ( d > 1e-6) {
	       GLfloat invd = 1.0F / d;
	       SELF_SCALE_SCALAR_3V(VP, invd);
	    }

            attenuation = 1.0F / (light->ConstantAttenuation + d *
                                  (light->LinearAttenuation + d *
                                   light->QuadraticAttenuation));

	    /* spotlight attenuation */
	    if (light->_Flags & LIGHT_SPOT) {
	       GLfloat PV_dot_dir = - DOT3(VP, light->_NormDirection);

	       if (PV_dot_dir<light->_CosCutoff) {
		  continue; /* this light makes no contribution */
	       }
	       else {
		  GLdouble x = PV_dot_dir * (EXP_TABLE_SIZE-1);
		  GLint k = (GLint) x;
		  GLfloat spot = (GLfloat) (light->_SpotExpTable[k][0]
				  + (x-k)*light->_SpotExpTable[k][1]);
		  attenuation *= spot;
	       }
	    }
	 }

	 if (attenuation < 1e-3)
	    continue;		/* this light makes no contribution */

	 /* Compute dot product or normal and vector from V to light pos */
	 n_dot_VP = DOT3( normal, VP );

	 /* which side are we lighting? */
	 if (n_dot_VP < 0.0F) {
	    ACC_SCALE_SCALAR_3V(sum[0], attenuation, light->_MatAmbient[0]);

	    if (!(IDX & LIGHT_TWOSIDE))
	       continue;

	    side = 1;
	    correction = -1;
	    n_dot_VP = -n_dot_VP;
	 }
         else {
	    if (IDX & LIGHT_TWOSIDE) {
	       ACC_SCALE_SCALAR_3V( sum[1], attenuation, light->_MatAmbient[1]);
	    }
	    side = 0;
	    correction = 1;
	 }

	 COPY_3V(contrib, light->_MatAmbient[side]);

	 /* diffuse term */
	 ACC_SCALE_SCALAR_3V(contrib, n_dot_VP, light->_MatDiffuse[side]);

	 /* specular term - cannibalize VP... */
	 {
	    if (ctx->Light.Model.LocalViewer) {
	       GLfloat v[3];
	       COPY_3V(v, vertex);
	       NORMALIZE_3FV(v);
	       SUB_3V(VP, VP, v);                /* h = VP + VPe */
	       h = VP;
	       NORMALIZE_3FV(h);
	    }
	    else if (light->_Flags & LIGHT_POSITIONAL) {
	       h = VP;
	       ACC_3V(h, ctx->_EyeZDir);
	       NORMALIZE_3FV(h);
	    }
            else {
	       h = light->_h_inf_norm;
	    }

	    n_dot_h = correction * DOT3(normal, h);

	    if (n_dot_h > 0.0F)
	    {
	       GLfloat spec_coef;
	       struct gl_shine_tab *tab = ctx->_ShineTable[side];

	       GET_SHINE_TAB_ENTRY( tab, n_dot_h, spec_coef );

	       ACC_SCALE_SCALAR_3V( contrib, spec_coef,
				    light->_MatSpecular[side]);
	    }
	 }

	 ACC_SCALE_SCALAR_3V( sum[side], attenuation, contrib );
      }

      UNCLAMPED_FLOAT_TO_RGB_CHAN( Fcolor[j], sum[0] );
      Fcolor[j][3] = sumA[0];

      if (IDX & LIGHT_TWOSIDE) {
	 UNCLAMPED_FLOAT_TO_RGB_CHAN( Bcolor[j], sum[1] );
	 Bcolor[j][3] = sumA[1];
      }
   }
}




/* As below, but with just a single light.
 */
static void TAG(light_fast_rgba_single)( GLcontext *ctx,
					 struct vertex_buffer *VB,
					 struct gl_pipeline_stage *stage,
					 GLvector4f *input )

{
   struct light_stage_data *store = LIGHT_STAGE_DATA(stage);
   GLuint  nstride = VB->NormalPtr->stride;
   const GLfloat *normal = (GLfloat *)VB->NormalPtr->data;
   GLfloat *CMcolor;
   GLuint CMstride;
   GLchan (*Fcolor)[4] = (GLchan (*)[4]) store->LitColor[0].Ptr;
   GLchan (*Bcolor)[4] = (GLchan (*)[4]) store->LitColor[1].Ptr;
   struct gl_light *light = ctx->Light.EnabledList.next;
   GLuint *flags = VB->Flag;
   GLchan basechan[2][4];
   GLuint j = 0;
   struct gl_material (*new_material)[2] = VB->Material;
   GLuint *new_material_mask = VB->MaterialMask;
   GLfloat base[2][3];
   GLuint nr = VB->Count;

   if (MESA_VERBOSE & VERBOSE_LIGHTING)
      fprintf(stderr, "%s\n", __FUNCTION__ );   

   (void) input;		/* doesn't refer to Eye or Obj */
   (void) flags;
   (void) nr;
   (void) nstride;

   if (IDX & LIGHT_COLORMATERIAL) {
      if (VB->ColorPtr[0]->Type != GL_FLOAT || 
	  VB->ColorPtr[0]->Size != 4)
	 import_color_material( ctx, stage );

      CMcolor = (GLfloat *)VB->ColorPtr[0]->Ptr;
      CMstride = VB->ColorPtr[0]->StrideB;
   }

   VB->ColorPtr[0] = &store->LitColor[0];
   if (IDX & LIGHT_TWOSIDE)
      VB->ColorPtr[1] = &store->LitColor[1];

   if (stage->changed_inputs == 0)
      return;

   do {
      
      if ( CHECK_COLOR_MATERIAL(j) ) {
	 _mesa_update_color_material( ctx, CMcolor );
      }

      if ( CHECK_MATERIAL(j) )
	 _mesa_update_material( ctx, new_material[j], new_material_mask[j] );

      if ( CHECK_VALIDATE(j) )
	 TNL_CONTEXT(ctx)->Driver.NotifyMaterialChange( ctx );


      /* No attenuation, so incoporate _MatAmbient into base color.
       */
      COPY_3V(base[0], light->_MatAmbient[0]);
      ACC_3V(base[0], ctx->Light._BaseColor[0] );
      UNCLAMPED_FLOAT_TO_RGB_CHAN( basechan[0], base[0] );
      UNCLAMPED_FLOAT_TO_CHAN(basechan[0][3], 
			      ctx->Light.Material[0].Diffuse[3]);

      if (IDX & LIGHT_TWOSIDE) {
	 COPY_3V(base[1], light->_MatAmbient[1]);
	 ACC_3V(base[1], ctx->Light._BaseColor[1]);
	 UNCLAMPED_FLOAT_TO_RGB_CHAN( basechan[1], base[1]);
	 UNCLAMPED_FLOAT_TO_CHAN(basechan[1][3], 
				 ctx->Light.Material[1].Diffuse[3]);
      }

      do {
	 GLfloat n_dot_VP = DOT3(normal, light->_VP_inf_norm);

	 if (n_dot_VP < 0.0F) {
	    if (IDX & LIGHT_TWOSIDE) {
	       GLfloat n_dot_h = -DOT3(normal, light->_h_inf_norm);
	       GLfloat sum[3];
	       COPY_3V(sum, base[1]);
	       ACC_SCALE_SCALAR_3V(sum, -n_dot_VP, light->_MatDiffuse[1]);
	       if (n_dot_h > 0.0F) {
		  GLfloat spec;
		  GET_SHINE_TAB_ENTRY( ctx->_ShineTable[1], n_dot_h, spec );
		  ACC_SCALE_SCALAR_3V(sum, spec, light->_MatSpecular[1]);
	       }
	       UNCLAMPED_FLOAT_TO_RGB_CHAN(Bcolor[j], sum );
	       Bcolor[j][3] = basechan[1][3];
	    }
	    COPY_CHAN4(Fcolor[j], basechan[0]);
	 } else {
	    GLfloat n_dot_h = DOT3(normal, light->_h_inf_norm);
	    GLfloat sum[3];
	    COPY_3V(sum, base[0]);
	    ACC_SCALE_SCALAR_3V(sum, n_dot_VP, light->_MatDiffuse[0]);
	    if (n_dot_h > 0.0F) {
	       GLfloat spec;
	       GET_SHINE_TAB_ENTRY( ctx->_ShineTable[0], n_dot_h, spec );
	       ACC_SCALE_SCALAR_3V(sum, spec, light->_MatSpecular[0]);

	    }
	    UNCLAMPED_FLOAT_TO_RGB_CHAN(Fcolor[j], sum );
	    Fcolor[j][3] = basechan[0][3];
	    if (IDX & LIGHT_TWOSIDE) COPY_CHAN4(Bcolor[j], basechan[1]);
	 }

	 j++;
	 CMSTRIDE;
	 STRIDE_F(normal, NSTRIDE);
      } while (DO_ANOTHER_NORMAL(j));


      for ( ; REUSE_LIGHT_RESULTS(j) ; j++, CMSTRIDE, STRIDE_F(normal,NSTRIDE))
      {
	 COPY_CHAN4(Fcolor[j], Fcolor[j-1]);
	 if (IDX & LIGHT_TWOSIDE)
	    COPY_CHAN4(Bcolor[j], Bcolor[j-1]);
      }

   } while (!CHECK_END_VB(j));
}


/* Light infinite lights
 */
static void TAG(light_fast_rgba)( GLcontext *ctx,
				  struct vertex_buffer *VB,
				  struct gl_pipeline_stage *stage,
				  GLvector4f *input )
{
   struct light_stage_data *store = LIGHT_STAGE_DATA(stage);
   GLchan sumA[2];
   GLuint  nstride = VB->NormalPtr->stride;
   const GLfloat *normal = (GLfloat *)VB->NormalPtr->data;
   GLfloat *CMcolor;
   GLuint CMstride;
   GLchan (*Fcolor)[4] = (GLchan (*)[4]) store->LitColor[0].Ptr;
   GLchan (*Bcolor)[4] = (GLchan (*)[4]) store->LitColor[1].Ptr;
   GLuint *flags = VB->Flag;
   GLuint j = 0;
   struct gl_material (*new_material)[2] = VB->Material;
   GLuint *new_material_mask = VB->MaterialMask;
   GLuint nr = VB->Count;
   struct gl_light *light;

   if (MESA_VERBOSE & VERBOSE_LIGHTING)
      fprintf(stderr, "%s\n", __FUNCTION__ );   


   (void) flags;
   (void) input;
   (void) nr;
   (void) nstride;

   UNCLAMPED_FLOAT_TO_CHAN(sumA[0], ctx->Light.Material[0].Diffuse[3]);
   UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);

   if (IDX & LIGHT_COLORMATERIAL) {
      if (VB->ColorPtr[0]->Type != GL_FLOAT || 
	  VB->ColorPtr[0]->Size != 4)
	 import_color_material( ctx, stage );

      CMcolor = (GLfloat *)VB->ColorPtr[0]->Ptr;
      CMstride = VB->ColorPtr[0]->StrideB;
   }

   VB->ColorPtr[0] = &store->LitColor[0];
   if (IDX & LIGHT_TWOSIDE)
      VB->ColorPtr[1] = &store->LitColor[1];

   if (stage->changed_inputs == 0)
      return;

   do {
      do {
	 GLfloat sum[2][3];

	 if ( CHECK_COLOR_MATERIAL(j) )
	    _mesa_update_color_material( ctx, CMcolor );

	 if ( CHECK_MATERIAL(j) )
	    _mesa_update_material( ctx, new_material[j], new_material_mask[j] );

	 if ( CHECK_VALIDATE(j) ) {
	    TNL_CONTEXT(ctx)->Driver.NotifyMaterialChange( ctx );
	    UNCLAMPED_FLOAT_TO_CHAN(sumA[0], ctx->Light.Material[0].Diffuse[3]);
	    if (IDX & LIGHT_TWOSIDE)
	       UNCLAMPED_FLOAT_TO_CHAN(sumA[1], 
				       ctx->Light.Material[1].Diffuse[3]);
	 }


	 COPY_3V(sum[0], ctx->Light._BaseColor[0]);
	 if (IDX & LIGHT_TWOSIDE)
	    COPY_3V(sum[1], ctx->Light._BaseColor[1]);

	 foreach (light, &ctx->Light.EnabledList) {
	    GLfloat n_dot_h, n_dot_VP, spec;

	    ACC_3V(sum[0], light->_MatAmbient[0]);
	    if (IDX & LIGHT_TWOSIDE)
	       ACC_3V(sum[1], light->_MatAmbient[1]);

	    n_dot_VP = DOT3(normal, light->_VP_inf_norm);

	    if (n_dot_VP > 0.0F) {
	       ACC_SCALE_SCALAR_3V(sum[0], n_dot_VP, light->_MatDiffuse[0]);
	       n_dot_h = DOT3(normal, light->_h_inf_norm);
	       if (n_dot_h > 0.0F) {
		  struct gl_shine_tab *tab = ctx->_ShineTable[0];
		  GET_SHINE_TAB_ENTRY( tab, n_dot_h, spec );
		  ACC_SCALE_SCALAR_3V( sum[0], spec,
				       light->_MatSpecular[0]);
	       }
	    }
	    else if (IDX & LIGHT_TWOSIDE) {
	       ACC_SCALE_SCALAR_3V(sum[1], -n_dot_VP, light->_MatDiffuse[1]);
	       n_dot_h = -DOT3(normal, light->_h_inf_norm);
	       if (n_dot_h > 0.0F) {
		  struct gl_shine_tab *tab = ctx->_ShineTable[1];
		  GET_SHINE_TAB_ENTRY( tab, n_dot_h, spec );
		  ACC_SCALE_SCALAR_3V( sum[1], spec,
				       light->_MatSpecular[1]);
	       }
	    }
	 }

	 UNCLAMPED_FLOAT_TO_RGB_CHAN( Fcolor[j], sum[0] );
	 Fcolor[j][3] = sumA[0];

	 if (IDX & LIGHT_TWOSIDE) {
	    UNCLAMPED_FLOAT_TO_RGB_CHAN( Bcolor[j], sum[1] );
	    Bcolor[j][3] = sumA[1];
	 }

	 j++;
	 CMSTRIDE;
	 STRIDE_F(normal, NSTRIDE);
      } while (DO_ANOTHER_NORMAL(j));

      /* Reuse the shading results while there is no change to
       * normal or material values.
       */
      for ( ; REUSE_LIGHT_RESULTS(j) ; j++, CMSTRIDE, STRIDE_F(normal, NSTRIDE))
      {
	 COPY_CHAN4(Fcolor[j], Fcolor[j-1]);
	 if (IDX & LIGHT_TWOSIDE)
	    COPY_CHAN4(Bcolor[j], Bcolor[j-1]);
      }

   } while (!CHECK_END_VB(j));
}





/*
 * Use current lighting/material settings to compute the color indexes
 * for an array of vertices.
 * Input:  n - number of vertices to light
 *         side - 0=use front material, 1=use back material
 *         vertex - array of [n] vertex position in eye coordinates
 *         normal - array of [n] surface normal vector
 * Output:  indexResult - resulting array of [n] color indexes
 */
static void TAG(light_ci)( GLcontext *ctx,
			   struct vertex_buffer *VB,
			   struct gl_pipeline_stage *stage,
			   GLvector4f *input )
{
   struct light_stage_data *store = LIGHT_STAGE_DATA(stage);
   GLuint j;
   GLuint vstride = input->stride;
   const GLfloat *vertex = (GLfloat *) input->data;
   GLuint nstride = VB->NormalPtr->stride;
   const GLfloat *normal = (GLfloat *)VB->NormalPtr->data;
   GLfloat *CMcolor;
   GLuint CMstride;
   GLuint *flags = VB->Flag;
   GLuint *indexResult[2];
   struct gl_material (*new_material)[2] = VB->Material;
   GLuint *new_material_mask = VB->MaterialMask;
   GLuint nr = VB->Count;

   if (MESA_VERBOSE & VERBOSE_LIGHTING)
      fprintf(stderr, "%s\n", __FUNCTION__ );   

   (void) flags;
   (void) nstride;
   (void) vstride;

   VB->IndexPtr[0] = &store->LitIndex[0];
   if (IDX & LIGHT_TWOSIDE)
      VB->IndexPtr[1] = &store->LitIndex[1];

   if (stage->changed_inputs == 0)
      return;

   indexResult[0] = VB->IndexPtr[0]->data;
   if (IDX & LIGHT_TWOSIDE)
      indexResult[1] = VB->IndexPtr[1]->data;

   if (IDX & LIGHT_COLORMATERIAL) {
      if (VB->ColorPtr[0]->Type != GL_FLOAT || 
	  VB->ColorPtr[0]->Size != 4)
	 import_color_material( ctx, stage );

      CMcolor = (GLfloat *)VB->ColorPtr[0]->Ptr;
      CMstride = VB->ColorPtr[0]->StrideB;
   }

   /* loop over vertices */
   for ( j=0 ;
	 j<nr ;
	 j++,STRIDE_F(vertex,VSTRIDE),STRIDE_F(normal, NSTRIDE), CMSTRIDE)
   {
      GLfloat diffuse[2], specular[2];
      GLuint side = 0;
      struct gl_light *light;

      if ( CHECK_COLOR_MATERIAL(j) )
	 _mesa_update_color_material( ctx, CMcolor );

      if ( CHECK_MATERIAL(j) )
	 _mesa_update_material( ctx, new_material[j], new_material_mask[j] );

      if ( CHECK_VALIDATE(j) )
	 TNL_CONTEXT(ctx)->Driver.NotifyMaterialChange( ctx );

      diffuse[0] = specular[0] = 0.0F;

      if ( IDX & LIGHT_TWOSIDE ) {
	 diffuse[1] = specular[1] = 0.0F;
      }

      /* Accumulate diffuse and specular from each light source */
      foreach (light, &ctx->Light.EnabledList) {

	 GLfloat attenuation = 1.0F;
	 GLfloat VP[3];  /* unit vector from vertex to light */
	 GLfloat n_dot_VP;  /* dot product of l and n */
	 GLfloat *h, n_dot_h, correction = 1.0;

	 /* compute l and attenuation */
	 if (!(light->_Flags & LIGHT_POSITIONAL)) {
	    /* directional light */
	    COPY_3V(VP, light->_VP_inf_norm);
	 }
	 else {
	    GLfloat d;     /* distance from vertex to light */

	    SUB_3V(VP, light->_Position, vertex);

	    d = (GLfloat) LEN_3FV( VP );
	    if ( d > 1e-6) {
	       GLfloat invd = 1.0F / d;
	       SELF_SCALE_SCALAR_3V(VP, invd);
	    }

	    attenuation = 1.0F / (light->ConstantAttenuation + d *
				  (light->LinearAttenuation + d *
				   light->QuadraticAttenuation));

	    /* spotlight attenuation */
	    if (light->_Flags & LIGHT_SPOT) {
	       GLfloat PV_dot_dir = - DOT3(VP, light->_NormDirection);
	       if (PV_dot_dir < light->_CosCutoff) {
		  continue; /* this light makes no contribution */
	       }
	       else {
		  GLdouble x = PV_dot_dir * (EXP_TABLE_SIZE-1);
		  GLint k = (GLint) x;
		  GLfloat spot = (GLfloat) (light->_SpotExpTable[k][0]
				  + (x-k)*light->_SpotExpTable[k][1]);
		  attenuation *= spot;
	       }
	    }
	 }

	 if (attenuation < 1e-3)
	    continue;		/* this light makes no contribution */

	 n_dot_VP = DOT3( normal, VP );

	 /* which side are we lighting? */
	 if (n_dot_VP < 0.0F) {
	    if (!(IDX & LIGHT_TWOSIDE))
	       continue;
	    side = 1;
	    correction = -1;
	    n_dot_VP = -n_dot_VP;
	 }

	 /* accumulate diffuse term */
	 diffuse[side] += n_dot_VP * light->_dli * attenuation;

	 /* specular term */
	 if (ctx->Light.Model.LocalViewer) {
	    GLfloat v[3];
	    COPY_3V(v, vertex);
	    NORMALIZE_3FV(v);
	    SUB_3V(VP, VP, v);                /* h = VP + VPe */
	    h = VP;
	    NORMALIZE_3FV(h);
	 }
	 else if (light->_Flags & LIGHT_POSITIONAL) {
	    h = VP;
            /* Strangely, disabling this addition fixes a conformance
             * problem.  If this code is enabled, l_sed.c fails.
             */
	    /*ACC_3V(h, ctx->_EyeZDir);*/
	    NORMALIZE_3FV(h);
	 }
         else {
	    h = light->_h_inf_norm;
	 }

	 n_dot_h = correction * DOT3(normal, h);
	 if (n_dot_h > 0.0F) {
	    GLfloat spec_coef;
	    struct gl_shine_tab *tab = ctx->_ShineTable[side];
	    GET_SHINE_TAB_ENTRY( tab, n_dot_h, spec_coef);
	    specular[side] += spec_coef * light->_sli * attenuation;
	 }
      } /*loop over lights*/

      /* Now compute final color index */
      for (side = 0 ; side < NR_SIDES ; side++) {
	 struct gl_material *mat = &ctx->Light.Material[side];
	 GLfloat index;

	 if (specular[side] > 1.0F) {
	    index = mat->SpecularIndex;
	 }
	 else {
	    GLfloat d_a = mat->DiffuseIndex - mat->AmbientIndex;
	    GLfloat s_a = mat->SpecularIndex - mat->AmbientIndex;

	    index = mat->AmbientIndex
	       + diffuse[side] * (1.0F-specular[side]) * d_a
	       + specular[side] * s_a;

	    if (index > mat->SpecularIndex) {
	       index = mat->SpecularIndex;
	    }
	 }
	 indexResult[side][j] = (GLuint) (GLint) index;
      }
   } /*for vertex*/
}



static void TAG(init_light_tab)( void )
{
   _tnl_light_tab[IDX] = TAG(light_rgba);
   _tnl_light_fast_tab[IDX] = TAG(light_fast_rgba);
   _tnl_light_fast_single_tab[IDX] = TAG(light_fast_rgba_single);
   _tnl_light_spec_tab[IDX] = TAG(light_rgba_spec);
   _tnl_light_ci_tab[IDX] = TAG(light_ci);
}


#undef TAG
#undef IDX
#undef NR_SIDES
#undef NSTRIDE
#undef VSTRIDE
#undef CHECK_MATERIAL
#undef CHECK_END_VB
#undef DO_ANOTHER_NORMAL
#undef REUSE_LIGHT_RESULTS
#undef CMSTRIDE
#undef CHECK_COLOR_MATERIAL
#undef CHECK_VALIDATE
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/extras/Mesa/src/tnl/t_vb_lighttmp.h,v 1.5 2003/11/04 15:16:29 tsi Exp $ */
d4 1
a4 1
 * Version:  4.1
d27 2
a28 2
 *    Brian Paul
 *    Keith Whitwell <keith@@tungstengraphics.com>
d34 3
a36 3
#  define NSTRIDE nstride /*(3 * sizeof(GLfloat))*/
#  define CHECK_MATERIAL(x)  (flags[x] & VERT_BIT_MATERIAL)
#  define CHECK_END_VB(x)    (flags[x] & VERT_BIT_END_VB)
d39 2
a40 2
#    define CHECK_COLOR_MATERIAL(x) (flags[x] & VERT_BIT_COLOR0)
#    define CHECK_VALIDATE(x) (flags[x] & (VERT_BIT_COLOR0|VERT_BIT_MATERIAL))
d42 1
a42 1
     ((flags[x] & (VERT_BIT_COLOR0|VERT_BIT_NORMAL|VERT_BIT_END_VB|VERT_BIT_MATERIAL)) == VERT_BIT_NORMAL)
d44 1
a44 1
     ((flags[x] & (VERT_BIT_COLOR0|VERT_BIT_NORMAL|VERT_BIT_END_VB|VERT_BIT_MATERIAL)) == 0)
d48 1
a48 1
#    define CHECK_VALIDATE(x) (flags[x] & (VERT_BIT_MATERIAL))
d50 1
a50 1
      ((flags[x] & (VERT_BIT_NORMAL|VERT_BIT_END_VB|VERT_BIT_MATERIAL)) == VERT_BIT_NORMAL)
d52 1
a52 1
      ((flags[x] & (VERT_BIT_NORMAL|VERT_BIT_END_VB|VERT_BIT_MATERIAL)) == 0)
a81 2
/* define TRACE if to trace lighting code */

a82 6
/*
 * ctx is the current context
 * VB is the vertex buffer
 * stage is the lighting stage-private data
 * input is the vector of eye or object-space vertex coordinates
 */
d91 1
d94 1
a94 1
   const GLuint vstride = input->stride;
d96 1
a96 1
   const GLuint nstride = VB->NormalPtr->stride;
a99 1
#if IDX & LIGHT_COLORMATERIAL
a100 1
#endif
a102 1
#if IDX & LIGHT_TWOSIDE
a103 1
#endif
a104 1
#if IDX & LIGHT_TWOSIDE
d106 1
a106 1
#endif
d108 2
a109 2
   const GLuint nr = VB->Count;
   const GLuint *flags = VB->Flag;
d111 1
a111 1
   const GLuint *new_material_mask = VB->MaterialMask;
a116 3
#ifdef TRACE
   fprintf(stderr, "%s\n", __FUNCTION__ );
#endif
d118 10
a127 4
#if IDX & LIGHT_COLORMATERIAL
   if (VB->ColorPtr[0]->Type != GL_FLOAT ||
       VB->ColorPtr[0]->Size != 4)
      import_color_material( ctx, stage );
d129 3
a131 3
   CMcolor = (GLfloat *) VB->ColorPtr[0]->Ptr;
   CMstride = VB->ColorPtr[0]->StrideB;
#endif
d137 5
a141 5
#if IDX & LIGHT_TWOSIDE
   VB->ColorPtr[1] = &store->LitColor[1];
   VB->SecondaryColorPtr[1] = &store->LitSecondary[1];
   UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
#endif
d164 2
a165 3
#if IDX & LIGHT_TWOSIDE
	 UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
#endif
d171 4
a174 4
#if IDX & LIGHT_TWOSIDE
      COPY_3V(sum[1], base[1]);
      ZERO_3V(spec[1]);
#endif
d235 3
a237 1
#if IDX & LIGHT_TWOSIDE
a240 3
#else
	    continue;
#endif
d243 3
a245 3
#if IDX & LIGHT_TWOSIDE
	    ACC_SCALE_SCALAR_3V( sum[1], attenuation, light->_MatAmbient[1]);
#endif
d292 5
a296 5
#if IDX & LIGHT_TWOSIDE
      UNCLAMPED_FLOAT_TO_RGB_CHAN( Bcolor[j], sum[1] );
      UNCLAMPED_FLOAT_TO_RGB_CHAN( Bspec[j], spec[1] );
      Bcolor[j][3] = sumA[1];
#endif
d312 1
a312 1
   const GLuint vstride = input->stride;
d314 1
a314 1
   const GLuint nstride = VB->NormalPtr->stride;
a317 1
#if IDX & LIGHT_COLORMATERIAL
a318 1
#endif
a320 1
#if IDX & LIGHT_TWOSIDE
d322 2
a323 2
#endif
   const GLuint *flags = VB->Flag;
d326 2
a327 2
   const GLuint *new_material_mask = VB->MaterialMask;
   const GLuint nr = VB->Count;
d329 2
a330 3
#ifdef TRACE
   fprintf(stderr, "%s\n", __FUNCTION__ );
#endif
d336 2
a337 4
#if IDX & LIGHT_COLORMATERIAL
   if (VB->ColorPtr[0]->Type != GL_FLOAT ||
       VB->ColorPtr[0]->Size != 4)
      import_color_material( ctx, stage );
d339 8
a346 3
   CMcolor = (GLfloat *)VB->ColorPtr[0]->Ptr;
   CMstride = VB->ColorPtr[0]->StrideB;
#endif
d351 4
a354 4
#if IDX & LIGHT_TWOSIDE
   VB->ColorPtr[1] = &store->LitColor[1];
   UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
#endif
d375 2
a376 3
#if IDX & LIGHT_TWOSIDE
	 UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
#endif
d381 2
a382 3
#if IDX & LIGHT_TWOSIDE
      COPY_3V(sum[1], base[1]);
#endif
d445 4
a448 1
#if IDX & LIGHT_TWOSIDE
a451 3
#else
	    continue;
#endif
d454 3
a456 3
#if IDX & LIGHT_TWOSIDE
	    ACC_SCALE_SCALAR_3V( sum[1], attenuation, light->_MatAmbient[1]);
#endif
d505 4
a508 4
#if IDX & LIGHT_TWOSIDE
      UNCLAMPED_FLOAT_TO_RGB_CHAN( Bcolor[j], sum[1] );
      Bcolor[j][3] = sumA[1];
#endif
d524 1
a524 1
   const GLuint nstride = VB->NormalPtr->stride;
a526 1
#if IDX & LIGHT_COLORMATERIAL
a527 1
#endif
a528 1
#if IDX & LIGHT_TWOSIDE
d530 2
a531 3
#endif
   const struct gl_light *light = ctx->Light.EnabledList.next;
   const GLuint *flags = VB->Flag;
d535 1
a535 1
   const GLuint *new_material_mask = VB->MaterialMask;
d537 1
a537 1
   const GLuint nr = VB->Count;
d539 2
a540 3
#ifdef TRACE
   fprintf(stderr, "%s\n", __FUNCTION__ );
#endif
d547 4
a550 4
#if IDX & LIGHT_COLORMATERIAL
   if (VB->ColorPtr[0]->Type != GL_FLOAT ||
       VB->ColorPtr[0]->Size != 4)
      import_color_material( ctx, stage );
d552 3
a554 3
   CMcolor = (GLfloat *)VB->ColorPtr[0]->Ptr;
   CMstride = VB->ColorPtr[0]->StrideB;
#endif
d557 2
a558 3
#if IDX & LIGHT_TWOSIDE
   VB->ColorPtr[1] = &store->LitColor[1];
#endif
d584 7
a590 7
#if IDX & LIGHT_TWOSIDE
      COPY_3V(base[1], light->_MatAmbient[1]);
      ACC_3V(base[1], ctx->Light._BaseColor[1]);
      UNCLAMPED_FLOAT_TO_RGB_CHAN( basechan[1], base[1]);
      UNCLAMPED_FLOAT_TO_CHAN(basechan[1][3],
			      ctx->Light.Material[1].Diffuse[3]);
#endif
d596 12
a607 9
#if IDX & LIGHT_TWOSIDE
	    GLfloat n_dot_h = -DOT3(normal, light->_h_inf_norm);
	    GLfloat sum[3];
	    COPY_3V(sum, base[1]);
	    ACC_SCALE_SCALAR_3V(sum, -n_dot_VP, light->_MatDiffuse[1]);
	    if (n_dot_h > 0.0F) {
	       GLfloat spec;
	       GET_SHINE_TAB_ENTRY( ctx->_ShineTable[1], n_dot_h, spec );
	       ACC_SCALE_SCALAR_3V(sum, spec, light->_MatSpecular[1]);
a608 3
	    UNCLAMPED_FLOAT_TO_RGB_CHAN(Bcolor[j], sum );
	    Bcolor[j][3] = basechan[1][3];
#endif
d623 1
a623 3
#if IDX & LIGHT_TWOSIDE
	    COPY_CHAN4(Bcolor[j], basechan[1]);
#endif
d635 2
a636 3
#if IDX & LIGHT_TWOSIDE
	 COPY_CHAN4(Bcolor[j], Bcolor[j-1]);
#endif
d652 1
a652 1
   const GLuint nstride = VB->NormalPtr->stride;
a654 1
#if IDX & LIGHT_COLORMATERIAL
a655 1
#endif
a656 1
#if IDX & LIGHT_TWOSIDE
d658 1
a658 2
#endif
   const GLuint *flags = VB->Flag;
d662 5
a666 2
   const GLuint nr = VB->Count;
   const struct gl_light *light;
a667 3
#ifdef TRACE
   fprintf(stderr, "%s\n", __FUNCTION__ );
#endif
d677 4
a680 4
#if IDX & LIGHT_COLORMATERIAL
   if (VB->ColorPtr[0]->Type != GL_FLOAT ||
       VB->ColorPtr[0]->Size != 4)
      import_color_material( ctx, stage );
d682 3
a684 3
   CMcolor = (GLfloat *)VB->ColorPtr[0]->Ptr;
   CMstride = VB->ColorPtr[0]->StrideB;
#endif
d687 2
a688 3
#if IDX & LIGHT_TWOSIDE
   VB->ColorPtr[1] = &store->LitColor[1];
#endif
d706 3
a708 3
#if IDX & LIGHT_TWOSIDE
	    UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
#endif
d711 1
d713 2
a714 3
#if IDX & LIGHT_TWOSIDE
	 COPY_3V(sum[1], ctx->Light._BaseColor[1]);
#endif
d720 2
a721 3
#if IDX & LIGHT_TWOSIDE
	    ACC_3V(sum[1], light->_MatAmbient[1]);
#endif
d735 1
a735 2
#if IDX & LIGHT_TWOSIDE
	    else {
a744 1
#endif
d750 4
a753 4
#if IDX & LIGHT_TWOSIDE
	 UNCLAMPED_FLOAT_TO_RGB_CHAN( Bcolor[j], sum[1] );
	 Bcolor[j][3] = sumA[1];
#endif
d766 2
a767 3
#if IDX & LIGHT_TWOSIDE
	 COPY_CHAN4(Bcolor[j], Bcolor[j-1]);
#endif
d793 1
a793 1
   const GLuint vstride = input->stride;
d795 1
a795 1
   const GLuint nstride = VB->NormalPtr->stride;
a797 1
#if IDX & LIGHT_COLORMATERIAL
d799 1
a799 2
#endif
   const GLuint *flags = VB->Flag;
d803 1
a803 1
   const GLuint nr = VB->Count;
d805 2
a806 3
#ifdef TRACE
   fprintf(stderr, "%s\n", __FUNCTION__ );
#endif
d813 2
a814 3
#if IDX & LIGHT_TWOSIDE
   VB->IndexPtr[1] = &store->LitIndex[1];
#endif
d820 2
a821 3
#if IDX & LIGHT_TWOSIDE
   indexResult[1] = VB->IndexPtr[1]->data;
#endif
d823 4
a826 4
#if IDX & LIGHT_COLORMATERIAL
   if (VB->ColorPtr[0]->Type != GL_FLOAT ||
       VB->ColorPtr[0]->Size != 4)
      import_color_material( ctx, stage );
d828 3
a830 3
   CMcolor = (GLfloat *)VB->ColorPtr[0]->Ptr;
   CMstride = VB->ColorPtr[0]->StrideB;
#endif
d852 3
a854 3
#if IDX & LIGHT_TWOSIDE
      diffuse[1] = specular[1] = 0.0F;
#endif
d907 2
a908 1
#if IDX & LIGHT_TWOSIDE
a911 3
#else
	    continue;
#endif
@


1.1.1.1
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@@


1.1.1.2
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/extras/Mesa/src/tnl/t_vb_lighttmp.h,v 1.5 2003/11/04 15:16:29 tsi Exp $ */
d4 1
a4 1
 * Version:  4.1
d27 2
a28 2
 *    Brian Paul
 *    Keith Whitwell <keith@@tungstengraphics.com>
d34 3
a36 3
#  define NSTRIDE nstride /*(3 * sizeof(GLfloat))*/
#  define CHECK_MATERIAL(x)  (flags[x] & VERT_BIT_MATERIAL)
#  define CHECK_END_VB(x)    (flags[x] & VERT_BIT_END_VB)
d39 2
a40 2
#    define CHECK_COLOR_MATERIAL(x) (flags[x] & VERT_BIT_COLOR0)
#    define CHECK_VALIDATE(x) (flags[x] & (VERT_BIT_COLOR0|VERT_BIT_MATERIAL))
d42 1
a42 1
     ((flags[x] & (VERT_BIT_COLOR0|VERT_BIT_NORMAL|VERT_BIT_END_VB|VERT_BIT_MATERIAL)) == VERT_BIT_NORMAL)
d44 1
a44 1
     ((flags[x] & (VERT_BIT_COLOR0|VERT_BIT_NORMAL|VERT_BIT_END_VB|VERT_BIT_MATERIAL)) == 0)
d48 1
a48 1
#    define CHECK_VALIDATE(x) (flags[x] & (VERT_BIT_MATERIAL))
d50 1
a50 1
      ((flags[x] & (VERT_BIT_NORMAL|VERT_BIT_END_VB|VERT_BIT_MATERIAL)) == VERT_BIT_NORMAL)
d52 1
a52 1
      ((flags[x] & (VERT_BIT_NORMAL|VERT_BIT_END_VB|VERT_BIT_MATERIAL)) == 0)
a81 2
/* define TRACE if to trace lighting code */

a82 6
/*
 * ctx is the current context
 * VB is the vertex buffer
 * stage is the lighting stage-private data
 * input is the vector of eye or object-space vertex coordinates
 */
d91 1
d94 1
a94 1
   const GLuint vstride = input->stride;
d96 1
a96 1
   const GLuint nstride = VB->NormalPtr->stride;
a99 1
#if IDX & LIGHT_COLORMATERIAL
a100 1
#endif
a102 1
#if IDX & LIGHT_TWOSIDE
a103 1
#endif
a104 1
#if IDX & LIGHT_TWOSIDE
d106 1
a106 1
#endif
d108 2
a109 2
   const GLuint nr = VB->Count;
   const GLuint *flags = VB->Flag;
d111 1
a111 1
   const GLuint *new_material_mask = VB->MaterialMask;
a116 3
#ifdef TRACE
   fprintf(stderr, "%s\n", __FUNCTION__ );
#endif
d118 10
a127 4
#if IDX & LIGHT_COLORMATERIAL
   if (VB->ColorPtr[0]->Type != GL_FLOAT ||
       VB->ColorPtr[0]->Size != 4)
      import_color_material( ctx, stage );
d129 3
a131 3
   CMcolor = (GLfloat *) VB->ColorPtr[0]->Ptr;
   CMstride = VB->ColorPtr[0]->StrideB;
#endif
d137 5
a141 5
#if IDX & LIGHT_TWOSIDE
   VB->ColorPtr[1] = &store->LitColor[1];
   VB->SecondaryColorPtr[1] = &store->LitSecondary[1];
   UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
#endif
d164 2
a165 3
#if IDX & LIGHT_TWOSIDE
	 UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
#endif
d171 4
a174 4
#if IDX & LIGHT_TWOSIDE
      COPY_3V(sum[1], base[1]);
      ZERO_3V(spec[1]);
#endif
d235 3
a237 1
#if IDX & LIGHT_TWOSIDE
a240 3
#else
	    continue;
#endif
d243 3
a245 3
#if IDX & LIGHT_TWOSIDE
	    ACC_SCALE_SCALAR_3V( sum[1], attenuation, light->_MatAmbient[1]);
#endif
d292 5
a296 5
#if IDX & LIGHT_TWOSIDE
      UNCLAMPED_FLOAT_TO_RGB_CHAN( Bcolor[j], sum[1] );
      UNCLAMPED_FLOAT_TO_RGB_CHAN( Bspec[j], spec[1] );
      Bcolor[j][3] = sumA[1];
#endif
d312 1
a312 1
   const GLuint vstride = input->stride;
d314 1
a314 1
   const GLuint nstride = VB->NormalPtr->stride;
a317 1
#if IDX & LIGHT_COLORMATERIAL
a318 1
#endif
a320 1
#if IDX & LIGHT_TWOSIDE
d322 2
a323 2
#endif
   const GLuint *flags = VB->Flag;
d326 2
a327 2
   const GLuint *new_material_mask = VB->MaterialMask;
   const GLuint nr = VB->Count;
d329 2
a330 3
#ifdef TRACE
   fprintf(stderr, "%s\n", __FUNCTION__ );
#endif
d336 2
a337 4
#if IDX & LIGHT_COLORMATERIAL
   if (VB->ColorPtr[0]->Type != GL_FLOAT ||
       VB->ColorPtr[0]->Size != 4)
      import_color_material( ctx, stage );
d339 8
a346 3
   CMcolor = (GLfloat *)VB->ColorPtr[0]->Ptr;
   CMstride = VB->ColorPtr[0]->StrideB;
#endif
d351 4
a354 4
#if IDX & LIGHT_TWOSIDE
   VB->ColorPtr[1] = &store->LitColor[1];
   UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
#endif
d375 2
a376 3
#if IDX & LIGHT_TWOSIDE
	 UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
#endif
d381 2
a382 3
#if IDX & LIGHT_TWOSIDE
      COPY_3V(sum[1], base[1]);
#endif
d445 4
a448 1
#if IDX & LIGHT_TWOSIDE
a451 3
#else
	    continue;
#endif
d454 3
a456 3
#if IDX & LIGHT_TWOSIDE
	    ACC_SCALE_SCALAR_3V( sum[1], attenuation, light->_MatAmbient[1]);
#endif
d505 4
a508 4
#if IDX & LIGHT_TWOSIDE
      UNCLAMPED_FLOAT_TO_RGB_CHAN( Bcolor[j], sum[1] );
      Bcolor[j][3] = sumA[1];
#endif
d524 1
a524 1
   const GLuint nstride = VB->NormalPtr->stride;
a526 1
#if IDX & LIGHT_COLORMATERIAL
a527 1
#endif
a528 1
#if IDX & LIGHT_TWOSIDE
d530 2
a531 3
#endif
   const struct gl_light *light = ctx->Light.EnabledList.next;
   const GLuint *flags = VB->Flag;
d535 1
a535 1
   const GLuint *new_material_mask = VB->MaterialMask;
d537 1
a537 1
   const GLuint nr = VB->Count;
d539 2
a540 3
#ifdef TRACE
   fprintf(stderr, "%s\n", __FUNCTION__ );
#endif
d547 4
a550 4
#if IDX & LIGHT_COLORMATERIAL
   if (VB->ColorPtr[0]->Type != GL_FLOAT ||
       VB->ColorPtr[0]->Size != 4)
      import_color_material( ctx, stage );
d552 3
a554 3
   CMcolor = (GLfloat *)VB->ColorPtr[0]->Ptr;
   CMstride = VB->ColorPtr[0]->StrideB;
#endif
d557 2
a558 3
#if IDX & LIGHT_TWOSIDE
   VB->ColorPtr[1] = &store->LitColor[1];
#endif
d584 7
a590 7
#if IDX & LIGHT_TWOSIDE
      COPY_3V(base[1], light->_MatAmbient[1]);
      ACC_3V(base[1], ctx->Light._BaseColor[1]);
      UNCLAMPED_FLOAT_TO_RGB_CHAN( basechan[1], base[1]);
      UNCLAMPED_FLOAT_TO_CHAN(basechan[1][3],
			      ctx->Light.Material[1].Diffuse[3]);
#endif
d596 12
a607 9
#if IDX & LIGHT_TWOSIDE
	    GLfloat n_dot_h = -DOT3(normal, light->_h_inf_norm);
	    GLfloat sum[3];
	    COPY_3V(sum, base[1]);
	    ACC_SCALE_SCALAR_3V(sum, -n_dot_VP, light->_MatDiffuse[1]);
	    if (n_dot_h > 0.0F) {
	       GLfloat spec;
	       GET_SHINE_TAB_ENTRY( ctx->_ShineTable[1], n_dot_h, spec );
	       ACC_SCALE_SCALAR_3V(sum, spec, light->_MatSpecular[1]);
a608 3
	    UNCLAMPED_FLOAT_TO_RGB_CHAN(Bcolor[j], sum );
	    Bcolor[j][3] = basechan[1][3];
#endif
d623 1
a623 3
#if IDX & LIGHT_TWOSIDE
	    COPY_CHAN4(Bcolor[j], basechan[1]);
#endif
d635 2
a636 3
#if IDX & LIGHT_TWOSIDE
	 COPY_CHAN4(Bcolor[j], Bcolor[j-1]);
#endif
d652 1
a652 1
   const GLuint nstride = VB->NormalPtr->stride;
a654 1
#if IDX & LIGHT_COLORMATERIAL
a655 1
#endif
a656 1
#if IDX & LIGHT_TWOSIDE
d658 1
a658 2
#endif
   const GLuint *flags = VB->Flag;
d662 5
a666 2
   const GLuint nr = VB->Count;
   const struct gl_light *light;
a667 3
#ifdef TRACE
   fprintf(stderr, "%s\n", __FUNCTION__ );
#endif
d677 4
a680 4
#if IDX & LIGHT_COLORMATERIAL
   if (VB->ColorPtr[0]->Type != GL_FLOAT ||
       VB->ColorPtr[0]->Size != 4)
      import_color_material( ctx, stage );
d682 3
a684 3
   CMcolor = (GLfloat *)VB->ColorPtr[0]->Ptr;
   CMstride = VB->ColorPtr[0]->StrideB;
#endif
d687 2
a688 3
#if IDX & LIGHT_TWOSIDE
   VB->ColorPtr[1] = &store->LitColor[1];
#endif
d706 3
a708 3
#if IDX & LIGHT_TWOSIDE
	    UNCLAMPED_FLOAT_TO_CHAN(sumA[1], ctx->Light.Material[1].Diffuse[3]);
#endif
d711 1
d713 2
a714 3
#if IDX & LIGHT_TWOSIDE
	 COPY_3V(sum[1], ctx->Light._BaseColor[1]);
#endif
d720 2
a721 3
#if IDX & LIGHT_TWOSIDE
	    ACC_3V(sum[1], light->_MatAmbient[1]);
#endif
d735 1
a735 2
#if IDX & LIGHT_TWOSIDE
	    else {
a744 1
#endif
d750 4
a753 4
#if IDX & LIGHT_TWOSIDE
	 UNCLAMPED_FLOAT_TO_RGB_CHAN( Bcolor[j], sum[1] );
	 Bcolor[j][3] = sumA[1];
#endif
d766 2
a767 3
#if IDX & LIGHT_TWOSIDE
	 COPY_CHAN4(Bcolor[j], Bcolor[j-1]);
#endif
d793 1
a793 1
   const GLuint vstride = input->stride;
d795 1
a795 1
   const GLuint nstride = VB->NormalPtr->stride;
a797 1
#if IDX & LIGHT_COLORMATERIAL
d799 1
a799 2
#endif
   const GLuint *flags = VB->Flag;
d803 1
a803 1
   const GLuint nr = VB->Count;
d805 2
a806 3
#ifdef TRACE
   fprintf(stderr, "%s\n", __FUNCTION__ );
#endif
d813 2
a814 3
#if IDX & LIGHT_TWOSIDE
   VB->IndexPtr[1] = &store->LitIndex[1];
#endif
d820 2
a821 3
#if IDX & LIGHT_TWOSIDE
   indexResult[1] = VB->IndexPtr[1]->data;
#endif
d823 4
a826 4
#if IDX & LIGHT_COLORMATERIAL
   if (VB->ColorPtr[0]->Type != GL_FLOAT ||
       VB->ColorPtr[0]->Size != 4)
      import_color_material( ctx, stage );
d828 3
a830 3
   CMcolor = (GLfloat *)VB->ColorPtr[0]->Ptr;
   CMstride = VB->ColorPtr[0]->StrideB;
#endif
d852 3
a854 3
#if IDX & LIGHT_TWOSIDE
      diffuse[1] = specular[1] = 0.0F;
#endif
d907 2
a908 1
#if IDX & LIGHT_TWOSIDE
a911 3
#else
	    continue;
#endif
@

