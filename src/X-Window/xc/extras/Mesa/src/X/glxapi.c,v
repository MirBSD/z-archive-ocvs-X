head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.28.25;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.01.03;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.01.03;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.20.05;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.29.25;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.04.52;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@
/*
 * Mesa 3-D graphics library
 * Version:  3.3
 * 
 * Copyright (C) 1999-2000  Brian Paul   All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * This is the GLX API dispatcher.  Calls to the glX* functions are
 * either routed to real (SGI / Utah) GLX encoders or to Mesa's
 * pseudo-GLX module.
 */


#include <assert.h>
#include <stdlib.h>
#include "glapi.h"
#include "glxapi.h"


/*
 * XXX - this really shouldn't be here.
 * Instead, add -DUSE_MESA_GLX to the compiler flags when needed.
 */
#define USE_MESA_GLX 1


/* Rather than include possibly non-existant headers... */
#ifdef USE_SGI_GLX
extern struct _glxapi_table *_sgi_GetGLXDispatchtable(void);
#endif
#ifdef USE_UTAH_GLX
extern struct _glxapi_table *_utah_GetGLXDispatchTable(void);
#endif
#ifdef USE_MESA_GLX
extern struct _glxapi_table *_mesa_GetGLXDispatchTable(void);
#endif



struct display_dispatch {
   Display *Dpy;
   struct _glxapi_table *Table;
   struct display_dispatch *Next;
};

static struct display_dispatch *DispatchList = NULL;


static struct _glxapi_table *
get_dispatch(Display *dpy)
{
   static Display *prevDisplay = NULL;
   static struct _glxapi_table *prevTable = NULL;

   if (!dpy)
      return NULL;

   /* try cached display */
   if (dpy == prevDisplay) {
      return prevTable;
   }

   /* search list of display/dispatch pairs for this display */
   {
      const struct display_dispatch *d = DispatchList;
      while (d) {
         if (d->Dpy == dpy) {
            prevDisplay = dpy;
            prevTable = d->Table;
            return d->Table;  /* done! */
         }
         d = d->Next;
      }
   }

   /* A new display, determine if we should use real GLX (SGI / Utah)
    * or Mesa's pseudo-GLX.
    */
   {
      struct _glxapi_table *t = NULL;

#if defined(USE_SGI_GLX) || defined(USE_UTAH_GLX)
      if (!getenv("MESA_FORCE_SOFTX")) {
         int ignore;
         if (XQueryExtension( dpy, "GLX", &ignore, &ignore, &ignore )) {
            /* the X server has the GLX extension */
#if defined(USE_SGI_GLX)
            t = _sgi_GetGLXDispatchtable();
#elif defined(USE_UTAH_GLX)
            t = _utah_GetGLXDispatchTable();
#endif
         }
      }
#endif

#if defined(USE_MESA_GLX)
      if (!t) {
         t = _mesa_GetGLXDispatchTable();
         assert(t);  /* this has to work */
      }
#endif

      if (t) {
         struct display_dispatch *d;
         d = (struct display_dispatch *) malloc(sizeof(struct display_dispatch));
         if (d) {
            d->Dpy = dpy;
            d->Table = t;
            /* insert at head of list */
            d->Next = DispatchList;
            DispatchList = d;
            /* update cache */
            prevDisplay = dpy;
            prevTable = t;
            return t;
         }
      }
   }

   /* If we get here that means we can't use real GLX on this display
    * and the Mesa pseudo-GLX software renderer wasn't compiled in.
    * Or, we ran out of memory!
    */
   return NULL;
}



/* Set by glXMakeCurrent() and glXMakeContextCurrent() only */
static Display *CurrentDisplay = NULL;
static GLXContext CurrentContext = 0;
static GLXDrawable CurrentDrawable = 0;
static GLXDrawable CurrentReadDrawable = 0;



/*
 * GLX API entrypoints
 */


XVisualInfo *glXChooseVisual(Display *dpy, int screen, int *list)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return NULL;
   return (t->ChooseVisual)(dpy, screen, list);
}


void glXCopyContext(Display *dpy, GLXContext src, GLXContext dst, unsigned long mask)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return;
   (t->CopyContext)(dpy, src, dst, mask);
}


GLXContext glXCreateContext(Display *dpy, XVisualInfo *visinfo, GLXContext shareList, Bool direct)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return 0;
   return (t->CreateContext)(dpy, visinfo, shareList, direct);
}


GLXPixmap glXCreateGLXPixmap(Display *dpy, XVisualInfo *visinfo, Pixmap pixmap)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return 0;
   return (t->CreateGLXPixmap)(dpy, visinfo, pixmap);
}


void glXDestroyContext(Display *dpy, GLXContext ctx)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return;
   (t->DestroyContext)(dpy, ctx);
}


void glXDestroyGLXPixmap(Display *dpy, GLXPixmap pixmap)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return;
   (t->DestroyGLXPixmap)(dpy, pixmap);
}


int glXGetConfig(Display *dpy, XVisualInfo *visinfo, int attrib, int *value)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return GLX_NO_EXTENSION;
   return (t->GetConfig)(dpy, visinfo, attrib, value);
}


GLXContext glXGetCurrentContext(void)
{
   return CurrentContext;
}


GLXDrawable glXGetCurrentDrawable(void)
{
   return CurrentDrawable;
}


Bool glXIsDirect(Display *dpy, GLXContext ctx)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return False;
   return (t->IsDirect)(dpy, ctx);
}


Bool glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ctx)
{
   Bool b;
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return False;
   b = (*t->MakeCurrent)(dpy, drawable, ctx);
   if (b) {
      CurrentDisplay = dpy;
      CurrentContext = ctx;
      CurrentDrawable = drawable;
      CurrentReadDrawable = drawable;
   }
   return b;
}


Bool glXQueryExtension(Display *dpy, int *errorb, int *event)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return False;
   return (t->QueryExtension)(dpy, errorb, event);
}


Bool glXQueryVersion(Display *dpy, int *maj, int *min)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return False;
   return (t->QueryVersion)(dpy, maj, min);
}


void glXSwapBuffers(Display *dpy, GLXDrawable drawable)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return;
   (t->SwapBuffers)(dpy, drawable);
}


void glXUseXFont(Font font, int first, int count, int listBase)
{
   struct _glxapi_table *t = get_dispatch(CurrentDisplay);
   if (!t)
      return;
   (t->UseXFont)(font, first, count, listBase);
}


void glXWaitGL(void)
{
   struct _glxapi_table *t = get_dispatch(CurrentDisplay);
   if (!t)
      return;
   (t->WaitGL)();
}


void glXWaitX(void)
{
   struct _glxapi_table *t = get_dispatch(CurrentDisplay);
   if (!t)
      return;
   (t->WaitX)();
}



#ifdef GLX_VERSION_1_1

const char *glXGetClientString(Display *dpy, int name)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return NULL;
   return (t->GetClientString)(dpy, name);
}


const char *glXQueryExtensionsString(Display *dpy, int screen)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return NULL;
   return (t->QueryExtensionsString)(dpy, screen);
}


const char *glXQueryServerString(Display *dpy, int screen, int name)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return NULL;
   return (t->QueryServerString)(dpy, screen, name);
}

#endif



#ifdef GLX_VERSION_1_2
Display *glXGetCurrentDisplay(void)
{
   return CurrentDisplay;
}
#endif



#ifdef GLX_VERSION_1_3

GLXFBConfig *glXChooseFBConfig(Display *dpy, int screen, const int *attribList, int *nitems)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return 0;
   return (t->ChooseFBConfig)(dpy, screen, attribList, nitems);
}


GLXContext glXCreateNewContext(Display *dpy, GLXFBConfig config, int renderType, GLXContext shareList, Bool direct)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return 0;
   return (t->CreateNewContext)(dpy, config, renderType, shareList, direct);
}


GLXPbuffer glXCreatePbuffer(Display *dpy, GLXFBConfig config, const int *attribList)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return 0;
   return (t->CreatePbuffer)(dpy, config, attribList);
}


GLXPixmap glXCreatePixmap(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attribList)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return 0;
   return (t->CreatePixmap)(dpy, config, pixmap, attribList);
}


GLXWindow glXCreateWindow(Display *dpy, GLXFBConfig config, Window win, const int *attribList)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return 0;
   return (t->CreateWindow)(dpy, config, win, attribList);
}


void glXDestroyPbuffer(Display *dpy, GLXPbuffer pbuf)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return;
   (t->DestroyPbuffer)(dpy, pbuf);
}


void glXDestroyPixmap(Display *dpy, GLXPixmap pixmap)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return;
   (t->DestroyPixmap)(dpy, pixmap);
}


void glXDestroyWindow(Display *dpy, GLXWindow window)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return;
   (t->DestroyWindow)(dpy, window);
}


GLXDrawable glXGetCurrentReadDrawable(void)
{
   return CurrentReadDrawable;
}


int glXGetFBConfigAttrib(Display *dpy, GLXFBConfig config, int attribute, int *value)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return GLX_NO_EXTENSION;
   return (t->GetFBConfigAttrib)(dpy, config, attribute, value);
}


GLXFBConfig *glXGetFBConfigs(Display *dpy, int screen, int *nelements)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return 0;
   return (t->GetFBConfigs)(dpy, screen, nelements);
}

void glXGetSelectedEvent(Display *dpy, GLXDrawable drawable, unsigned long *mask)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return;
   (t->GetSelectedEvent)(dpy, drawable, mask);
}


XVisualInfo *glXGetVisualFromFBConfig(Display *dpy, GLXFBConfig config)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return NULL;
   return (t->GetVisualFromFBConfig)(dpy, config);
}


Bool glXMakeContextCurrent(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   Bool b;
   if (!t)
      return False;
   b = (t->MakeContextCurrent)(dpy, draw, read, ctx);
   if (b) {
      CurrentDisplay = dpy;
      CurrentContext = ctx;
      CurrentDrawable = draw;
      CurrentReadDrawable = read;
   }
   return b;
}


int glXQueryContext(Display *dpy, GLXContext ctx, int attribute, int *value)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   assert(t);
   if (!t)
      return 0; /* XXX correct? */
   return (t->QueryContext)(dpy, ctx, attribute, value);
}


void glXQueryDrawable(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return;
   (t->QueryDrawable)(dpy, draw, attribute, value);
}


void glXSelectEvent(Display *dpy, GLXDrawable drawable, unsigned long mask)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return;
   (t->SelectEvent)(dpy, drawable, mask);
}

#endif /* GLX_VERSION_1_3 */


#ifdef GLX_EXT_import_context

void glXFreeContextEXT(Display *dpy, GLXContext context)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return;
   (t->FreeContextEXT)(dpy, context);
}


GLXContextID glXGetContextIDEXT(const GLXContext context)
{
   /* XXX is this function right? */
   struct _glxapi_table *t = get_dispatch(CurrentDisplay);
   if (!t)
      return 0;
   return (t->GetContextIDEXT)(context);
}


Display *glXGetCurrentDisplayEXT(void)
{
   return CurrentDisplay;
}


GLXContext glXImportContextEXT(Display *dpy, GLXContextID contextID)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return 0;
   return (t->ImportContextEXT)(dpy, contextID);
}

int glXQueryContextInfoEXT(Display *dpy, GLXContext context, int attribute,int *value)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return 0;  /* XXX ok? */
   return (t->QueryContextInfoEXT)(dpy, context, attribute, value);
}

#endif


#ifdef GLX_SGI_video_sync

int glXGetVideoSyncSGI(unsigned int *count)
{
   struct _glxapi_table *t = get_dispatch(CurrentDisplay);
   if (!t)
      return 0;
   return (t->GetVideoSyncSGI)(count);
}


int glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *count)
{
   struct _glxapi_table *t = get_dispatch(CurrentDisplay);
   if (!t)
      return 0;
   return (t->WaitVideoSyncSGI)(divisor, remainder, count);
}

#endif


#ifdef GLX_MESA_copy_sub_buffer

void glXCopySubBufferMESA(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return;
   (t->CopySubBufferMESA)(dpy, drawable, x, y, width, height);
}

#endif


#ifdef GLX_MESA_release_buffers

Bool glXReleaseBuffersMESA(Display *dpy, Window w)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return False;
   return (t->ReleaseBuffersMESA)(dpy, w);
}

#endif


#ifdef GLX_MESA_pixmap_colormap

GLXPixmap glXCreateGLXPixmapMESA(Display *dpy, XVisualInfo *visinfo, Pixmap pixmap, Colormap cmap)
{
   struct _glxapi_table *t = get_dispatch(dpy);
   if (!t)
      return 0;
   return (t->CreateGLXPixmapMESA)(dpy, visinfo, pixmap, cmap);
}

#endif


#ifdef GLX_MESA_set_3dfx_mode

GLboolean glXSet3DfxModeMESA(GLint mode)
{
   struct _glxapi_table *t = get_dispatch(CurrentDisplay);
   if (!t)
      return False;
   return (t->Set3DfxModeMESA)(mode);
}

#endif



/**********************************************************************/
/* GLX API management functions                                       */
/**********************************************************************/


const char *
_glxapi_get_version(void)
{
   return "1.3";
}


/*
 * Return array of extension strings.
 */
const char **
_glxapi_get_extensions(void)
{
   static const char *extensions[] = {
#ifdef GLX_EXT_import_context
      "GLX_EXT_import_context",
#endif
#ifdef GLX_SGI_video_sync
      "GLX_SGI_video_sync",
#endif
#ifdef GLX_MESA_copy_sub_buffer
      "GLX_MESA_copy_sub_buffer",
#endif
#ifdef GLX_MESA_release_buffers
      "GLX_MESA_release_buffers",
#endif
#ifdef GLX_MESA_pixmap_colormap
      "GLX_MESA_pixmap_colormap",
#endif
#ifdef GLX_MESA_set_3dfx_mode
      "GLX_MESA_set_3dfx_mode",
#endif
      NULL
   };
   return extensions;
}


/*
 * Return size of the GLX dispatch table, in entries, not bytes.
 */
GLuint
_glxapi_get_dispatch_table_size(void)
{
   return sizeof(struct _glxapi_table) / sizeof(void *);
}


static int
generic_no_op_func(void)
{
   return 0;
}


/*
 * Initialize all functions in given dispatch table to be no-ops
 */
void
_glxapi_set_no_op_table(struct _glxapi_table *t)
{
   GLuint n = _glxapi_get_dispatch_table_size();
   GLuint i;
   void **dispatch = (void **) t;
   for (i = 0; i < n; i++) {
      dispatch[i] = (void *) generic_no_op_func;
   }
}



struct name_address_pair {
   const char *Name;
   GLvoid *Address;
};

static struct name_address_pair GLX_functions[] = {
   { "glXChooseVisual", (GLvoid *) glXChooseVisual },
   { "glXCopyContext", (GLvoid *) glXCopyContext },
   { "glXCreateContext", (GLvoid *) glXCreateContext },
   { "glXCreateGLXPixmap", (GLvoid *) glXCreateGLXPixmap },
   { "glXDestroyContext", (GLvoid *) glXDestroyContext },
   { "glXDestroyGLXPixmap", (GLvoid *) glXDestroyGLXPixmap },
   { "glXGetConfig", (GLvoid *) glXGetConfig },
   { "glXGetCurrentContext", (GLvoid *) glXGetCurrentContext },
   { "glXGetCurrentDrawable", (GLvoid *) glXGetCurrentDrawable },
   { "glXIsDirect", (GLvoid *) glXIsDirect },
   { "glXMakeCurrent", (GLvoid *) glXMakeCurrent },
   { "glXQueryExtension", (GLvoid *) glXQueryExtension },
   { "glXQueryVersion", (GLvoid *) glXQueryVersion },
   { "glXSwapBuffers", (GLvoid *) glXSwapBuffers },
   { "glXUseXFont", (GLvoid *) glXUseXFont },
   { "glXWaitGL", (GLvoid *) glXWaitGL },
   { "glXWaitX", (GLvoid *) glXWaitX },

#ifdef GLX_VERSION_1_1
   { "glXGetClientString", (GLvoid *) glXGetClientString },
   { "glXQueryExtensionsString", (GLvoid *) glXQueryExtensionsString },
   { "glXQueryServerString", (GLvoid *) glXQueryServerString },
#endif

#ifdef GLX_VERSION_1_2
   { "glXGetCurrentDisplay", (GLvoid *) glXGetCurrentDisplay },
#endif

#ifdef GLX_VERSION_1_3
   { "glXChooseFBConfig", (GLvoid *) glXChooseFBConfig },
   { "glXCreateNewContext", (GLvoid *) glXCreateNewContext },
   { "glXCreatePbuffer", (GLvoid *) glXCreatePbuffer },
   { "glXCreatePixmap", (GLvoid *) glXCreatePixmap },
   { "glXCreateWindow", (GLvoid *) glXCreateWindow },
   { "glXDestroyPbuffer", (GLvoid *) glXDestroyPbuffer },
   { "glXDestroyPixmap", (GLvoid *) glXDestroyPixmap },
   { "glXDestroyWindow", (GLvoid *) glXDestroyWindow },
   { "glXGetCurrentReadDrawable", (GLvoid *) glXGetCurrentReadDrawable },
   { "glXGetFBConfigAttrib", (GLvoid *) glXGetFBConfigAttrib },
   { "glXGetSelectedEvent", (GLvoid *) glXGetSelectedEvent },
   { "glXGetVisualFromFBConfig", (GLvoid *) glXGetVisualFromFBConfig },
   { "glXMakeContextCurrent", (GLvoid *) glXMakeContextCurrent },
   { "glXQueryContext", (GLvoid *) glXQueryContext },
   { "glXQueryDrawable", (GLvoid *) glXQueryDrawable },
   { "glXSelectEvent", (GLvoid *) glXSelectEvent },
#endif

#ifdef GLX_SGI_video_sync
   { "glXGetVideoSyncSGI", (GLvoid *) glXGetVideoSyncSGI },
   { "glXWaitVideoSyncSGI", (GLvoid *) glXWaitVideoSyncSGI },
#endif

#ifdef GLX_MESA_copy_sub_buffer
   { "glXCopySubBufferMESA", (GLvoid *) glXCopySubBufferMESA },
#endif

#ifdef GLX_MESA_release_buffers
   { "glXReleaseBuffersMESA", (GLvoid *) glXReleaseBuffersMESA },
#endif

#ifdef GLX_MESA_pixmap_colormap
   { "glXCreateGLXPixmapMESA", (GLvoid *) glXCreateGLXPixmapMESA },
#endif

#ifdef GLX_MESA_set_3dfx_mode
   { "glXSet3DfxModeMESA", (GLvoid *) glXSet3DfxModeMESA },
#endif

   { "glXGetProcAddressARB", (GLvoid *) glXGetProcAddressARB },

   { NULL, NULL }   /* end of list */
};



/*
 * Return address of named glX function, or NULL if not found.
 */
const GLvoid *
_glxapi_get_proc_address(const char *funcName)
{
   GLuint i;
   for (i = 0; GLX_functions[i].Name; i++) {
      if (strcmp(GLX_functions[i].Name, funcName) == 0)
         return GLX_functions[i].Address;
   }
   return NULL;
}



/*
 * This function does not get dispatched through the dispatch table
 * since it's really a "meta" function.
 */
void (*glXGetProcAddressARB(const GLubyte *procName))()
{
   typedef void (*gl_function)();
   gl_function f;

   f = (gl_function) _glxapi_get_proc_address((const char *) procName);
   if (f) {
      return f;
   }

   f = (gl_function) _glapi_get_proc_address((const char *) procName);
   return f;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d4 1
a4 1
 * Version:  4.0.2
d6 1
a6 1
 * Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
d29 2
a30 2
 * either routed to the real GLX encoders or to Mesa's pseudo-GLX functions.
 * See the glxapi.h file for more details.
a35 2
#include <stdio.h>
#include <string.h>
d40 15
a54 1
extern struct _glxapi_table *_real_GetGLXDispatchTable(void);
d56 2
a68 5
/* Display -> Dispatch caching */
static Display *prevDisplay = NULL;
static struct _glxapi_table *prevTable = NULL;


d72 3
d78 5
d96 1
a96 1
   /* A new display, determine if we should use real GLX
d102 2
a103 2
#ifdef GLX_BUILT_IN_XMESA
      if (!getenv("LIBGL_FORCE_XMESA")) {
d107 5
a111 1
            t = _real_GetGLXDispatchTable();
d116 1
a117 9
         /* Fallback to Mesa with Xlib driver */
#ifdef GLX_BUILT_IN_XMESA
         if (getenv("LIBGL_DEBUG")) {
            fprintf(stderr,
                    "libGL: server %s lacks the GLX extension.",
                    dpy->display_name);
            fprintf(stderr, " Using Mesa Xlib renderer.\n");
         }
#endif
d121 1
a147 13
#define GET_DISPATCH(DPY, TABLE)	\
   if (DPY == prevDisplay) {		\
      TABLE = prevTable;		\
   }					\
   else if (!DPY) {			\
      TABLE = NULL;			\
   }					\
   else {				\
      TABLE = get_dispatch(DPY);	\
   }

   

d150 1
a150 1
#ifndef GLX_BUILT_IN_XMESA
d152 3
a154 2
#define __glXGetCurrentContext() CurrentContext;
#endif
a160 1
/*** GLX_VERSION_1_0 ***/
d164 1
a164 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d173 1
a173 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d182 1
a182 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d191 1
a191 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d200 1
a200 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d209 1
a209 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d218 1
a218 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
a224 4
#ifdef GLX_BUILT_IN_XMESA
/* Use real libGL's glXGetCurrentContext() function */
#else
/* stand-alone Mesa */
a228 1
#endif
a230 4
#ifdef GLX_BUILT_IN_XMESA
/* Use real libGL's glXGetCurrentContext() function */
#else
/* stand-alone Mesa */
d233 1
a233 2
   __GLXcontext *gc = (__GLXcontext *) glXGetCurrentContext();
   return gc ? gc->currentDrawable : 0;
a234 1
#endif
d239 1
a239 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d249 2
a250 3
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t) {
a251 1
   }
a252 1
#ifndef  GLX_BUILT_IN_XMESA
d254 1
d256 2
a258 1
#endif
d265 1
a265 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d274 1
a274 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d283 1
a283 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d292 1
a292 3
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
d301 1
a301 3
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
d310 1
a310 3
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
d318 1
a318 1
/*** GLX_VERSION_1_1 ***/
d322 1
a322 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d331 1
a331 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d340 1
a340 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d346 2
a348 1
/*** GLX_VERSION_1_2 ***/
d350 1
a350 1
#if !defined(GLX_BUILT_IN_XMESA)
d353 1
a353 4
   /* Same code as in libGL's glxext.c */
   __GLXcontext *gc = (__GLXcontext *) glXGetCurrentContext();
   if (NULL == gc) return NULL;
   return gc->currentDpy;
d359 1
a359 1
/*** GLX_VERSION_1_3 ***/
d363 1
a363 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d372 1
a372 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d381 1
a381 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d390 1
a390 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d399 1
a399 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d408 1
a408 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d417 1
a417 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d426 1
a426 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
a432 3
#ifdef GLX_BUILT_IN_XMESA
/* Use the glXGetCurrentReadDrawable() function from libGL */
#else
d435 1
a435 2
   __GLXcontext *gc = (__GLXcontext *) glXGetCurrentContext();
   return gc ? gc->currentReadable : 0;
a436 1
#endif
d441 1
a441 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d450 1
a450 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d458 1
a458 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d467 1
a467 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d476 1
a477 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
a480 1
#ifndef GLX_BUILT_IN_XMESA
d482 1
d484 2
a486 1
#endif
d493 1
a493 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d503 1
a503 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d512 1
a512 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d518 1
d521 1
a521 1
/*** GLX_SGI_swap_control ***/
d523 1
a523 1
int glXSwapIntervalSGI(int interval)
d525 1
a525 3
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
d527 2
a528 2
      return 0;
   return (t->SwapIntervalSGI)(interval);
d532 1
a532 4

/*** GLX_SGI_video_sync ***/

int glXGetVideoSyncSGI(unsigned int *count)
d534 2
a535 3
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
d538 1
a538 1
   return (t->GetVideoSyncSGI)(count);
a540 9
int glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *count)
{
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->WaitVideoSyncSGI)(divisor, remainder, count);
}
d542 1
a542 18


/*** GLX_SGI_make_current_read ***/

Bool glXMakeCurrentReadSGI(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->MakeCurrentReadSGI)(dpy, draw, read, ctx);
}

#ifdef GLX_BUILT_IN_XMESA
/* Use glXGetCurrentReadDrawableSGI() from libGL */
#else
/* stand-alone Mesa */
GLXDrawable glXGetCurrentReadDrawableSGI(void)
d544 1
a544 1
   return glXGetCurrentReadDrawable();
a545 2
#endif

a546 53
#if defined(_VL_H)

GLXVideoSourceSGIX glXCreateGLXVideoSourceSGIX(Display *dpy, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->CreateGLXVideoSourceSGIX)(dpy, screen, server, path, nodeClass, drainNode);
}

void glXDestroyGLXVideoSourceSGIX(Display *dpy, GLXVideoSourceSGIX src)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->DestroyGLXVideoSourceSGIX)(dpy, src);
}

#endif


/*** GLX_EXT_import_context ***/

void glXFreeContextEXT(Display *dpy, GLXContext context)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (t->FreeContextEXT)(dpy, context);
}

#ifdef GLX_BUILT_IN_XMESA
/* Use real libGL's glXGetContextIDEXT() function */
#else
/* stand-alone Mesa */
GLXContextID glXGetContextIDEXT(const GLXContext context)
{
   return ((__GLXcontext *) context)->xid;
}
#endif

#ifdef GLX_BUILT_IN_XMESA
/* Use real libGL's glXGetCurrentDisplayEXT() function */
#else
/* stand-alone Mesa */
Display *glXGetCurrentDisplayEXT(void)
{
   return glXGetCurrentDisplay();
}
#endif
d550 1
a550 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d558 1
a558 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d564 1
d567 1
a567 1
/*** GLX_SGIX_fbconfig ***/
d569 1
a569 1
int glXGetFBConfigAttribSGIX(Display *dpy, GLXFBConfigSGIX config, int attribute, int *value)
d571 1
a571 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d574 1
a574 1
   return (t->GetFBConfigAttribSGIX)(dpy, config, attribute, value);
a576 8
GLXFBConfigSGIX *glXChooseFBConfigSGIX(Display *dpy, int screen, int *attrib_list, int *nelements)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->ChooseFBConfigSGIX)(dpy, screen, attrib_list, nelements);
}
d578 1
a578 1
GLXPixmap glXCreateGLXPixmapWithConfigSGIX(Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap)
d580 1
a580 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d583 1
a583 152
   return (t->CreateGLXPixmapWithConfigSGIX)(dpy, config, pixmap);
}

GLXContext glXCreateContextWithConfigSGIX(Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->CreateContextWithConfigSGIX)(dpy, config, render_type, share_list, direct);
}

XVisualInfo * glXGetVisualFromFBConfigSGIX(Display *dpy, GLXFBConfigSGIX config)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->GetVisualFromFBConfigSGIX)(dpy, config);
}

GLXFBConfigSGIX glXGetFBConfigFromVisualSGIX(Display *dpy, XVisualInfo *vis)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->GetFBConfigFromVisualSGIX)(dpy, vis);
}



/*** GLX_SGIX_pbuffer ***/

GLXPbufferSGIX glXCreateGLXPbufferSGIX(Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->CreateGLXPbufferSGIX)(dpy, config, width, height, attrib_list);
}

void glXDestroyGLXPbufferSGIX(Display *dpy, GLXPbufferSGIX pbuf)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (t->DestroyGLXPbufferSGIX)(dpy, pbuf);
}

int glXQueryGLXPbufferSGIX(Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->QueryGLXPbufferSGIX)(dpy, pbuf, attribute, value);
}

void glXSelectEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long mask)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (t->SelectEventSGIX)(dpy, drawable, mask);
}

void glXGetSelectedEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long *mask)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (t->GetSelectedEventSGIX)(dpy, drawable, mask);
}



/*** GLX_SGI_cushion ***/

void glXCushionSGI(Display *dpy, Window win, float cushion)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (t->CushionSGI)(dpy, win, cushion);
}



/*** GLX_SGIX_video_resize ***/

int glXBindChannelToWindowSGIX(Display *dpy, int screen, int channel , Window window)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->BindChannelToWindowSGIX)(dpy, screen, channel, window);
}

int glXChannelRectSGIX(Display *dpy, int screen, int channel, int x, int y, int w, int h)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->ChannelRectSGIX)(dpy, screen, channel, x, y, w, h);
}

int glXQueryChannelRectSGIX(Display *dpy, int screen, int channel, int *x, int *y, int *w, int *h)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->QueryChannelRectSGIX)(dpy, screen, channel, x, y, w, h);
}

int glXQueryChannelDeltasSGIX(Display *dpy, int screen, int channel, int *dx, int *dy, int *dw, int *dh)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->QueryChannelDeltasSGIX)(dpy, screen, channel, dx, dy, dw, dh);
}

int glXChannelRectSyncSGIX(Display *dpy, int screen, int channel, GLenum synctype)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->ChannelRectSyncSGIX)(dpy, screen, channel, synctype);
}



#if defined(_DM_BUFFER_H_)

Bool glXAssociateDMPbufferSGIX(Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return False;
   return (t->AssociateDMPbufferSGIX)(dpy, pbuffer, params, dmbuffer);
d589 1
a589 48
/*** GLX_SGIX_swap_group ***/

void glXJoinSwapGroupSGIX(Display *dpy, GLXDrawable drawable, GLXDrawable member)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (*t->JoinSwapGroupSGIX)(dpy, drawable, member);
}


/*** GLX_SGIX_swap_barrier ***/

void glXBindSwapBarrierSGIX(Display *dpy, GLXDrawable drawable, int barrier)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (*t->BindSwapBarrierSGIX)(dpy, drawable, barrier);
}

Bool glXQueryMaxSwapBarriersSGIX(Display *dpy, int screen, int *max)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return False;
   return (*t->QueryMaxSwapBarriersSGIX)(dpy, screen, max);
}



/*** GLX_SUN_get_transparent_index ***/

Status glXGetTransparentIndexSUN(Display *dpy, Window overlay, Window underlay, long *pTransparent)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return False;
   return (*t->GetTransparentIndexSUN)(dpy, overlay, underlay, pTransparent);
}



/*** GLX_MESA_copy_sub_buffer ***/
d593 1
a593 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d599 1
d602 1
a602 1
/*** GLX_MESA_release_buffers ***/
d606 1
a606 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d612 1
d615 1
a615 1
/*** GLX_MESA_pixmap_colormap ***/
d619 1
a619 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d625 1
d628 1
a628 1
/*** GLX_MESA_set_3dfx_mode ***/
d630 1
a630 1
Bool glXSet3DfxModeMESA(int mode)
d632 1
a632 3
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
d638 1
a638 29


/*** AGP memory allocation ***/

void *
glXAllocateMemoryNV( GLsizei size,
                     GLfloat readFrequency,
                     GLfloat writeFrequency,
                     GLfloat priority )
{
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
   if (!t)
      return NULL;
   return (t->AllocateMemoryNV)(size, readFrequency, writeFrequency, priority);
}


void 
glXFreeMemoryNV( GLvoid *pointer )
{
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (t->FreeMemoryNV)(pointer);
}
d717 1
a723 1
   /*** GLX_VERSION_1_0 ***/
d742 1
a742 1
   /*** GLX_VERSION_1_1 ***/
d746 1
d748 1
a748 1
   /*** GLX_VERSION_1_2 ***/
d750 1
d752 1
a752 1
   /*** GLX_VERSION_1_3 ***/
a762 1
   { "glXGetFBConfigs", (GLvoid *) glXGetFBConfigs },
d769 1
d771 1
a771 7
   /*** GLX_VERSION_1_4 ***/
   { "glXGetProcAddress", (GLvoid *) glXGetProcAddress },

   /*** GLX_SGI_swap_control ***/
   { "glXSwapIntervalSGI", (GLvoid *) glXSwapIntervalSGI },

   /*** GLX_SGI_video_sync ***/
d774 1
d776 3
a778 53
   /*** GLX_SGI_make_current_read ***/
   { "glXMakeCurrentReadSGI", (GLvoid *) glXMakeCurrentReadSGI },
   { "glXGetCurrentReadDrawableSGI", (GLvoid *) glXGetCurrentReadDrawableSGI },

   /*** GLX_SGIX_video_source ***/
#if defined(_VL_H)
   { "glXCreateGLXVideoSourceSGIX", (GLvoid *) glXCreateGLXVideoSourceSGIX },
   { "glXDestroyGLXVideoSourceSGIX", (GLvoid *) glXDestroyGLXVideoSourceSGIX },
#endif

   /*** GLX_EXT_import_context ***/
   { "glXFreeContextEXT", (GLvoid *) glXFreeContextEXT },
   { "glXGetContextIDEXT", (GLvoid *) glXGetContextIDEXT },
   { "glXGetCurrentDisplayEXT", (GLvoid *) glXGetCurrentDisplayEXT },
   { "glXImportContextEXT", (GLvoid *) glXImportContextEXT },
   { "glXQueryContextInfoEXT", (GLvoid *) glXQueryContextInfoEXT },

   /*** GLX_SGIX_fbconfig ***/
   { "glXGetFBConfigAttribSGIX", (GLvoid *) glXGetFBConfigAttribSGIX },
   { "glXChooseFBConfigSGIX", (GLvoid *) glXChooseFBConfigSGIX },
   { "glXCreateGLXPixmapWithConfigSGIX", (GLvoid *) glXCreateGLXPixmapWithConfigSGIX },
   { "glXCreateContextWithConfigSGIX", (GLvoid *) glXCreateContextWithConfigSGIX },
   { "glXGetVisualFromFBConfigSGIX", (GLvoid *) glXGetVisualFromFBConfigSGIX },
   { "glXGetFBConfigFromVisualSGIX", (GLvoid *) glXGetFBConfigFromVisualSGIX },

   /*** GLX_SGIX_pbuffer ***/
   { "glXCreateGLXPbufferSGIX", (GLvoid *) glXCreateGLXPbufferSGIX },
   { "glXDestroyGLXPbufferSGIX", (GLvoid *) glXDestroyGLXPbufferSGIX },
   { "glXQueryGLXPbufferSGIX", (GLvoid *) glXQueryGLXPbufferSGIX },
   { "glXSelectEventSGIX", (GLvoid *) glXSelectEventSGIX },
   { "glXGetSelectedEventSGIX", (GLvoid *) glXGetSelectedEventSGIX },

   /*** GLX_SGI_cushion ***/
   { "glXCushionSGI", (GLvoid *) glXCushionSGI },

   /*** GLX_SGIX_video_resize ***/
   { "glXBindChannelToWindowSGIX", (GLvoid *) glXBindChannelToWindowSGIX },
   { "glXChannelRectSGIX", (GLvoid *) glXChannelRectSGIX },
   { "glXQueryChannelRectSGIX", (GLvoid *) glXQueryChannelRectSGIX },
   { "glXQueryChannelDeltasSGIX", (GLvoid *) glXQueryChannelDeltasSGIX },
   { "glXChannelRectSyncSGIX", (GLvoid *) glXChannelRectSyncSGIX },

   /*** GLX_SGIX_dmbuffer **/
#if defined(_DM_BUFFER_H_)
   { "glXAssociateDMPbufferSGIX", (GLvoid *) glXAssociateDMPbufferSGIX },
#endif

   /*** GLX_SGIX_swap_group ***/
   { "glXJoinSwapGroupSGIX", (GLvoid *) glXJoinSwapGroupSGIX },

   /*** GLX_SGIX_swap_barrier ***/
   { "glXBindSwapBarrierSGIX", (GLvoid *) glXBindSwapBarrierSGIX },
   { "glXQueryMaxSwapBarriersSGIX", (GLvoid *) glXQueryMaxSwapBarriersSGIX },
d780 3
a782 2
   /*** GLX_SUN_get_transparent_index ***/
   { "glXGetTransparentIndexSUN", (GLvoid *) glXGetTransparentIndexSUN },
d784 1
a784 4
   /*** GLX_MESA_copy_sub_buffer ***/
   { "glXCopySubBufferMESA", (GLvoid *) glXCopySubBufferMESA },

   /*** GLX_MESA_pixmap_colormap ***/
d786 1
d788 1
a788 4
   /*** GLX_MESA_release_buffers ***/
   { "glXReleaseBuffersMESA", (GLvoid *) glXReleaseBuffersMESA },

   /*** GLX_MESA_set_3dfx_mode ***/
d790 1
a791 1
   /*** GLX_ARB_get_proc_address ***/
a793 4
   /*** GLX AGP memory allocation ***/
   { "glXAllocateMemoryNV", (GLvoid *) glXAllocateMemoryNV },
   { "glXFreeMemoryNV", (GLvoid *) glXFreeMemoryNV },

a830 7
}


/* GLX 1.4 */
void (*glXGetProcAddress(const GLubyte *procName))()
{
   return glXGetProcAddressARB(procName);
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d4 1
a4 1
 * Version:  4.0.4
d6 1
a6 1
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
d29 2
a30 2
 * either routed to the real GLX encoders or to Mesa's pseudo-GLX functions.
 * See the glxapi.h file for more details.
a35 2
#include <stdio.h>
#include <string.h>
d40 15
a54 1
extern struct _glxapi_table *_real_GetGLXDispatchTable(void);
d56 2
a68 5
/* Display -> Dispatch caching */
static Display *prevDisplay = NULL;
static struct _glxapi_table *prevTable = NULL;


d72 3
d78 5
d96 1
a96 1
   /* A new display, determine if we should use real GLX
d102 2
a103 2
#ifdef GLX_BUILT_IN_XMESA
      if (!getenv("LIBGL_FORCE_XMESA")) {
d107 5
a111 1
            t = _real_GetGLXDispatchTable();
d116 1
a117 9
         /* Fallback to Mesa with Xlib driver */
#ifdef GLX_BUILT_IN_XMESA
         if (getenv("LIBGL_DEBUG")) {
            fprintf(stderr,
                    "libGL: server %s lacks the GLX extension.",
                    dpy->display_name);
            fprintf(stderr, " Using Mesa Xlib renderer.\n");
         }
#endif
d121 1
a147 13
#define GET_DISPATCH(DPY, TABLE)	\
   if (DPY == prevDisplay) {		\
      TABLE = prevTable;		\
   }					\
   else if (!DPY) {			\
      TABLE = NULL;			\
   }					\
   else {				\
      TABLE = get_dispatch(DPY);	\
   }

   

d150 1
a150 1
#ifndef GLX_BUILT_IN_XMESA
d152 3
a154 2
#define __glXGetCurrentContext() CurrentContext;
#endif
a160 1
/*** GLX_VERSION_1_0 ***/
d164 1
a164 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d173 1
a173 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d182 1
a182 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d191 1
a191 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d200 1
a200 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d209 1
a209 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d218 1
a218 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
a224 4
#ifdef GLX_BUILT_IN_XMESA
/* Use real libGL's glXGetCurrentContext() function */
#else
/* stand-alone Mesa */
a228 1
#endif
a230 4
#ifdef GLX_BUILT_IN_XMESA
/* Use real libGL's glXGetCurrentContext() function */
#else
/* stand-alone Mesa */
d233 1
a233 2
   __GLXcontext *gc = (__GLXcontext *) glXGetCurrentContext();
   return gc ? gc->currentDrawable : 0;
a234 1
#endif
d239 1
a239 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d249 2
a250 3
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t) {
a251 1
   }
a252 1
#ifndef  GLX_BUILT_IN_XMESA
d254 1
d256 2
a258 1
#endif
d265 1
a265 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d274 1
a274 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d283 1
a283 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d292 1
a292 3
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
d301 1
a301 3
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
d310 1
a310 3
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
d318 1
a318 1
/*** GLX_VERSION_1_1 ***/
d322 1
a322 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d331 1
a331 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d340 1
a340 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d346 2
a348 1
/*** GLX_VERSION_1_2 ***/
d350 1
a350 1
#if !defined(GLX_BUILT_IN_XMESA)
d353 1
a353 4
   /* Same code as in libGL's glxext.c */
   __GLXcontext *gc = (__GLXcontext *) glXGetCurrentContext();
   if (NULL == gc) return NULL;
   return gc->currentDpy;
d359 1
a359 1
/*** GLX_VERSION_1_3 ***/
d363 1
a363 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d372 1
a372 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d381 1
a381 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d390 1
a390 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d399 1
a399 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d408 1
a408 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d417 1
a417 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d426 1
a426 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
a432 3
#ifdef GLX_BUILT_IN_XMESA
/* Use the glXGetCurrentReadDrawable() function from libGL */
#else
d435 1
a435 2
   __GLXcontext *gc = (__GLXcontext *) glXGetCurrentContext();
   return gc ? gc->currentReadable : 0;
a436 1
#endif
d441 1
a441 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d450 1
a450 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d458 1
a458 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d467 1
a467 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d476 1
a477 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
a480 1
#ifndef GLX_BUILT_IN_XMESA
d482 1
d484 2
a486 1
#endif
d493 1
a493 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d503 1
a503 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d512 1
a512 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d518 1
d521 1
a521 1
/*** GLX_SGI_swap_control ***/
d523 1
a523 1
int glXSwapIntervalSGI(int interval)
d525 1
a525 3
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
d527 2
a528 2
      return 0;
   return (t->SwapIntervalSGI)(interval);
d532 1
a532 4

/*** GLX_SGI_video_sync ***/

int glXGetVideoSyncSGI(unsigned int *count)
d534 2
a535 3
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
d538 1
a538 1
   return (t->GetVideoSyncSGI)(count);
a540 9
int glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *count)
{
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->WaitVideoSyncSGI)(divisor, remainder, count);
}
d542 1
a542 36


/*** GLX_SGI_make_current_read ***/

Bool glXMakeCurrentReadSGI(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->MakeCurrentReadSGI)(dpy, draw, read, ctx);
}

#ifdef GLX_BUILT_IN_XMESA
/* Use glXGetCurrentReadDrawableSGI() from libGL */
#else
/* stand-alone Mesa */
GLXDrawable glXGetCurrentReadDrawableSGI(void)
{
   return glXGetCurrentReadDrawable();
}
#endif


#if defined(_VL_H)

GLXVideoSourceSGIX glXCreateGLXVideoSourceSGIX(Display *dpy, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->CreateGLXVideoSourceSGIX)(dpy, screen, server, path, nodeClass, drainNode);
}

void glXDestroyGLXVideoSourceSGIX(Display *dpy, GLXVideoSourceSGIX src)
d544 1
a544 28
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->DestroyGLXVideoSourceSGIX)(dpy, src);
}

#endif


/*** GLX_EXT_import_context ***/

void glXFreeContextEXT(Display *dpy, GLXContext context)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (t->FreeContextEXT)(dpy, context);
}

#ifdef GLX_BUILT_IN_XMESA
/* Use real libGL's glXGetContextIDEXT() function */
#else
/* stand-alone Mesa */
GLXContextID glXGetContextIDEXT(const GLXContext context)
{
   return ((__GLXcontext *) context)->xid;
a545 1
#endif
a546 9
#ifdef GLX_BUILT_IN_XMESA
/* Use real libGL's glXGetCurrentDisplayEXT() function */
#else
/* stand-alone Mesa */
Display *glXGetCurrentDisplayEXT(void)
{
   return glXGetCurrentDisplay();
}
#endif
d550 1
a550 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d558 1
a558 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d564 1
d567 1
a567 1
/*** GLX_SGIX_fbconfig ***/
d569 1
a569 1
int glXGetFBConfigAttribSGIX(Display *dpy, GLXFBConfigSGIX config, int attribute, int *value)
d571 1
a571 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d574 1
a574 1
   return (t->GetFBConfigAttribSGIX)(dpy, config, attribute, value);
a576 8
GLXFBConfigSGIX *glXChooseFBConfigSGIX(Display *dpy, int screen, int *attrib_list, int *nelements)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->ChooseFBConfigSGIX)(dpy, screen, attrib_list, nelements);
}
d578 1
a578 1
GLXPixmap glXCreateGLXPixmapWithConfigSGIX(Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap)
d580 1
a580 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d583 1
a583 152
   return (t->CreateGLXPixmapWithConfigSGIX)(dpy, config, pixmap);
}

GLXContext glXCreateContextWithConfigSGIX(Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->CreateContextWithConfigSGIX)(dpy, config, render_type, share_list, direct);
}

XVisualInfo * glXGetVisualFromFBConfigSGIX(Display *dpy, GLXFBConfigSGIX config)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->GetVisualFromFBConfigSGIX)(dpy, config);
}

GLXFBConfigSGIX glXGetFBConfigFromVisualSGIX(Display *dpy, XVisualInfo *vis)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->GetFBConfigFromVisualSGIX)(dpy, vis);
}



/*** GLX_SGIX_pbuffer ***/

GLXPbufferSGIX glXCreateGLXPbufferSGIX(Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->CreateGLXPbufferSGIX)(dpy, config, width, height, attrib_list);
}

void glXDestroyGLXPbufferSGIX(Display *dpy, GLXPbufferSGIX pbuf)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (t->DestroyGLXPbufferSGIX)(dpy, pbuf);
}

int glXQueryGLXPbufferSGIX(Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->QueryGLXPbufferSGIX)(dpy, pbuf, attribute, value);
}

void glXSelectEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long mask)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (t->SelectEventSGIX)(dpy, drawable, mask);
}

void glXGetSelectedEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long *mask)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (t->GetSelectedEventSGIX)(dpy, drawable, mask);
}



/*** GLX_SGI_cushion ***/

void glXCushionSGI(Display *dpy, Window win, float cushion)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (t->CushionSGI)(dpy, win, cushion);
}



/*** GLX_SGIX_video_resize ***/

int glXBindChannelToWindowSGIX(Display *dpy, int screen, int channel , Window window)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->BindChannelToWindowSGIX)(dpy, screen, channel, window);
}

int glXChannelRectSGIX(Display *dpy, int screen, int channel, int x, int y, int w, int h)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->ChannelRectSGIX)(dpy, screen, channel, x, y, w, h);
}

int glXQueryChannelRectSGIX(Display *dpy, int screen, int channel, int *x, int *y, int *w, int *h)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->QueryChannelRectSGIX)(dpy, screen, channel, x, y, w, h);
}

int glXQueryChannelDeltasSGIX(Display *dpy, int screen, int channel, int *dx, int *dy, int *dw, int *dh)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->QueryChannelDeltasSGIX)(dpy, screen, channel, dx, dy, dw, dh);
}

int glXChannelRectSyncSGIX(Display *dpy, int screen, int channel, GLenum synctype)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return 0;
   return (t->ChannelRectSyncSGIX)(dpy, screen, channel, synctype);
}



#if defined(_DM_BUFFER_H_)

Bool glXAssociateDMPbufferSGIX(Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return False;
   return (t->AssociateDMPbufferSGIX)(dpy, pbuffer, params, dmbuffer);
d589 1
a589 48
/*** GLX_SGIX_swap_group ***/

void glXJoinSwapGroupSGIX(Display *dpy, GLXDrawable drawable, GLXDrawable member)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (*t->JoinSwapGroupSGIX)(dpy, drawable, member);
}


/*** GLX_SGIX_swap_barrier ***/

void glXBindSwapBarrierSGIX(Display *dpy, GLXDrawable drawable, int barrier)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (*t->BindSwapBarrierSGIX)(dpy, drawable, barrier);
}

Bool glXQueryMaxSwapBarriersSGIX(Display *dpy, int screen, int *max)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return False;
   return (*t->QueryMaxSwapBarriersSGIX)(dpy, screen, max);
}



/*** GLX_SUN_get_transparent_index ***/

Status glXGetTransparentIndexSUN(Display *dpy, Window overlay, Window underlay, long *pTransparent)
{
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
   if (!t)
      return False;
   return (*t->GetTransparentIndexSUN)(dpy, overlay, underlay, pTransparent);
}



/*** GLX_MESA_copy_sub_buffer ***/
d593 1
a593 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d599 1
d602 1
a602 1
/*** GLX_MESA_release_buffers ***/
d606 1
a606 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d612 1
d615 1
a615 1
/*** GLX_MESA_pixmap_colormap ***/
d619 1
a619 2
   struct _glxapi_table *t;
   GET_DISPATCH(dpy, t);
d625 1
d628 1
a628 1
/*** GLX_MESA_set_3dfx_mode ***/
d630 1
a630 1
Bool glXSet3DfxModeMESA(int mode)
d632 1
a632 3
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
d638 1
a641 43
/*** GLX_NV_vertex_array_range ***/

void *
glXAllocateMemoryNV( GLsizei size,
                     GLfloat readFrequency,
                     GLfloat writeFrequency,
                     GLfloat priority )
{
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
   if (!t)
      return NULL;
   return (t->AllocateMemoryNV)(size, readFrequency, writeFrequency, priority);
}


void 
glXFreeMemoryNV( GLvoid *pointer )
{
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
   if (!t)
      return;
   (t->FreeMemoryNV)(pointer);
}


/*** GLX_MESA_agp_offset */

GLuint
glXGetAGPOffsetMESA( const GLvoid *pointer )
{
   struct _glxapi_table *t;
   Display *dpy = glXGetCurrentDisplay();
   GET_DISPATCH(dpy, t);
   if (!t)
      return ~0;
   return (t->GetAGPOffsetMESA)(pointer);
}


d717 1
a723 1
   /*** GLX_VERSION_1_0 ***/
d742 1
a742 1
   /*** GLX_VERSION_1_1 ***/
d746 1
d748 1
a748 1
   /*** GLX_VERSION_1_2 ***/
d750 1
d752 1
a752 1
   /*** GLX_VERSION_1_3 ***/
a762 1
   { "glXGetFBConfigs", (GLvoid *) glXGetFBConfigs },
d769 1
d771 1
a771 7
   /*** GLX_VERSION_1_4 ***/
   { "glXGetProcAddress", (GLvoid *) glXGetProcAddress },

   /*** GLX_SGI_swap_control ***/
   { "glXSwapIntervalSGI", (GLvoid *) glXSwapIntervalSGI },

   /*** GLX_SGI_video_sync ***/
d774 1
d776 3
a778 53
   /*** GLX_SGI_make_current_read ***/
   { "glXMakeCurrentReadSGI", (GLvoid *) glXMakeCurrentReadSGI },
   { "glXGetCurrentReadDrawableSGI", (GLvoid *) glXGetCurrentReadDrawableSGI },

   /*** GLX_SGIX_video_source ***/
#if defined(_VL_H)
   { "glXCreateGLXVideoSourceSGIX", (GLvoid *) glXCreateGLXVideoSourceSGIX },
   { "glXDestroyGLXVideoSourceSGIX", (GLvoid *) glXDestroyGLXVideoSourceSGIX },
#endif

   /*** GLX_EXT_import_context ***/
   { "glXFreeContextEXT", (GLvoid *) glXFreeContextEXT },
   { "glXGetContextIDEXT", (GLvoid *) glXGetContextIDEXT },
   { "glXGetCurrentDisplayEXT", (GLvoid *) glXGetCurrentDisplayEXT },
   { "glXImportContextEXT", (GLvoid *) glXImportContextEXT },
   { "glXQueryContextInfoEXT", (GLvoid *) glXQueryContextInfoEXT },

   /*** GLX_SGIX_fbconfig ***/
   { "glXGetFBConfigAttribSGIX", (GLvoid *) glXGetFBConfigAttribSGIX },
   { "glXChooseFBConfigSGIX", (GLvoid *) glXChooseFBConfigSGIX },
   { "glXCreateGLXPixmapWithConfigSGIX", (GLvoid *) glXCreateGLXPixmapWithConfigSGIX },
   { "glXCreateContextWithConfigSGIX", (GLvoid *) glXCreateContextWithConfigSGIX },
   { "glXGetVisualFromFBConfigSGIX", (GLvoid *) glXGetVisualFromFBConfigSGIX },
   { "glXGetFBConfigFromVisualSGIX", (GLvoid *) glXGetFBConfigFromVisualSGIX },

   /*** GLX_SGIX_pbuffer ***/
   { "glXCreateGLXPbufferSGIX", (GLvoid *) glXCreateGLXPbufferSGIX },
   { "glXDestroyGLXPbufferSGIX", (GLvoid *) glXDestroyGLXPbufferSGIX },
   { "glXQueryGLXPbufferSGIX", (GLvoid *) glXQueryGLXPbufferSGIX },
   { "glXSelectEventSGIX", (GLvoid *) glXSelectEventSGIX },
   { "glXGetSelectedEventSGIX", (GLvoid *) glXGetSelectedEventSGIX },

   /*** GLX_SGI_cushion ***/
   { "glXCushionSGI", (GLvoid *) glXCushionSGI },

   /*** GLX_SGIX_video_resize ***/
   { "glXBindChannelToWindowSGIX", (GLvoid *) glXBindChannelToWindowSGIX },
   { "glXChannelRectSGIX", (GLvoid *) glXChannelRectSGIX },
   { "glXQueryChannelRectSGIX", (GLvoid *) glXQueryChannelRectSGIX },
   { "glXQueryChannelDeltasSGIX", (GLvoid *) glXQueryChannelDeltasSGIX },
   { "glXChannelRectSyncSGIX", (GLvoid *) glXChannelRectSyncSGIX },

   /*** GLX_SGIX_dmbuffer **/
#if defined(_DM_BUFFER_H_)
   { "glXAssociateDMPbufferSGIX", (GLvoid *) glXAssociateDMPbufferSGIX },
#endif

   /*** GLX_SGIX_swap_group ***/
   { "glXJoinSwapGroupSGIX", (GLvoid *) glXJoinSwapGroupSGIX },

   /*** GLX_SGIX_swap_barrier ***/
   { "glXBindSwapBarrierSGIX", (GLvoid *) glXBindSwapBarrierSGIX },
   { "glXQueryMaxSwapBarriersSGIX", (GLvoid *) glXQueryMaxSwapBarriersSGIX },
d780 3
a782 2
   /*** GLX_SUN_get_transparent_index ***/
   { "glXGetTransparentIndexSUN", (GLvoid *) glXGetTransparentIndexSUN },
d784 1
a784 4
   /*** GLX_MESA_copy_sub_buffer ***/
   { "glXCopySubBufferMESA", (GLvoid *) glXCopySubBufferMESA },

   /*** GLX_MESA_pixmap_colormap ***/
d786 1
d788 1
a788 4
   /*** GLX_MESA_release_buffers ***/
   { "glXReleaseBuffersMESA", (GLvoid *) glXReleaseBuffersMESA },

   /*** GLX_MESA_set_3dfx_mode ***/
d790 1
a791 1
   /*** GLX_ARB_get_proc_address ***/
a793 4
   /*** GLX AGP memory allocation ***/
   { "glXAllocateMemoryNV", (GLvoid *) glXAllocateMemoryNV },
   { "glXFreeMemoryNV", (GLvoid *) glXFreeMemoryNV },

a830 7
}


/* GLX 1.4 */
void (*glXGetProcAddress(const GLubyte *procName))()
{
   return glXGetProcAddressARB(procName);
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d4 1
a4 1
 * Version:  4.0.2
d6 1
a6 1
 * Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
d990 2
a991 1
/*** AGP memory allocation ***/
d1019 13
@


