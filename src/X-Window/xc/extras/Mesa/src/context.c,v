head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.28.14;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.00.58;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.00.58;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.19.55;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.28.26;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.04.34;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@
/*
 * Mesa 3-D graphics library
 * Version:  3.4
 *
 * Copyright (C) 1999-2000  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


#ifdef PC_HEADER
#include "all.h"
#else
#include "glheader.h"
#include "accum.h"
#include "alphabuf.h"
#include "clip.h"
#include "colortab.h"
#include "context.h"
#include "cva.h"
#include "depth.h"
#include "dlist.h"
#include "eval.h"
#include "enums.h"
#include "extensions.h"
#include "fog.h"
#include "get.h"
#include "glapi.h"
#include "glapinoop.h"
#include "glthread.h"
#include "hash.h"
#include "light.h"
#include "macros.h"
#include "matrix.h"
#include "mem.h"
#include "mmath.h"
#include "pb.h"
#include "pipeline.h"
#include "shade.h"
#include "simple_list.h"
#include "stencil.h"
#include "stages.h"
#include "state.h"
#include "translate.h"
#include "teximage.h"
#include "texobj.h"
#include "texstate.h"
#include "texture.h"
#include "types.h"
#include "varray.h"
#include "vb.h"
#include "vbcull.h"
#include "vbrender.h"
#include "vbxform.h"
#include "vertices.h"
#include "xform.h"
#endif



/**********************************************************************/
/*****                  Context and Thread management             *****/
/**********************************************************************/


#if !defined(THREADS)

struct immediate *_mesa_CurrentInput = NULL;

#endif


/**********************************************************************/
/***** GL Visual allocation/destruction                           *****/
/**********************************************************************/


/*
 * Allocate a new GLvisual object.
 * Input:  rgbFlag - GL_TRUE=RGB(A) mode, GL_FALSE=Color Index mode
 *         dbFlag - double buffering?
 *         stereoFlag - stereo buffer?
 *         depthBits - requested bits per depth buffer value
 *                     Any value in [0, 32] is acceptable but the actual
 *                     depth type will be GLushort or GLuint as needed.
 *         stencilBits - requested minimum bits per stencil buffer value
 *         accumBits - requested minimum bits per accum buffer component
 *         indexBits - number of bits per pixel if rgbFlag==GL_FALSE
 *         red/green/blue/alphaBits - number of bits per color component
 *                                    in frame buffer for RGB(A) mode.
 *                                    We always use 8 in core Mesa though.
 * Return:  pointer to new GLvisual or NULL if requested parameters can't
 *          be met.
 */
GLvisual *
_mesa_create_visual( GLboolean rgbFlag,
                     GLboolean dbFlag,
                     GLboolean stereoFlag,
                     GLint redBits,
                     GLint greenBits,
                     GLint blueBits,
                     GLint alphaBits,
                     GLint indexBits,
                     GLint depthBits,
                     GLint stencilBits,
                     GLint accumRedBits,
                     GLint accumGreenBits,
                     GLint accumBlueBits,
                     GLint accumAlphaBits,
                     GLint numSamples )
{
   GLvisual *vis = (GLvisual *) CALLOC( sizeof(GLvisual) );
   if (vis) {
      if (!_mesa_initialize_visual(vis, rgbFlag, dbFlag, stereoFlag,
                                   redBits, greenBits, blueBits, alphaBits,
                                   indexBits, depthBits, stencilBits,
                                   accumRedBits, accumGreenBits,
                                   accumBlueBits, accumAlphaBits,
                                   numSamples )) {
         FREE(vis);
         return NULL;
      }
   }
   return vis;
}


/*
 * Initialize the fields of the given GLvisual.
 * Input:  see _mesa_create_visual() above.
 * Return: GL_TRUE = success
 *         GL_FALSE = failure.
 */
GLboolean
_mesa_initialize_visual( GLvisual *vis,
                         GLboolean rgbFlag,
                         GLboolean dbFlag,
                         GLboolean stereoFlag,
                         GLint redBits,
                         GLint greenBits,
                         GLint blueBits,
                         GLint alphaBits,
                         GLint indexBits,
                         GLint depthBits,
                         GLint stencilBits,
                         GLint accumRedBits,
                         GLint accumGreenBits,
                         GLint accumBlueBits,
                         GLint accumAlphaBits,
                         GLint numSamples )
{
   assert(vis);

   /* This is to catch bad values from device drivers not updated for
    * Mesa 3.3.  Some device drivers just passed 1.  That's a REALLY
    * bad value now (a 1-bit depth buffer!?!).
    */
   assert(depthBits == 0 || depthBits > 1);

   if (depthBits < 0 || depthBits > 32) {
      return GL_FALSE;
   }
   if (stencilBits < 0 || stencilBits > (GLint) (8 * sizeof(GLstencil))) {
      return GL_FALSE;
   }
   if (accumRedBits < 0 || accumRedBits > (GLint) (8 * sizeof(GLaccum))) {
      return GL_FALSE;
   }
   if (accumGreenBits < 0 || accumGreenBits > (GLint) (8 * sizeof(GLaccum))) {
      return GL_FALSE;
   }
   if (accumBlueBits < 0 || accumBlueBits > (GLint) (8 * sizeof(GLaccum))) {
      return GL_FALSE;
   }
   if (accumAlphaBits < 0 || accumAlphaBits > (GLint) (8 * sizeof(GLaccum))) {
      return GL_FALSE;
   }

   vis->RGBAflag   = rgbFlag;
   vis->DBflag     = dbFlag;
   vis->StereoFlag = stereoFlag;
   vis->RedBits    = redBits;
   vis->GreenBits  = greenBits;
   vis->BlueBits   = blueBits;
   vis->AlphaBits  = alphaBits;

   vis->IndexBits      = indexBits;
   vis->DepthBits      = depthBits;
   vis->AccumRedBits   = (accumRedBits > 0) ? (8 * sizeof(GLaccum)) : 0;
   vis->AccumGreenBits = (accumGreenBits > 0) ? (8 * sizeof(GLaccum)) : 0;
   vis->AccumBlueBits  = (accumBlueBits > 0) ? (8 * sizeof(GLaccum)) : 0;
   vis->AccumAlphaBits = (accumAlphaBits > 0) ? (8 * sizeof(GLaccum)) : 0;
   vis->StencilBits    = (stencilBits > 0) ? (8 * sizeof(GLstencil)) : 0;

   if (depthBits == 0) {
      /* Special case.  Even if we don't have a depth buffer we need
       * good values for DepthMax for Z vertex transformation purposes
       * and for per-fragment fog computation.
       */
      vis->DepthMax = 1 << 16;
      vis->DepthMaxF = (GLfloat) vis->DepthMax;
   }
   else if (depthBits < 32) {
      vis->DepthMax = (1 << depthBits) - 1;
      vis->DepthMaxF = (GLfloat) vis->DepthMax;
   }
   else {
      /* Special case since shift values greater than or equal to the
       * number of bits in the left hand expression's type are
       * undefined.
       */
      vis->DepthMax = 0xffffffff;
      vis->DepthMaxF = (GLfloat) vis->DepthMax;
   }

   return GL_TRUE;
}


/* This function should no longer be used. Use _mesa_create_visual() instead */
GLvisual *
gl_create_visual( GLboolean rgbFlag,
                  GLboolean alphaFlag,
                  GLboolean dbFlag,
                  GLboolean stereoFlag,
                  GLint depthBits,
                  GLint stencilBits,
                  GLint accumBits,
                  GLint indexBits,
                  GLint redBits,
                  GLint greenBits,
                  GLint blueBits,
                  GLint alphaBits )
{
   (void) alphaFlag;
   return _mesa_create_visual(rgbFlag, dbFlag, stereoFlag,
                              redBits, greenBits, blueBits, alphaBits,
                              indexBits, depthBits, stencilBits,
                              accumBits, accumBits, accumBits, accumBits, 0);
}


void
_mesa_destroy_visual( GLvisual *vis )
{
   FREE(vis);
}


/* obsolete */
void
gl_destroy_visual( GLvisual *vis )
{
   _mesa_destroy_visual(vis);
}



/**********************************************************************/
/***** GL Framebuffer allocation/destruction                      *****/
/**********************************************************************/


/*
 * Create a new framebuffer.  A GLframebuffer is a struct which
 * encapsulates the depth, stencil and accum buffers and related
 * parameters.
 * Input:  visual - a GLvisual pointer
 *         softwareDepth - create/use a software depth buffer?
 *         softwareStencil - create/use a software stencil buffer?
 *         softwareAccum - create/use a software accum buffer?
 *         softwareAlpha - create/use a software alpha buffer?

 * Return:  pointer to new GLframebuffer struct or NULL if error.
 */
GLframebuffer *
gl_create_framebuffer( GLvisual *visual,
                       GLboolean softwareDepth,
                       GLboolean softwareStencil,
                       GLboolean softwareAccum,
                       GLboolean softwareAlpha )
{
   GLframebuffer *buffer = CALLOC_STRUCT(gl_frame_buffer);
   assert(visual);
   if (buffer) {
      _mesa_initialize_framebuffer(buffer, visual,
                                   softwareDepth, softwareStencil,
                                   softwareAccum, softwareAlpha );
   }
   return buffer;
}


/*
 * Initialize a GLframebuffer object.
 * Input:  See gl_create_framebuffer() above.
 */
void
_mesa_initialize_framebuffer( GLframebuffer *buffer,
                              GLvisual *visual,
                              GLboolean softwareDepth,
                              GLboolean softwareStencil,
                              GLboolean softwareAccum,
                              GLboolean softwareAlpha )
{
   assert(buffer);
   assert(visual);

   /* sanity checks */
   if (softwareDepth ) {
      assert(visual->DepthBits > 0);
   }
   if (softwareStencil) {
      assert(visual->StencilBits > 0);
   }
   if (softwareAccum) {
      assert(visual->RGBAflag);
      assert(visual->AccumRedBits > 0);
      assert(visual->AccumGreenBits > 0);
      assert(visual->AccumBlueBits > 0);
   }
   if (softwareAlpha) {
      assert(visual->RGBAflag);
      assert(visual->AlphaBits > 0);
   }

   buffer->Visual = visual;
   buffer->UseSoftwareDepthBuffer = softwareDepth;
   buffer->UseSoftwareStencilBuffer = softwareStencil;
   buffer->UseSoftwareAccumBuffer = softwareAccum;
   buffer->UseSoftwareAlphaBuffers = softwareAlpha;
}


/*
 * Free a framebuffer struct and its buffers.
 */
void
gl_destroy_framebuffer( GLframebuffer *buffer )
{
   if (buffer) {
      if (buffer->DepthBuffer) {
         FREE( buffer->DepthBuffer );
      }
      if (buffer->Accum) {
         FREE( buffer->Accum );
      }
      if (buffer->Stencil) {
         FREE( buffer->Stencil );
      }
      if (buffer->FrontLeftAlpha) {
         FREE( buffer->FrontLeftAlpha );
      }
      if (buffer->BackLeftAlpha) {
         FREE( buffer->BackLeftAlpha );
      }
      if (buffer->FrontRightAlpha) {
         FREE( buffer->FrontRightAlpha );
      }
      if (buffer->BackRightAlpha) {
         FREE( buffer->BackRightAlpha );
      }
      FREE(buffer);
   }
}



/**********************************************************************/
/*****       Context allocation, initialization, destroying       *****/
/**********************************************************************/


_glthread_DECLARE_STATIC_MUTEX(OneTimeLock);


/*
 * This function just calls all the various one-time-init functions in Mesa.
 */
static void
one_time_init( void )
{
   static GLboolean alreadyCalled = GL_FALSE;
   _glthread_LOCK_MUTEX(OneTimeLock);
   if (!alreadyCalled) {
      /* do some implementation tests */
      assert( sizeof(GLbyte) == 1 );
      assert( sizeof(GLshort) >= 2 );
      assert( sizeof(GLint) >= 4 );
      assert( sizeof(GLubyte) == 1 );
      assert( sizeof(GLushort) >= 2 );
      assert( sizeof(GLuint) >= 4 );

      gl_init_clip();
      gl_init_eval();
      _mesa_init_fog();
      _mesa_init_math();
      gl_init_lists();
      gl_init_texture();
      gl_init_transformation();
      gl_init_translate();
      gl_init_shade();
      gl_init_vbrender();
      gl_init_vbxform();
      gl_init_vertices();

      if (getenv("MESA_DEBUG")) {
         _glapi_noop_enable_warnings(GL_TRUE);
      }
      else {
         _glapi_noop_enable_warnings(GL_FALSE);
      }

#if defined(DEBUG) && defined(__DATE__) && defined(__TIME__)
   fprintf(stderr, "Mesa DEBUG build %s %s\n", __DATE__, __TIME__);
#endif

      alreadyCalled = GL_TRUE;
   }
   _glthread_UNLOCK_MUTEX(OneTimeLock);
}



/*
 * Allocate and initialize a shared context state structure.
 */
static struct gl_shared_state *
alloc_shared_state( void )
{
   GLuint d;
   struct gl_shared_state *ss;
   GLboolean outOfMemory;

   ss = CALLOC_STRUCT(gl_shared_state);
   if (!ss)
      return NULL;

   _glthread_INIT_MUTEX(ss->Mutex);

   ss->DisplayList = _mesa_NewHashTable();
   ss->TexObjects = _mesa_NewHashTable();
#ifdef VAO
   ss->ArrayObjects = _mesa_NewHashTable();
#endif

   /* Default Texture objects */
   outOfMemory = GL_FALSE;
   for (d = 1 ; d <= 3 ; d++) {
      ss->DefaultD[d] = gl_alloc_texture_object(ss, 0, d);
      if (!ss->DefaultD[d]) {
         outOfMemory = GL_TRUE;
         break;
      }
      ss->DefaultD[d]->RefCount++; /* don't free if not in use */
   }

   ss->DefaultCubeMap = gl_alloc_texture_object(ss, 0, 6);
   if (!ss->DefaultCubeMap) {
      outOfMemory = GL_TRUE;
   }
   else {
      ss->DefaultCubeMap->RefCount++;
   }

   if (!ss->DisplayList || !ss->TexObjects || outOfMemory) {
      /* Ran out of memory at some point.  Free everything and return NULL */
      if (ss->DisplayList)
         _mesa_DeleteHashTable(ss->DisplayList);
      if (ss->TexObjects)
         _mesa_DeleteHashTable(ss->TexObjects);
      if (ss->DefaultD[1])
         gl_free_texture_object(ss, ss->DefaultD[1]);
      if (ss->DefaultD[2])
         gl_free_texture_object(ss, ss->DefaultD[2]);
      if (ss->DefaultD[3])
         gl_free_texture_object(ss, ss->DefaultD[3]);
      if (ss->DefaultCubeMap)
         gl_free_texture_object(ss, ss->DefaultCubeMap);
      FREE(ss);
      return NULL;
   }
   else {
      return ss;
   }
}


/*
 * Deallocate a shared state context and all children structures.
 */
static void
free_shared_state( GLcontext *ctx, struct gl_shared_state *ss )
{
   /* Free display lists */
   while (1) {
      GLuint list = _mesa_HashFirstEntry(ss->DisplayList);
      if (list) {
         gl_destroy_list(ctx, list);
      }
      else {
         break;
      }
   }
   _mesa_DeleteHashTable(ss->DisplayList);

   /* Free texture objects */
   while (ss->TexObjectList)
   {
      if (ctx->Driver.DeleteTexture)
         (*ctx->Driver.DeleteTexture)( ctx, ss->TexObjectList );
      /* this function removes from linked list too! */
      gl_free_texture_object(ss, ss->TexObjectList);
   }
   _mesa_DeleteHashTable(ss->TexObjects);

   FREE(ss);
}



/*
 * Initialize the nth light.  Note that the defaults for light 0 are
 * different than the other lights.
 */
static void
init_light( struct gl_light *l, GLuint n )
{
   make_empty_list( l );

   ASSIGN_4V( l->Ambient, 0.0, 0.0, 0.0, 1.0 );
   if (n==0) {
      ASSIGN_4V( l->Diffuse, 1.0, 1.0, 1.0, 1.0 );
      ASSIGN_4V( l->Specular, 1.0, 1.0, 1.0, 1.0 );
   }
   else {
      ASSIGN_4V( l->Diffuse, 0.0, 0.0, 0.0, 1.0 );
      ASSIGN_4V( l->Specular, 0.0, 0.0, 0.0, 1.0 );
   }
   ASSIGN_4V( l->EyePosition, 0.0, 0.0, 1.0, 0.0 );
   ASSIGN_3V( l->EyeDirection, 0.0, 0.0, -1.0 );
   l->SpotExponent = 0.0;
   gl_compute_spot_exp_table( l );
   l->SpotCutoff = 180.0;
   l->CosCutoff = 0.0;		/* KW: -ve values not admitted */
   l->ConstantAttenuation = 1.0;
   l->LinearAttenuation = 0.0;
   l->QuadraticAttenuation = 0.0;
   l->Enabled = GL_FALSE;
}



static void
init_lightmodel( struct gl_lightmodel *lm )
{
   ASSIGN_4V( lm->Ambient, 0.2, 0.2, 0.2, 1.0 );
   lm->LocalViewer = GL_FALSE;
   lm->TwoSide = GL_FALSE;
   lm->ColorControl = GL_SINGLE_COLOR;
}


static void
init_material( struct gl_material *m )
{
   ASSIGN_4V( m->Ambient,  0.2, 0.2, 0.2, 1.0 );
   ASSIGN_4V( m->Diffuse,  0.8, 0.8, 0.8, 1.0 );
   ASSIGN_4V( m->Specular, 0.0, 0.0, 0.0, 1.0 );
   ASSIGN_4V( m->Emission, 0.0, 0.0, 0.0, 1.0 );
   m->Shininess = 0.0;
   m->AmbientIndex = 0;
   m->DiffuseIndex = 1;
   m->SpecularIndex = 1;
}



static void
init_texture_unit( GLcontext *ctx, GLuint unit )
{
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];

   texUnit->Enabled = 0;
   texUnit->ReallyEnabled = 0;
   texUnit->EnvMode = GL_MODULATE;
   texUnit->CombineModeRGB = GL_MODULATE;
   texUnit->CombineModeA = GL_MODULATE;
   texUnit->CombineSourceRGB[0] = GL_TEXTURE;
   texUnit->CombineSourceRGB[1] = GL_PREVIOUS_EXT;
   texUnit->CombineSourceRGB[2] = GL_CONSTANT_EXT;
   texUnit->CombineSourceA[0] = GL_TEXTURE;
   texUnit->CombineSourceA[1] = GL_PREVIOUS_EXT;
   texUnit->CombineSourceA[2] = GL_CONSTANT_EXT;
   texUnit->CombineOperandRGB[0] = GL_SRC_COLOR;
   texUnit->CombineOperandRGB[1] = GL_SRC_COLOR;
   texUnit->CombineOperandRGB[2] = GL_SRC_ALPHA;
   texUnit->CombineOperandA[0] = GL_SRC_ALPHA;
   texUnit->CombineOperandA[1] = GL_SRC_ALPHA;
   texUnit->CombineOperandA[2] = GL_SRC_ALPHA;
   texUnit->CombineScaleShiftRGB = 0;
   texUnit->CombineScaleShiftA = 0;

   ASSIGN_4V( texUnit->EnvColor, 0.0, 0.0, 0.0, 0.0 );
   texUnit->TexGenEnabled = 0;
   texUnit->GenModeS = GL_EYE_LINEAR;
   texUnit->GenModeT = GL_EYE_LINEAR;
   texUnit->GenModeR = GL_EYE_LINEAR;
   texUnit->GenModeQ = GL_EYE_LINEAR;
   texUnit->GenBitS = TEXGEN_EYE_LINEAR;
   texUnit->GenBitT = TEXGEN_EYE_LINEAR;
   texUnit->GenBitR = TEXGEN_EYE_LINEAR;
   texUnit->GenBitQ = TEXGEN_EYE_LINEAR;

   /* Yes, these plane coefficients are correct! */
   ASSIGN_4V( texUnit->ObjectPlaneS, 1.0, 0.0, 0.0, 0.0 );
   ASSIGN_4V( texUnit->ObjectPlaneT, 0.0, 1.0, 0.0, 0.0 );
   ASSIGN_4V( texUnit->ObjectPlaneR, 0.0, 0.0, 0.0, 0.0 );
   ASSIGN_4V( texUnit->ObjectPlaneQ, 0.0, 0.0, 0.0, 0.0 );
   ASSIGN_4V( texUnit->EyePlaneS, 1.0, 0.0, 0.0, 0.0 );
   ASSIGN_4V( texUnit->EyePlaneT, 0.0, 1.0, 0.0, 0.0 );
   ASSIGN_4V( texUnit->EyePlaneR, 0.0, 0.0, 0.0, 0.0 );
   ASSIGN_4V( texUnit->EyePlaneQ, 0.0, 0.0, 0.0, 0.0 );

   texUnit->CurrentD[1] = ctx->Shared->DefaultD[1];
   texUnit->CurrentD[2] = ctx->Shared->DefaultD[2];
   texUnit->CurrentD[3] = ctx->Shared->DefaultD[3];
   texUnit->CurrentCubeMap = ctx->Shared->DefaultCubeMap;
}


static void
init_fallback_arrays( GLcontext *ctx )
{
   struct gl_client_array *cl;
   GLuint i;

   cl = &ctx->Fallback.Normal;
   cl->Size = 3;
   cl->Type = GL_FLOAT;
   cl->Stride = 0;
   cl->StrideB = 0;
   cl->Ptr = (void *) ctx->Current.Normal;
   cl->Enabled = 1;

   cl = &ctx->Fallback.Color;
   cl->Size = 4;
   cl->Type = GL_UNSIGNED_BYTE;
   cl->Stride = 0;
   cl->StrideB = 0;
   cl->Ptr = (void *) ctx->Current.ByteColor;
   cl->Enabled = 1;

   cl = &ctx->Fallback.Index;
   cl->Size = 1;
   cl->Type = GL_UNSIGNED_INT;
   cl->Stride = 0;
   cl->StrideB = 0;
   cl->Ptr = (void *) &ctx->Current.Index;
   cl->Enabled = 1;

   for (i = 0 ; i < MAX_TEXTURE_UNITS ; i++) {
      cl = &ctx->Fallback.TexCoord[i];
      cl->Size = 4;
      cl->Type = GL_FLOAT;
      cl->Stride = 0;
      cl->StrideB = 0;
      cl->Ptr = (void *) ctx->Current.Texcoord[i];
      cl->Enabled = 1;
   }

   cl = &ctx->Fallback.EdgeFlag;
   cl->Size = 1;
   cl->Type = GL_UNSIGNED_BYTE;
   cl->Stride = 0;
   cl->StrideB = 0;
   cl->Ptr = (void *) &ctx->Current.EdgeFlag;
   cl->Enabled = 1;
}


/* Initialize a 1-D evaluator map */
static void
init_1d_map( struct gl_1d_map *map, int n, const float *initial )
{
   map->Order = 1;
   map->u1 = 0.0;
   map->u2 = 1.0;
   map->Points = (GLfloat *) MALLOC(n * sizeof(GLfloat));
   if (map->Points) {
      GLint i;
      for (i=0;i<n;i++)
         map->Points[i] = initial[i];
   }
}


/* Initialize a 2-D evaluator map */
static void
init_2d_map( struct gl_2d_map *map, int n, const float *initial )
{
   map->Uorder = 1;
   map->Vorder = 1;
   map->u1 = 0.0;
   map->u2 = 1.0;
   map->v1 = 0.0;
   map->v2 = 1.0;
   map->Points = (GLfloat *) MALLOC(n * sizeof(GLfloat));
   if (map->Points) {
      GLint i;
      for (i=0;i<n;i++)
         map->Points[i] = initial[i];
   }
}


/*
 * Initialize the attribute groups in a GLcontext.
 */
static void
init_attrib_groups( GLcontext *ctx )
{
   GLuint i, j;

   assert(ctx);

   /* Constants, may be overriden by device drivers */
   ctx->Const.MaxTextureLevels = MAX_TEXTURE_LEVELS;
   ctx->Const.MaxTextureSize = 1 << (MAX_TEXTURE_LEVELS - 1);
   ctx->Const.MaxCubeTextureSize = ctx->Const.MaxTextureSize;
   ctx->Const.MaxTextureUnits = MAX_TEXTURE_UNITS;
   ctx->Const.MaxArrayLockSize = MAX_ARRAY_LOCK_SIZE;
   ctx->Const.SubPixelBits = SUB_PIXEL_BITS;
   ctx->Const.MinPointSize = MIN_POINT_SIZE;
   ctx->Const.MaxPointSize = MAX_POINT_SIZE;
   ctx->Const.MinPointSizeAA = MIN_POINT_SIZE;
   ctx->Const.MaxPointSizeAA = MAX_POINT_SIZE;
   ctx->Const.PointSizeGranularity = POINT_SIZE_GRANULARITY;
   ctx->Const.MinLineWidth = MIN_LINE_WIDTH;
   ctx->Const.MaxLineWidth = MAX_LINE_WIDTH;
   ctx->Const.MinLineWidthAA = MIN_LINE_WIDTH;
   ctx->Const.MaxLineWidthAA = MAX_LINE_WIDTH;
   ctx->Const.LineWidthGranularity = LINE_WIDTH_GRANULARITY;
   ctx->Const.NumAuxBuffers = NUM_AUX_BUFFERS;
   ctx->Const.MaxColorTableSize = MAX_COLOR_TABLE_SIZE;
   ctx->Const.MaxConvolutionWidth = MAX_CONVOLUTION_WIDTH;
   ctx->Const.MaxConvolutionHeight = MAX_CONVOLUTION_HEIGHT;
   ctx->Const.NumCompressedTextureFormats = 0;

   /* Modelview matrix */
   gl_matrix_ctr( &ctx->ModelView );
   gl_matrix_alloc_inv( &ctx->ModelView );

   ctx->ModelViewStackDepth = 0;
   for (i = 0; i < MAX_MODELVIEW_STACK_DEPTH - 1; i++) {
      gl_matrix_ctr( &ctx->ModelViewStack[i] );
      gl_matrix_alloc_inv( &ctx->ModelViewStack[i] );
   }

   /* Projection matrix - need inv for user clipping in clip space*/
   gl_matrix_ctr( &ctx->ProjectionMatrix );
   gl_matrix_alloc_inv( &ctx->ProjectionMatrix );

   gl_matrix_ctr( &ctx->ModelProjectMatrix );
   gl_matrix_ctr( &ctx->ModelProjectWinMatrix );
   ctx->ModelProjectWinMatrixUptodate = GL_FALSE;

   ctx->ProjectionStackDepth = 0;
   ctx->NearFarStack[0][0] = 1.0; /* These values seem weird by make */
   ctx->NearFarStack[0][1] = 0.0; /* sense mathematically. */

   for (i = 0; i < MAX_PROJECTION_STACK_DEPTH - 1; i++) {
      gl_matrix_ctr( &ctx->ProjectionStack[i] );
      gl_matrix_alloc_inv( &ctx->ProjectionStack[i] );
   }

   /* Texture matrix */
   for (i = 0; i < MAX_TEXTURE_UNITS; i++) {
      gl_matrix_ctr( &ctx->TextureMatrix[i] );
      ctx->TextureStackDepth[i] = 0;
      for (j = 0; j < MAX_TEXTURE_STACK_DEPTH - 1; j++) {
         gl_matrix_ctr( &ctx->TextureStack[i][j] );
         ctx->TextureStack[i][j].inv = 0;
      }
   }

   /* Color matrix */
   gl_matrix_ctr(&ctx->ColorMatrix);
   ctx->ColorStackDepth = 0;
   for (j = 0; j < MAX_COLOR_STACK_DEPTH - 1; j++) {
      gl_matrix_ctr(&ctx->ColorStack[j]);
   }

   /* Accumulate buffer group */
   ASSIGN_4V( ctx->Accum.ClearColor, 0.0, 0.0, 0.0, 0.0 );

   /* Color buffer group */
   ctx->Color.IndexMask = 0xffffffff;
   ctx->Color.ColorMask[0] = 0xff;
   ctx->Color.ColorMask[1] = 0xff;
   ctx->Color.ColorMask[2] = 0xff;
   ctx->Color.ColorMask[3] = 0xff;
   ctx->Color.SWmasking = GL_FALSE;
   ctx->Color.ClearIndex = 0;
   ASSIGN_4V( ctx->Color.ClearColor, 0.0, 0.0, 0.0, 0.0 );
   ctx->Color.DrawBuffer = GL_FRONT;
   ctx->Color.AlphaEnabled = GL_FALSE;
   ctx->Color.AlphaFunc = GL_ALWAYS;
   ctx->Color.AlphaRef = 0;
   ctx->Color.BlendEnabled = GL_FALSE;
   ctx->Color.BlendSrcRGB = GL_ONE;
   ctx->Color.BlendDstRGB = GL_ZERO;
   ctx->Color.BlendSrcA = GL_ONE;
   ctx->Color.BlendDstA = GL_ZERO;
   ctx->Color.BlendEquation = GL_FUNC_ADD_EXT;
   ctx->Color.BlendFunc = NULL;  /* this pointer set only when needed */
   ASSIGN_4V( ctx->Color.BlendColor, 0.0, 0.0, 0.0, 0.0 );
   ctx->Color.IndexLogicOpEnabled = GL_FALSE;
   ctx->Color.ColorLogicOpEnabled = GL_FALSE;
   ctx->Color.SWLogicOpEnabled = GL_FALSE;
   ctx->Color.LogicOp = GL_COPY;
   ctx->Color.DitherFlag = GL_TRUE;
   ctx->Color.MultiDrawBuffer = GL_FALSE;

   /* Current group */
   ASSIGN_4V( ctx->Current.ByteColor, 255, 255, 255, 255);
   ctx->Current.Index = 1;
   for (i=0; i<MAX_TEXTURE_UNITS; i++)
      ASSIGN_4V( ctx->Current.Texcoord[i], 0.0, 0.0, 0.0, 1.0 );
   ASSIGN_4V( ctx->Current.RasterPos, 0.0, 0.0, 0.0, 1.0 );
   ctx->Current.RasterDistance = 0.0;
   ASSIGN_4V( ctx->Current.RasterColor, 1.0, 1.0, 1.0, 1.0 );
   ctx->Current.RasterIndex = 1;
   for (i=0; i<MAX_TEXTURE_UNITS; i++)
      ASSIGN_4V( ctx->Current.RasterMultiTexCoord[i], 0.0, 0.0, 0.0, 1.0 );
   ctx->Current.RasterTexCoord = ctx->Current.RasterMultiTexCoord[0];
   ctx->Current.RasterPosValid = GL_TRUE;
   ctx->Current.EdgeFlag = GL_TRUE;
   ASSIGN_3V( ctx->Current.Normal, 0.0, 0.0, 1.0 );
   ctx->Current.Primitive = (GLenum) (GL_POLYGON + 1);

   ctx->Current.Flag = (VERT_NORM|VERT_INDEX|VERT_RGBA|VERT_EDGE|
                        VERT_TEX0_1|VERT_TEX1_1|VERT_MATERIAL);

   init_fallback_arrays( ctx );

   /* Depth buffer group */
   ctx->Depth.Test = GL_FALSE;
   ctx->Depth.Clear = 1.0;
   ctx->Depth.Func = GL_LESS;
   ctx->Depth.Mask = GL_TRUE;
   ctx->Depth.OcclusionTest = GL_FALSE;

   /* Evaluators group */
   ctx->Eval.Map1Color4 = GL_FALSE;
   ctx->Eval.Map1Index = GL_FALSE;
   ctx->Eval.Map1Normal = GL_FALSE;
   ctx->Eval.Map1TextureCoord1 = GL_FALSE;
   ctx->Eval.Map1TextureCoord2 = GL_FALSE;
   ctx->Eval.Map1TextureCoord3 = GL_FALSE;
   ctx->Eval.Map1TextureCoord4 = GL_FALSE;
   ctx->Eval.Map1Vertex3 = GL_FALSE;
   ctx->Eval.Map1Vertex4 = GL_FALSE;
   ctx->Eval.Map2Color4 = GL_FALSE;
   ctx->Eval.Map2Index = GL_FALSE;
   ctx->Eval.Map2Normal = GL_FALSE;
   ctx->Eval.Map2TextureCoord1 = GL_FALSE;
   ctx->Eval.Map2TextureCoord2 = GL_FALSE;
   ctx->Eval.Map2TextureCoord3 = GL_FALSE;
   ctx->Eval.Map2TextureCoord4 = GL_FALSE;
   ctx->Eval.Map2Vertex3 = GL_FALSE;
   ctx->Eval.Map2Vertex4 = GL_FALSE;
   ctx->Eval.AutoNormal = GL_FALSE;
   ctx->Eval.MapGrid1un = 1;
   ctx->Eval.MapGrid1u1 = 0.0;
   ctx->Eval.MapGrid1u2 = 1.0;
   ctx->Eval.MapGrid2un = 1;
   ctx->Eval.MapGrid2vn = 1;
   ctx->Eval.MapGrid2u1 = 0.0;
   ctx->Eval.MapGrid2u2 = 1.0;
   ctx->Eval.MapGrid2v1 = 0.0;
   ctx->Eval.MapGrid2v2 = 1.0;

   /* Evaluator data */
   {
      static GLfloat vertex[4] = { 0.0, 0.0, 0.0, 1.0 };
      static GLfloat normal[3] = { 0.0, 0.0, 1.0 };
      static GLfloat index[1] = { 1.0 };
      static GLfloat color[4] = { 1.0, 1.0, 1.0, 1.0 };
      static GLfloat texcoord[4] = { 0.0, 0.0, 0.0, 1.0 };

      init_1d_map( &ctx->EvalMap.Map1Vertex3, 3, vertex );
      init_1d_map( &ctx->EvalMap.Map1Vertex4, 4, vertex );
      init_1d_map( &ctx->EvalMap.Map1Index, 1, index );
      init_1d_map( &ctx->EvalMap.Map1Color4, 4, color );
      init_1d_map( &ctx->EvalMap.Map1Normal, 3, normal );
      init_1d_map( &ctx->EvalMap.Map1Texture1, 1, texcoord );
      init_1d_map( &ctx->EvalMap.Map1Texture2, 2, texcoord );
      init_1d_map( &ctx->EvalMap.Map1Texture3, 3, texcoord );
      init_1d_map( &ctx->EvalMap.Map1Texture4, 4, texcoord );

      init_2d_map( &ctx->EvalMap.Map2Vertex3, 3, vertex );
      init_2d_map( &ctx->EvalMap.Map2Vertex4, 4, vertex );
      init_2d_map( &ctx->EvalMap.Map2Index, 1, index );
      init_2d_map( &ctx->EvalMap.Map2Color4, 4, color );
      init_2d_map( &ctx->EvalMap.Map2Normal, 3, normal );
      init_2d_map( &ctx->EvalMap.Map2Texture1, 1, texcoord );
      init_2d_map( &ctx->EvalMap.Map2Texture2, 2, texcoord );
      init_2d_map( &ctx->EvalMap.Map2Texture3, 3, texcoord );
      init_2d_map( &ctx->EvalMap.Map2Texture4, 4, texcoord );
   }

   /* Fog group */
   ctx->Fog.Enabled = GL_FALSE;
   ctx->Fog.Mode = GL_EXP;
   ASSIGN_4V( ctx->Fog.Color, 0.0, 0.0, 0.0, 0.0 );
   ctx->Fog.Index = 0.0;
   ctx->Fog.Density = 1.0;
   ctx->Fog.Start = 0.0;
   ctx->Fog.End = 1.0;

   /* Hint group */
   ctx->Hint.PerspectiveCorrection = GL_DONT_CARE;
   ctx->Hint.PointSmooth = GL_DONT_CARE;
   ctx->Hint.LineSmooth = GL_DONT_CARE;
   ctx->Hint.PolygonSmooth = GL_DONT_CARE;
   ctx->Hint.Fog = GL_DONT_CARE;
   ctx->Hint.AllowDrawWin = GL_TRUE;
   ctx->Hint.AllowDrawFrg = GL_TRUE;
   ctx->Hint.AllowDrawMem = GL_TRUE;
   ctx->Hint.StrictLighting = GL_TRUE;
   ctx->Hint.ClipVolumeClipping = GL_DONT_CARE;
   ctx->Hint.TextureCompression = GL_DONT_CARE;

   /* Histogram group */
   ctx->Histogram.Width = 0;
   ctx->Histogram.Format = GL_RGBA;
   ctx->Histogram.Sink = GL_FALSE;
   ctx->Histogram.RedSize       = 0xffffffff;
   ctx->Histogram.GreenSize     = 0xffffffff;
   ctx->Histogram.BlueSize      = 0xffffffff;
   ctx->Histogram.AlphaSize     = 0xffffffff;
   ctx->Histogram.LuminanceSize = 0xffffffff;
   for (i = 0; i < HISTOGRAM_TABLE_SIZE; i++) {
      ctx->Histogram.Count[i][0] = 0;
      ctx->Histogram.Count[i][1] = 0;
      ctx->Histogram.Count[i][2] = 0;
      ctx->Histogram.Count[i][3] = 0;
   }

   /* Min/Max group */
   ctx->MinMax.Format = GL_RGBA;
   ctx->MinMax.Sink = GL_FALSE;
   ctx->MinMax.Min[RCOMP] = 1000;    ctx->MinMax.Max[RCOMP] = -1000;
   ctx->MinMax.Min[GCOMP] = 1000;    ctx->MinMax.Max[GCOMP] = -1000;
   ctx->MinMax.Min[BCOMP] = 1000;    ctx->MinMax.Max[BCOMP] = -1000;
   ctx->MinMax.Min[ACOMP] = 1000;    ctx->MinMax.Max[ACOMP] = -1000;



   /* Pipeline */
   gl_pipeline_init( ctx );
   gl_cva_init( ctx );

   /* Extensions */
   gl_extensions_ctr( ctx );

   ctx->AllowVertexCull = CLIP_CULLED_BIT;

   /* Lighting group */
   for (i=0;i<MAX_LIGHTS;i++) {
      init_light( &ctx->Light.Light[i], i );
   }
   make_empty_list( &ctx->Light.EnabledList );

   init_lightmodel( &ctx->Light.Model );
   init_material( &ctx->Light.Material[0] );
   init_material( &ctx->Light.Material[1] );
   ctx->Light.ShadeModel = GL_SMOOTH;
   ctx->Light.Enabled = GL_FALSE;
   ctx->Light.ColorMaterialFace = GL_FRONT_AND_BACK;
   ctx->Light.ColorMaterialMode = GL_AMBIENT_AND_DIFFUSE;
   ctx->Light.ColorMaterialBitmask
      = gl_material_bitmask( ctx,
                             GL_FRONT_AND_BACK,
                             GL_AMBIENT_AND_DIFFUSE, ~0, 0 );

   ctx->Light.ColorMaterialEnabled = GL_FALSE;

   /* Lighting miscellaneous */
   ctx->ShineTabList = MALLOC_STRUCT( gl_shine_tab );
   make_empty_list( ctx->ShineTabList );
   for (i = 0 ; i < 10 ; i++) {
      struct gl_shine_tab *s = MALLOC_STRUCT( gl_shine_tab );
      s->shininess = -1;
      s->refcount = 0;
      insert_at_tail( ctx->ShineTabList, s );
   }
   for (i = 0 ; i < 4 ; i++) {
      ctx->ShineTable[i] = ctx->ShineTabList->prev;
      ctx->ShineTable[i]->refcount++;
   }

   gl_compute_shine_table( ctx, 0, ctx->Light.Material[0].Shininess );
   gl_compute_shine_table( ctx, 2, ctx->Light.Material[0].Shininess * .5 );
   gl_compute_shine_table( ctx, 1, ctx->Light.Material[1].Shininess );
   gl_compute_shine_table( ctx, 3, ctx->Light.Material[1].Shininess * .5 );


   /* Line group */
   ctx->Line.SmoothFlag = GL_FALSE;
   ctx->Line.StippleFlag = GL_FALSE;
   ctx->Line.Width = 1.0;
   ctx->Line.StipplePattern = 0xffff;
   ctx->Line.StippleFactor = 1;

   /* Display List group */
   ctx->List.ListBase = 0;

   /* Pixel group */
   ctx->Pixel.RedBias = 0.0;
   ctx->Pixel.RedScale = 1.0;
   ctx->Pixel.GreenBias = 0.0;
   ctx->Pixel.GreenScale = 1.0;
   ctx->Pixel.BlueBias = 0.0;
   ctx->Pixel.BlueScale = 1.0;
   ctx->Pixel.AlphaBias = 0.0;
   ctx->Pixel.AlphaScale = 1.0;
   ctx->Pixel.ScaleOrBiasRGBA = GL_FALSE;
   ctx->Pixel.DepthBias = 0.0;
   ctx->Pixel.DepthScale = 1.0;
   ctx->Pixel.IndexOffset = 0;
   ctx->Pixel.IndexShift = 0;
   ctx->Pixel.ZoomX = 1.0;
   ctx->Pixel.ZoomY = 1.0;
   ctx->Pixel.MapColorFlag = GL_FALSE;
   ctx->Pixel.MapStencilFlag = GL_FALSE;
   ctx->Pixel.MapStoSsize = 1;
   ctx->Pixel.MapItoIsize = 1;
   ctx->Pixel.MapItoRsize = 1;
   ctx->Pixel.MapItoGsize = 1;
   ctx->Pixel.MapItoBsize = 1;
   ctx->Pixel.MapItoAsize = 1;
   ctx->Pixel.MapRtoRsize = 1;
   ctx->Pixel.MapGtoGsize = 1;
   ctx->Pixel.MapBtoBsize = 1;
   ctx->Pixel.MapAtoAsize = 1;
   ctx->Pixel.MapStoS[0] = 0;
   ctx->Pixel.MapItoI[0] = 0;
   ctx->Pixel.MapItoR[0] = 0.0;
   ctx->Pixel.MapItoG[0] = 0.0;
   ctx->Pixel.MapItoB[0] = 0.0;
   ctx->Pixel.MapItoA[0] = 0.0;
   ctx->Pixel.MapItoR8[0] = 0;
   ctx->Pixel.MapItoG8[0] = 0;
   ctx->Pixel.MapItoB8[0] = 0;
   ctx->Pixel.MapItoA8[0] = 0;
   ctx->Pixel.MapRtoR[0] = 0.0;
   ctx->Pixel.MapGtoG[0] = 0.0;
   ctx->Pixel.MapBtoB[0] = 0.0;
   ctx->Pixel.MapAtoA[0] = 0.0;
   ctx->Pixel.HistogramEnabled = GL_FALSE;
   ctx->Pixel.MinMaxEnabled = GL_FALSE;
   ctx->Pixel.PixelTextureEnabled = GL_FALSE;
   ctx->Pixel.FragmentRgbSource = GL_PIXEL_GROUP_COLOR_SGIS;
   ctx->Pixel.FragmentAlphaSource = GL_PIXEL_GROUP_COLOR_SGIS;
   ASSIGN_4V(ctx->Pixel.PostColorMatrixScale, 1.0, 1.0, 1.0, 1.0);
   ASSIGN_4V(ctx->Pixel.PostColorMatrixBias, 0.0, 0.0, 0.0, 0.0);
   ASSIGN_4V(ctx->Pixel.ColorTableScale, 1.0, 1.0, 1.0, 1.0);
   ASSIGN_4V(ctx->Pixel.ColorTableBias, 0.0, 0.0, 0.0, 0.0);
   ASSIGN_4V(ctx->Pixel.PCCTscale, 1.0, 1.0, 1.0, 1.0);
   ASSIGN_4V(ctx->Pixel.PCCTbias, 0.0, 0.0, 0.0, 0.0);
   ASSIGN_4V(ctx->Pixel.PCMCTscale, 1.0, 1.0, 1.0, 1.0);
   ASSIGN_4V(ctx->Pixel.PCMCTbias, 0.0, 0.0, 0.0, 0.0);
   ctx->Pixel.ColorTableEnabled = GL_FALSE;
   ctx->Pixel.PostConvolutionColorTableEnabled = GL_FALSE;
   ctx->Pixel.PostColorMatrixColorTableEnabled = GL_FALSE;
   ctx->Pixel.Convolution1DEnabled = GL_FALSE;
   ctx->Pixel.Convolution2DEnabled = GL_FALSE;
   ctx->Pixel.Separable2DEnabled = GL_FALSE;
   for (i = 0; i < 3; i++) {
      ASSIGN_4V(ctx->Pixel.ConvolutionBorderColor[i], 0.0, 0.0, 0.0, 0.0);
      ctx->Pixel.ConvolutionBorderMode[i] = GL_REDUCE;
      ASSIGN_4V(ctx->Pixel.ConvolutionFilterScale[i], 1.0, 1.0, 1.0, 1.0);
      ASSIGN_4V(ctx->Pixel.ConvolutionFilterBias[i], 0.0, 0.0, 0.0, 0.0);
   }
   ASSIGN_4V(ctx->Pixel.PostConvolutionScale, 1.0, 1.0, 1.0, 1.0);
   ASSIGN_4V(ctx->Pixel.PostConvolutionBias, 0.0, 0.0, 0.0, 0.0);

   /* Point group */
   ctx->Point.SmoothFlag = GL_FALSE;
   ctx->Point.UserSize = 1.0;
   ctx->Point.Size = 1.0;
   ctx->Point.Params[0] = 1.0;
   ctx->Point.Params[1] = 0.0;
   ctx->Point.Params[2] = 0.0;
   ctx->Point.Attenuated = GL_FALSE;
   ctx->Point.MinSize = 0.0;
   ctx->Point.MaxSize = (GLfloat) MAX_POINT_SIZE;
   ctx->Point.Threshold = 1.0;

   /* Polygon group */
   ctx->Polygon.CullFlag = GL_FALSE;
   ctx->Polygon.CullFaceMode = GL_BACK;
   ctx->Polygon.FrontFace = GL_CCW;
   ctx->Polygon.FrontBit = 0;
   ctx->Polygon.FrontMode = GL_FILL;
   ctx->Polygon.BackMode = GL_FILL;
   ctx->Polygon.Unfilled = GL_FALSE;
   ctx->Polygon.SmoothFlag = GL_FALSE;
   ctx->Polygon.StippleFlag = GL_FALSE;
   ctx->Polygon.OffsetFactor = 0.0F;
   ctx->Polygon.OffsetUnits = 0.0F;
   ctx->Polygon.OffsetPoint = GL_FALSE;
   ctx->Polygon.OffsetLine = GL_FALSE;
   ctx->Polygon.OffsetFill = GL_FALSE;

   /* Polygon Stipple group */
   MEMSET( ctx->PolygonStipple, 0xff, 32*sizeof(GLuint) );

   /* Scissor group */
   ctx->Scissor.Enabled = GL_FALSE;
   ctx->Scissor.X = 0;
   ctx->Scissor.Y = 0;
   ctx->Scissor.Width = 0;
   ctx->Scissor.Height = 0;

   /* Stencil group */
   ctx->Stencil.Enabled = GL_FALSE;
   ctx->Stencil.Function = GL_ALWAYS;
   ctx->Stencil.FailFunc = GL_KEEP;
   ctx->Stencil.ZPassFunc = GL_KEEP;
   ctx->Stencil.ZFailFunc = GL_KEEP;
   ctx->Stencil.Ref = 0;
   ctx->Stencil.ValueMask = STENCIL_MAX;
   ctx->Stencil.Clear = 0;
   ctx->Stencil.WriteMask = STENCIL_MAX;

   /* Texture group */
   ctx->Texture.CurrentUnit = 0;      /* multitexture */
   ctx->Texture.CurrentTransformUnit = 0; /* multitexture */
   ctx->Texture.ReallyEnabled = 0;
   for (i=0; i<MAX_TEXTURE_UNITS; i++)
      init_texture_unit( ctx, i );
   ctx->Texture.SharedPalette = GL_FALSE;
   _mesa_init_colortable(&ctx->Texture.Palette);

   /* Transformation group */
   ctx->Transform.MatrixMode = GL_MODELVIEW;
   ctx->Transform.Normalize = GL_FALSE;
   ctx->Transform.RescaleNormals = GL_FALSE;
   for (i=0;i<MAX_CLIP_PLANES;i++) {
      ctx->Transform.ClipEnabled[i] = GL_FALSE;
      ASSIGN_4V( ctx->Transform.EyeUserPlane[i], 0.0, 0.0, 0.0, 0.0 );
   }
   ctx->Transform.AnyClip = GL_FALSE;

   /* Viewport group */
   ctx->Viewport.X = 0;
   ctx->Viewport.Y = 0;
   ctx->Viewport.Width = 0;
   ctx->Viewport.Height = 0;
   ctx->Viewport.Near = 0.0;
   ctx->Viewport.Far = 1.0;
   gl_matrix_ctr(&ctx->Viewport.WindowMap);

#define Sz 10
#define Tz 14
   ctx->Viewport.WindowMap.m[Sz] = 0.5 * ctx->Visual->DepthMaxF;
   ctx->Viewport.WindowMap.m[Tz] = 0.5 * ctx->Visual->DepthMaxF;
#undef Sz
#undef Tz

   ctx->Viewport.WindowMap.flags = MAT_FLAG_GENERAL_SCALE|MAT_FLAG_TRANSLATION;
   ctx->Viewport.WindowMap.type = MATRIX_3D_NO_ROT;

   /* Vertex arrays */
#ifdef VAO
   {
      struct gl_array_object *arrayObj;
      arrayObj = _mesa_alloc_vertex_array_object(ctx, 0);
      ctx->Array.Current = arrayObj;
   }
#else
   ctx->Array.Vertex.Size = 4;
   ctx->Array.Vertex.Type = GL_FLOAT;
   ctx->Array.Vertex.Stride = 0;
   ctx->Array.Vertex.StrideB = 0;
   ctx->Array.Vertex.Ptr = NULL;
   ctx->Array.Vertex.Enabled = GL_FALSE;
   ctx->Array.Normal.Type = GL_FLOAT;
   ctx->Array.Normal.Stride = 0;
   ctx->Array.Normal.StrideB = 0;
   ctx->Array.Normal.Ptr = NULL;
   ctx->Array.Normal.Enabled = GL_FALSE;
   ctx->Array.Color.Size = 4;
   ctx->Array.Color.Type = GL_FLOAT;
   ctx->Array.Color.Stride = 0;
   ctx->Array.Color.StrideB = 0;
   ctx->Array.Color.Ptr = NULL;
   ctx->Array.Color.Enabled = GL_FALSE;
   ctx->Array.Index.Type = GL_FLOAT;
   ctx->Array.Index.Stride = 0;
   ctx->Array.Index.StrideB = 0;
   ctx->Array.Index.Ptr = NULL;
   ctx->Array.Index.Enabled = GL_FALSE;
   for (i = 0; i < MAX_TEXTURE_UNITS; i++) {
      ctx->Array.TexCoord[i].Size = 4;
      ctx->Array.TexCoord[i].Type = GL_FLOAT;
      ctx->Array.TexCoord[i].Stride = 0;
      ctx->Array.TexCoord[i].StrideB = 0;
      ctx->Array.TexCoord[i].Ptr = NULL;
      ctx->Array.TexCoord[i].Enabled = GL_FALSE;
   }
   ctx->Array.TexCoordInterleaveFactor = 1;
   ctx->Array.EdgeFlag.Stride = 0;
   ctx->Array.EdgeFlag.StrideB = 0;
   ctx->Array.EdgeFlag.Ptr = NULL;
   ctx->Array.EdgeFlag.Enabled = GL_FALSE;
#endif
   ctx->Array.ActiveTexture = 0;   /* GL_ARB_multitexture */

   /* Pixel transfer */
   ctx->Pack.Alignment = 4;
   ctx->Pack.RowLength = 0;
   ctx->Pack.ImageHeight = 0;
   ctx->Pack.SkipPixels = 0;
   ctx->Pack.SkipRows = 0;
   ctx->Pack.SkipImages = 0;
   ctx->Pack.SwapBytes = GL_FALSE;
   ctx->Pack.LsbFirst = GL_FALSE;
   ctx->Unpack.Alignment = 4;
   ctx->Unpack.RowLength = 0;
   ctx->Unpack.ImageHeight = 0;
   ctx->Unpack.SkipPixels = 0;
   ctx->Unpack.SkipRows = 0;
   ctx->Unpack.SkipImages = 0;
   ctx->Unpack.SwapBytes = GL_FALSE;
   ctx->Unpack.LsbFirst = GL_FALSE;

   /* Feedback */
   ctx->Feedback.Type = GL_2D;   /* TODO: verify */
   ctx->Feedback.Buffer = NULL;
   ctx->Feedback.BufferSize = 0;
   ctx->Feedback.Count = 0;

   /* Selection/picking */
   ctx->Select.Buffer = NULL;
   ctx->Select.BufferSize = 0;
   ctx->Select.BufferCount = 0;
   ctx->Select.Hits = 0;
   ctx->Select.NameStackDepth = 0;

   /* Optimized Accum buffer */
   ctx->IntegerAccumMode = GL_TRUE;
   ctx->IntegerAccumScaler = 0.0;

   /* Renderer and client attribute stacks */
   ctx->AttribStackDepth = 0;
   ctx->ClientAttribStackDepth = 0;

   /* Display list */
   ctx->CallDepth = 0;
   ctx->ExecuteFlag = GL_TRUE;
   ctx->CompileFlag = GL_FALSE;
   ctx->CurrentListPtr = NULL;
   ctx->CurrentBlock = NULL;
   ctx->CurrentListNum = 0;
   ctx->CurrentPos = 0;

   /* Color tables */
   _mesa_init_colortable(&ctx->ColorTable);
   _mesa_init_colortable(&ctx->ProxyColorTable);
   _mesa_init_colortable(&ctx->PostConvolutionColorTable);
   _mesa_init_colortable(&ctx->ProxyPostConvolutionColorTable);
   _mesa_init_colortable(&ctx->PostColorMatrixColorTable);
   _mesa_init_colortable(&ctx->ProxyPostColorMatrixColorTable);

   /* Miscellaneous */
   ctx->NewState = NEW_ALL;
   ctx->RenderMode = GL_RENDER;
   ctx->StippleCounter = 0;
   ctx->NeedNormals = GL_FALSE;
   ctx->DoViewportMapping = GL_TRUE;

   ctx->NeedEyeCoords = GL_FALSE;
   ctx->NeedEyeNormals = GL_FALSE;
   ctx->vb_proj_matrix = &ctx->ModelProjectMatrix;

   ctx->ErrorValue = (GLenum) GL_NO_ERROR;

   ctx->CatchSignals = GL_TRUE;
   ctx->OcclusionResult = GL_FALSE;
   ctx->OcclusionResultSaved = GL_FALSE;

   /* For debug/development only */
   ctx->NoRaster = getenv("MESA_NO_RASTER") ? GL_TRUE : GL_FALSE;
   ctx->FirstTimeCurrent = GL_TRUE;

   /* Dither disable */
   ctx->NoDither = getenv("MESA_NO_DITHER") ? GL_TRUE : GL_FALSE;
   if (ctx->NoDither) {
      if (getenv("MESA_DEBUG")) {
         fprintf(stderr, "MESA_NO_DITHER set - dithering disabled\n");
      }
      ctx->Color.DitherFlag = GL_FALSE;
   }
}




/*
 * Allocate the proxy textures.  If we run out of memory part way through
 * the allocations clean up and return GL_FALSE.
 * Return:  GL_TRUE=success, GL_FALSE=failure
 */
static GLboolean
alloc_proxy_textures( GLcontext *ctx )
{
   GLboolean out_of_memory;
   GLint i;

   ctx->Texture.Proxy1D = gl_alloc_texture_object(NULL, 0, 1);
   if (!ctx->Texture.Proxy1D) {
      return GL_FALSE;
   }

   ctx->Texture.Proxy2D = gl_alloc_texture_object(NULL, 0, 2);
   if (!ctx->Texture.Proxy2D) {
      gl_free_texture_object(NULL, ctx->Texture.Proxy1D);
      return GL_FALSE;
   }

   ctx->Texture.Proxy3D = gl_alloc_texture_object(NULL, 0, 3);
   if (!ctx->Texture.Proxy3D) {
      gl_free_texture_object(NULL, ctx->Texture.Proxy1D);
      gl_free_texture_object(NULL, ctx->Texture.Proxy2D);
      return GL_FALSE;
   }

   out_of_memory = GL_FALSE;
   for (i=0;i<MAX_TEXTURE_LEVELS;i++) {
      ctx->Texture.Proxy1D->Image[i] = _mesa_alloc_texture_image();
      ctx->Texture.Proxy2D->Image[i] = _mesa_alloc_texture_image();
      ctx->Texture.Proxy3D->Image[i] = _mesa_alloc_texture_image();
      if (!ctx->Texture.Proxy1D->Image[i]
          || !ctx->Texture.Proxy2D->Image[i]
          || !ctx->Texture.Proxy3D->Image[i]) {
         out_of_memory = GL_TRUE;
      }
   }
   if (out_of_memory) {
      for (i=0;i<MAX_TEXTURE_LEVELS;i++) {
         if (ctx->Texture.Proxy1D->Image[i]) {
            _mesa_free_texture_image(ctx->Texture.Proxy1D->Image[i]);
         }
         if (ctx->Texture.Proxy2D->Image[i]) {
            _mesa_free_texture_image(ctx->Texture.Proxy2D->Image[i]);
         }
         if (ctx->Texture.Proxy3D->Image[i]) {
            _mesa_free_texture_image(ctx->Texture.Proxy3D->Image[i]);
         }
      }
      gl_free_texture_object(NULL, ctx->Texture.Proxy1D);
      gl_free_texture_object(NULL, ctx->Texture.Proxy2D);
      gl_free_texture_object(NULL, ctx->Texture.Proxy3D);
      return GL_FALSE;
   }
   else {
      return GL_TRUE;
   }
}



/*
 * Initialize a GLcontext struct.  This includes allocating all the
 * other structs and arrays which hang off of the context by pointers.
 */
GLboolean
_mesa_initialize_context( GLcontext *ctx,
                          GLvisual *visual,
                          GLcontext *share_list,
                          void *driver_ctx,
                          GLboolean direct )
{
   GLuint dispatchSize;

   (void) direct;  /* not used */

   /* misc one-time initializations */
   one_time_init();

   ctx->DriverCtx = driver_ctx;
   ctx->Visual = visual;
   ctx->DrawBuffer = NULL;
   ctx->ReadBuffer = NULL;

   ctx->VB = gl_vb_create_for_immediate( ctx );
   if (!ctx->VB) {
      return GL_FALSE;
   }
   ctx->input = ctx->VB->IM;

   ctx->PB = gl_alloc_pb();
   if (!ctx->PB) {
      ALIGN_FREE( ctx->VB );
      return GL_FALSE;
   }

   if (share_list) {
      /* share the group of display lists of another context */
      ctx->Shared = share_list->Shared;
   }
   else {
      /* allocate new group of display lists */
      ctx->Shared = alloc_shared_state();
      if (!ctx->Shared) {
         ALIGN_FREE( ctx->VB );
         FREE( ctx->PB );
         return GL_FALSE;
      }
   }
   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
   ctx->Shared->RefCount++;
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);

   init_attrib_groups( ctx );

   gl_reset_vb( ctx->VB );
   gl_reset_input( ctx );

   if (visual->DBflag) {
      ctx->Color.DrawBuffer = GL_BACK;
      ctx->Color.DriverDrawBuffer = GL_BACK_LEFT;
      ctx->Color.DrawDestMask = BACK_LEFT_BIT;
      ctx->Pixel.ReadBuffer = GL_BACK;
      ctx->Pixel.DriverReadBuffer = GL_BACK_LEFT;
   }
   else {
      ctx->Color.DrawBuffer = GL_FRONT;
      ctx->Color.DriverDrawBuffer = GL_FRONT_LEFT;
      ctx->Color.DrawDestMask = FRONT_LEFT_BIT;
      ctx->Pixel.ReadBuffer = GL_FRONT;
      ctx->Pixel.DriverReadBuffer = GL_FRONT_LEFT;
   }

   if (!alloc_proxy_textures(ctx)) {
      free_shared_state(ctx, ctx->Shared);
      ALIGN_FREE( ctx->VB );
      FREE( ctx->PB );
      return GL_FALSE;
   }

   /* register the most recent extension functions with libGL */
   _glapi_add_entrypoint("glTbufferMask3DFX", 553);
   _glapi_add_entrypoint("glCompressedTexImage3DARB", 554);
   _glapi_add_entrypoint("glCompressedTexImage2DARB", 555);
   _glapi_add_entrypoint("glCompressedTexImage1DARB", 556);
   _glapi_add_entrypoint("glCompressedTexSubImage3DARB", 557);
   _glapi_add_entrypoint("glCompressedTexSubImage2DARB", 558);
   _glapi_add_entrypoint("glCompressedTexSubImage1DARB", 559);
   _glapi_add_entrypoint("glGetCompressedTexImageARB", 560);

   /* Find the larger of Mesa's dispatch table and libGL's dispatch table.
    * In practice, this'll be the same for stand-alone Mesa.  But for DRI
    * Mesa we do this to accomodate different versions of libGL and various
    * DRI drivers.
    */
   dispatchSize = MAX2(_glapi_get_dispatch_table_size(),
                       sizeof(struct _glapi_table) / sizeof(void *));

   /* setup API dispatch tables */
   ctx->Exec = (struct _glapi_table *) CALLOC(dispatchSize * sizeof(void*));
   ctx->Save = (struct _glapi_table *) CALLOC(dispatchSize * sizeof(void*));
   if (!ctx->Exec || !ctx->Save) {
      free_shared_state(ctx, ctx->Shared);
      ALIGN_FREE( ctx->VB );
      FREE( ctx->PB );
      if (ctx->Exec)
         FREE( ctx->Exec );
   }
   _mesa_init_exec_table(ctx->Exec, dispatchSize);
   _mesa_init_dlist_table(ctx->Save, dispatchSize);
   ctx->CurrentDispatch = ctx->Exec;

   return GL_TRUE;
}



/*
 * Allocate and initialize a GLcontext structure.
 * Input:  visual - a GLvisual pointer
 *         sharelist - another context to share display lists with or NULL
 *         driver_ctx - pointer to device driver's context state struct
 * Return:  pointer to a new gl_context struct or NULL if error.
 */
GLcontext *
gl_create_context( GLvisual *visual,
                   GLcontext *share_list,
                   void *driver_ctx,
                   GLboolean direct )
{
   GLcontext *ctx = (GLcontext *) CALLOC( sizeof(GLcontext) );
   if (!ctx) {
      return NULL;
   }

   if (_mesa_initialize_context(ctx, visual, share_list, driver_ctx, direct)) {
      return ctx;
   }
   else {
      FREE(ctx);
      return NULL;
   }
}



/*
 * Free the data associated with the given context.
 * But don't free() the GLcontext struct itself!
 */
void
gl_free_context_data( GLcontext *ctx )
{
   struct gl_shine_tab *s, *tmps;
   GLuint i, j;

   /* if we're destroying the current context, unbind it first */
   if (ctx == gl_get_current_context()) {
      gl_make_current(NULL, NULL);
   }

   gl_matrix_dtr( &ctx->ModelView );
   for (i = 0; i < MAX_MODELVIEW_STACK_DEPTH - 1; i++) {
      gl_matrix_dtr( &ctx->ModelViewStack[i] );
   }
   gl_matrix_dtr( &ctx->ProjectionMatrix );
   for (i = 0; i < MAX_PROJECTION_STACK_DEPTH - 1; i++) {
      gl_matrix_dtr( &ctx->ProjectionStack[i] );
   }
   for (i = 0; i < MAX_TEXTURE_UNITS; i++) {
      gl_matrix_dtr( &ctx->TextureMatrix[i] );
      for (j = 0; j < MAX_TEXTURE_STACK_DEPTH - 1; j++) {
         gl_matrix_dtr( &ctx->TextureStack[i][j] );
      }
   }

   FREE( ctx->PB );

   if (ctx->input != ctx->VB->IM)
      gl_immediate_free( ctx->input );

   gl_vb_free( ctx->VB );

   _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
   ctx->Shared->RefCount--;
   assert(ctx->Shared->RefCount >= 0);
   _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
   if (ctx->Shared->RefCount == 0) {
      /* free shared state */
      free_shared_state( ctx, ctx->Shared );
   }

   foreach_s( s, tmps, ctx->ShineTabList ) {
      FREE( s );
   }
   FREE( ctx->ShineTabList );

   /* Free proxy texture objects */
   gl_free_texture_object( NULL, ctx->Texture.Proxy1D );
   gl_free_texture_object( NULL, ctx->Texture.Proxy2D );
   gl_free_texture_object( NULL, ctx->Texture.Proxy3D );

   /* Free evaluator data */
   if (ctx->EvalMap.Map1Vertex3.Points)
      FREE( ctx->EvalMap.Map1Vertex3.Points );
   if (ctx->EvalMap.Map1Vertex4.Points)
      FREE( ctx->EvalMap.Map1Vertex4.Points );
   if (ctx->EvalMap.Map1Index.Points)
      FREE( ctx->EvalMap.Map1Index.Points );
   if (ctx->EvalMap.Map1Color4.Points)
      FREE( ctx->EvalMap.Map1Color4.Points );
   if (ctx->EvalMap.Map1Normal.Points)
      FREE( ctx->EvalMap.Map1Normal.Points );
   if (ctx->EvalMap.Map1Texture1.Points)
      FREE( ctx->EvalMap.Map1Texture1.Points );
   if (ctx->EvalMap.Map1Texture2.Points)
      FREE( ctx->EvalMap.Map1Texture2.Points );
   if (ctx->EvalMap.Map1Texture3.Points)
      FREE( ctx->EvalMap.Map1Texture3.Points );
   if (ctx->EvalMap.Map1Texture4.Points)
      FREE( ctx->EvalMap.Map1Texture4.Points );

   if (ctx->EvalMap.Map2Vertex3.Points)
      FREE( ctx->EvalMap.Map2Vertex3.Points );
   if (ctx->EvalMap.Map2Vertex4.Points)
      FREE( ctx->EvalMap.Map2Vertex4.Points );
   if (ctx->EvalMap.Map2Index.Points)
      FREE( ctx->EvalMap.Map2Index.Points );
   if (ctx->EvalMap.Map2Color4.Points)
      FREE( ctx->EvalMap.Map2Color4.Points );
   if (ctx->EvalMap.Map2Normal.Points)
      FREE( ctx->EvalMap.Map2Normal.Points );
   if (ctx->EvalMap.Map2Texture1.Points)
      FREE( ctx->EvalMap.Map2Texture1.Points );
   if (ctx->EvalMap.Map2Texture2.Points)
      FREE( ctx->EvalMap.Map2Texture2.Points );
   if (ctx->EvalMap.Map2Texture3.Points)
      FREE( ctx->EvalMap.Map2Texture3.Points );
   if (ctx->EvalMap.Map2Texture4.Points)
      FREE( ctx->EvalMap.Map2Texture4.Points );

   _mesa_free_colortable_data( &ctx->ColorTable );
   _mesa_free_colortable_data( &ctx->PostConvolutionColorTable );
   _mesa_free_colortable_data( &ctx->PostColorMatrixColorTable );
   _mesa_free_colortable_data( &ctx->Texture.Palette );

   /* Free cache of immediate buffers. */
   while (ctx->nr_im_queued-- > 0) {
      struct immediate * next = ctx->freed_im_queue->next;
      ALIGN_FREE( ctx->freed_im_queue );
      ctx->freed_im_queue = next;
   }
   gl_extensions_dtr(ctx);

   FREE(ctx->Exec);
   FREE(ctx->Save);
}



/*
 * Destroy a GLcontext structure.
 */
void
gl_destroy_context( GLcontext *ctx )
{
   if (ctx) {
      gl_free_context_data(ctx);
      FREE( (void *) ctx );
   }
}



/*
 * Called by the driver after both the context and driver are fully
 * initialized.  Currently just reads the config file.
 */
void
gl_context_initialize( GLcontext *ctx )
{
   gl_read_config_file( ctx );
}



/*
 * Copy attribute groups from one context to another.
 * Input:  src - source context
 *         dst - destination context
 *         mask - bitwise OR of GL_*_BIT flags
 */
void
gl_copy_context( const GLcontext *src, GLcontext *dst, GLuint mask )
{
   if (mask & GL_ACCUM_BUFFER_BIT) {
      MEMCPY( &dst->Accum, &src->Accum, sizeof(struct gl_accum_attrib) );
   }
   if (mask & GL_COLOR_BUFFER_BIT) {
      MEMCPY( &dst->Color, &src->Color, sizeof(struct gl_colorbuffer_attrib) );
   }
   if (mask & GL_CURRENT_BIT) {
      MEMCPY( &dst->Current, &src->Current, sizeof(struct gl_current_attrib) );
   }
   if (mask & GL_DEPTH_BUFFER_BIT) {
      MEMCPY( &dst->Depth, &src->Depth, sizeof(struct gl_depthbuffer_attrib) );
   }
   if (mask & GL_ENABLE_BIT) {
      /* no op */
   }
   if (mask & GL_EVAL_BIT) {
      MEMCPY( &dst->Eval, &src->Eval, sizeof(struct gl_eval_attrib) );
   }
   if (mask & GL_FOG_BIT) {
      MEMCPY( &dst->Fog, &src->Fog, sizeof(struct gl_fog_attrib) );
   }
   if (mask & GL_HINT_BIT) {
      MEMCPY( &dst->Hint, &src->Hint, sizeof(struct gl_hint_attrib) );
   }
   if (mask & GL_LIGHTING_BIT) {
      MEMCPY( &dst->Light, &src->Light, sizeof(struct gl_light_attrib) );
      /*       gl_reinit_light_attrib( &dst->Light ); */
   }
   if (mask & GL_LINE_BIT) {
      MEMCPY( &dst->Line, &src->Line, sizeof(struct gl_line_attrib) );
   }
   if (mask & GL_LIST_BIT) {
      MEMCPY( &dst->List, &src->List, sizeof(struct gl_list_attrib) );
   }
   if (mask & GL_PIXEL_MODE_BIT) {
      MEMCPY( &dst->Pixel, &src->Pixel, sizeof(struct gl_pixel_attrib) );
   }
   if (mask & GL_POINT_BIT) {
      MEMCPY( &dst->Point, &src->Point, sizeof(struct gl_point_attrib) );
   }
   if (mask & GL_POLYGON_BIT) {
      MEMCPY( &dst->Polygon, &src->Polygon, sizeof(struct gl_polygon_attrib) );
   }
   if (mask & GL_POLYGON_STIPPLE_BIT) {
      /* Use loop instead of MEMCPY due to problem with Portland Group's
       * C compiler.  Reported by John Stone.
       */
      int i;
      for (i=0;i<32;i++) {
         dst->PolygonStipple[i] = src->PolygonStipple[i];
      }
   }
   if (mask & GL_SCISSOR_BIT) {
      MEMCPY( &dst->Scissor, &src->Scissor, sizeof(struct gl_scissor_attrib) );
   }
   if (mask & GL_STENCIL_BUFFER_BIT) {
      MEMCPY( &dst->Stencil, &src->Stencil, sizeof(struct gl_stencil_attrib) );
   }
   if (mask & GL_TEXTURE_BIT) {
      MEMCPY( &dst->Texture, &src->Texture, sizeof(struct gl_texture_attrib) );
   }
   if (mask & GL_TRANSFORM_BIT) {
      MEMCPY( &dst->Transform, &src->Transform, sizeof(struct gl_transform_attrib) );
   }
   if (mask & GL_VIEWPORT_BIT) {
      MEMCPY( &dst->Viewport, &src->Viewport, sizeof(struct gl_viewport_attrib) );
   }
}


/*
 * Set the current context, binding the given frame buffer to the context.
 */
void gl_make_current( GLcontext *newCtx, GLframebuffer *buffer )
{
   gl_make_current2( newCtx, buffer, buffer );
}


/*
 * Bind the given context to the given draw-buffer and read-buffer
 * and make it the current context for this thread.
 */
void gl_make_current2( GLcontext *newCtx, GLframebuffer *drawBuffer,
                       GLframebuffer *readBuffer )
{
#if 0
   GLcontext *oldCtx = gl_get_context();

   /* Flush the old context
    */
   if (oldCtx) {
      ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(oldCtx, "gl_make_current");

      /* unbind frame buffers from context */
      if (oldCtx->DrawBuffer) {
         oldCtx->DrawBuffer = NULL;
      }
      if (oldCtx->ReadBuffer) {
         oldCtx->ReadBuffer = NULL;
      }
   }
#endif

   /* We call this function periodically (just here for now) in
    * order to detect when multithreading has begun.
    */
   _glapi_check_multithread();

   _glapi_set_context((void *) newCtx);
   ASSERT(gl_get_current_context() == newCtx);
   if (newCtx) {
      SET_IMMEDIATE(newCtx, newCtx->input);
      _glapi_set_dispatch(newCtx->CurrentDispatch);
   }
   else {
      _glapi_set_dispatch(NULL);  /* none current */
   }

   if (MESA_VERBOSE) fprintf(stderr, "gl_make_current()\n");

   if (newCtx && drawBuffer && readBuffer) {
      /* TODO: check if newCtx and buffer's visual match??? */
      newCtx->DrawBuffer = drawBuffer;
      newCtx->ReadBuffer = readBuffer;
      newCtx->NewState = NEW_ALL;   /* just to be safe */
      gl_update_state( newCtx );
   }

   /* We can use this to help debug user's problems.  Tell the to set
    * the MESA_INFO env variable before running their app.  Then the
    * first time each context is made current we'll print some useful
    * information.
    */
   if (newCtx && newCtx->FirstTimeCurrent) {
      if (getenv("MESA_INFO")) {
         fprintf(stderr, "Mesa GL_VERSION = %s\n", (char *) _mesa_GetString(GL_VERSION));
         fprintf(stderr, "Mesa GL_RENDERER = %s\n", (char *) _mesa_GetString(GL_RENDERER));
         fprintf(stderr, "Mesa GL_VENDOR = %s\n", (char *) _mesa_GetString(GL_VENDOR));
         fprintf(stderr, "Mesa GL_EXTENSIONS = %s\n", (char *) _mesa_GetString(GL_EXTENSIONS));
#if defined(THREADS)
         fprintf(stderr, "Mesa thread-safe: YES\n");
#else
         fprintf(stderr, "Mesa thread-safe: NO\n");
#endif
#if defined(USE_X86_ASM)
         fprintf(stderr, "Mesa x86-optimized: YES\n");
#else
         fprintf(stderr, "Mesa x86-optimized: NO\n");
#endif
      }
      newCtx->FirstTimeCurrent = GL_FALSE;
   }
}



/*
 * Return current context handle for the calling thread.
 * This isn't the fastest way to get the current context.
 * If you need speed, see the GET_CURRENT_CONTEXT() macro in context.h
 */
GLcontext *gl_get_current_context( void )
{
   return (GLcontext *) _glapi_get_context();
}



/*
 * This should be called by device drivers just before they do a
 * swapbuffers.  Any pending rendering commands will be executed.
 */
void
_mesa_swapbuffers(GLcontext *ctx)
{
   FLUSH_VB( ctx, "swap buffers" );
}



/*
 * Return pointer to this context's current API dispatch table.
 * It'll either be the immediate-mode execute dispatcher or the
 * display list compile dispatcher.
 */
struct _glapi_table *
_mesa_get_dispatch(GLcontext *ctx)
{
   return ctx->CurrentDispatch;
}



/**********************************************************************/
/*****                Miscellaneous functions                     *****/
/**********************************************************************/


/*
 * This function is called when the Mesa user has stumbled into a code
 * path which may not be implemented fully or correctly.
 */
void gl_problem( const GLcontext *ctx, const char *s )
{
   fprintf( stderr, "Mesa implementation error: %s\n", s );
#ifdef XF86DRI
   fprintf( stderr, "Please report to the DRI bug database at dri.sourceforge.net\n");
#else
   fprintf( stderr, "Please report to the Mesa bug database at www.mesa3d.org\n" );
#endif
   (void) ctx;
}



/*
 * This is called to inform the user that he or she has tried to do
 * something illogical or if there's likely a bug in their program
 * (like enabled depth testing without a depth buffer).
 */
void gl_warning( const GLcontext *ctx, const char *s )
{
   GLboolean debug;
#ifdef DEBUG
   debug = GL_TRUE;
#else
   if (getenv("MESA_DEBUG")) {
      debug = GL_TRUE;
   }
   else {
      debug = GL_FALSE;
   }
#endif
   if (debug) {
      fprintf( stderr, "Mesa warning: %s\n", s );
   }
   (void) ctx;
}



/*
 * Compile an error into current display list.
 */
void gl_compile_error( GLcontext *ctx, GLenum error, const char *s )
{
   if (ctx->CompileFlag)
      gl_save_error( ctx, error, s );

   if (ctx->ExecuteFlag)
      gl_error( ctx, error, s );
}



/*
 * This is Mesa's error handler.  Normally, all that's done is the updating
 * of the current error value.  If Mesa is compiled with -DDEBUG or if the
 * environment variable "MESA_DEBUG" is defined then a real error message
 * is printed to stderr.
 * Input:  ctx - the GL context
 *         error - the error value
 *         where - usually the name of function where error was detected
 */
void
gl_error( GLcontext *ctx, GLenum error, const char *where )
{
   const char *debugEnv = getenv("MESA_DEBUG");
   GLboolean debug;

#ifdef DEBUG
   if (debugEnv && strstr(debugEnv, "silent"))
      debug = GL_FALSE;
   else
      debug = GL_TRUE;
#else
   if (debugEnv)
      debug = GL_TRUE;
   else
      debug = GL_FALSE;
#endif

   if (debug) {
      const char *errstr;
      switch (error) {
	 case GL_NO_ERROR:
	    errstr = "GL_NO_ERROR";
	    break;
	 case GL_INVALID_VALUE:
	    errstr = "GL_INVALID_VALUE";
	    break;
	 case GL_INVALID_ENUM:
	    errstr = "GL_INVALID_ENUM";
	    break;
	 case GL_INVALID_OPERATION:
	    errstr = "GL_INVALID_OPERATION";
	    break;
	 case GL_STACK_OVERFLOW:
	    errstr = "GL_STACK_OVERFLOW";
	    break;
	 case GL_STACK_UNDERFLOW:
	    errstr = "GL_STACK_UNDERFLOW";
	    break;
	 case GL_OUT_OF_MEMORY:
	    errstr = "GL_OUT_OF_MEMORY";
	    break;
         case GL_TABLE_TOO_LARGE:
            errstr = "GL_TABLE_TOO_LARGE";
            break;
	 default:
	    errstr = "unknown";
	    break;
      }
      fprintf(stderr, "Mesa user error: %s in %s\n", errstr, where);
   }

   if (ctx->ErrorValue == GL_NO_ERROR) {
      ctx->ErrorValue = error;
   }

   /* Call device driver's error handler, if any.  This is used on the Mac. */
   if (ctx->Driver.Error) {
      (*ctx->Driver.Error)( ctx );
   }
}



void
_mesa_Finish( void )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glFinish");
   if (ctx->Driver.Finish) {
      (*ctx->Driver.Finish)( ctx );
   }
}



void
_mesa_Flush( void )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glFlush");
   if (ctx->Driver.Flush) {
      (*ctx->Driver.Flush)( ctx );
   }
}
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d4 1
a4 1
 * Version:  4.1
d6 1
a6 1
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
d27 3
d31 2
a32 2
#include "imports.h"
#include "buffers.h"
d36 2
d44 2
d50 2
d53 3
d57 2
d60 1
d64 2
a65 1
#include "mtypes.h"
d67 6
a72 2
#if FEATURE_NV_vertex_program
#include "vpstate.h"
a73 6
#include "vtxfmt.h"
#include "math/m_translate.h"
#include "math/m_matrix.h"
#include "math/m_xform.h"
#include "math/mathmod.h"

a74 20
#if defined(MESA_TRACE)
#include "Trace/tr_context.h"
#include "Trace/tr_wrapper.h"
#endif

#ifdef USE_SPARC_ASM
#include "SPARC/sparc.h"
#endif

#ifndef MESA_VERBOSE
int MESA_VERBOSE = 0;
#endif

#ifndef MESA_DEBUG_FLAGS
int MESA_DEBUG_FLAGS = 0;
#endif


static void
free_shared_state( GLcontext *ctx, struct gl_shared_state *ss );
d78 1
a78 1
/*****       OpenGL SI-style interface (new in Mesa 3.5)          *****/
a80 32
/* Called by window system/device driver (via gc->exports.destroyCurrent())
 * when the rendering context is to be destroyed.
 */
GLboolean
_mesa_destroyContext(__GLcontext *gc)
{
   if (gc) {
      _mesa_free_context_data(gc);
      _mesa_free(gc);
   }
   return GL_TRUE;
}

/* Called by window system/device driver (via gc->exports.loseCurrent())
 * when the rendering context is made non-current.
 */
GLboolean
_mesa_loseCurrent(__GLcontext *gc)
{
   /* XXX unbind context from thread */
   return GL_TRUE;
}

/* Called by window system/device driver (via gc->exports.makeCurrent())
 * when the rendering context is made current.
 */
GLboolean
_mesa_makeCurrent(__GLcontext *gc)
{
   /* XXX bind context to thread */
   return GL_TRUE;
}
d82 1
a82 19
/* Called by window system/device driver - yadda, yadda, yadda.
 * See above comments.
 */
GLboolean
_mesa_shareContext(__GLcontext *gc, __GLcontext *gcShare)
{
   if (gc && gcShare && gc->Shared && gcShare->Shared) {
      gc->Shared->RefCount--;
      if (gc->Shared->RefCount == 0) {
         free_shared_state(gc, gc->Shared);
      }
      gc->Shared = gcShare->Shared;
      gc->Shared->RefCount++;
      return GL_TRUE;
   }
   else {
      return GL_FALSE;
   }
}
d84 1
a84 11
GLboolean
_mesa_copyContext(__GLcontext *dst, const __GLcontext *src, GLuint mask)
{
   if (dst && src) {
      _mesa_copy_context( src, dst, mask );
      return GL_TRUE;
   }
   else {
      return GL_FALSE;
   }
}
a85 106
GLboolean
_mesa_forceCurrent(__GLcontext *gc)
{
   return GL_TRUE;
}

GLboolean
_mesa_notifyResize(__GLcontext *gc)
{
   GLint x, y;
   GLuint width, height;
   __GLdrawablePrivate *d = gc->imports.getDrawablePrivate(gc);
   if (!d || !d->getDrawableSize)
      return GL_FALSE;
   d->getDrawableSize( d, &x, &y, &width, &height );
   /* update viewport, resize software buffers, etc. */
   return GL_TRUE;
}

void
_mesa_notifyDestroy(__GLcontext *gc)
{
   /* Called when the context's window/buffer is going to be destroyed. */
   /* Unbind from it. */
}

/* Called by window system just before swapping buffers.
 * We have to finish any pending rendering.
 */
void
_mesa_notifySwapBuffers(__GLcontext *gc)
{
   FLUSH_VERTICES( gc, 0 );
}

struct __GLdispatchStateRec *
_mesa_dispatchExec(__GLcontext *gc)
{
   return NULL;
}

void
_mesa_beginDispatchOverride(__GLcontext *gc)
{
}

void
_mesa_endDispatchOverride(__GLcontext *gc)
{
}

/* Setup the exports.  The window system will call these functions
 * when it needs Mesa to do something.
 * NOTE: Device drivers should override these functions!  For example,
 * the Xlib driver should plug in the XMesa*-style functions into this
 * structure.  The XMesa-style functions should then call the _mesa_*
 * version of these functions.  This is an approximation to OO design
 * (inheritance and virtual functions).
 */
static void
_mesa_init_default_exports(__GLexports *exports)
{
    exports->destroyContext = _mesa_destroyContext;
    exports->loseCurrent = _mesa_loseCurrent;
    exports->makeCurrent = _mesa_makeCurrent;
    exports->shareContext = _mesa_shareContext;
    exports->copyContext = _mesa_copyContext;
    exports->forceCurrent = _mesa_forceCurrent;
    exports->notifyResize = _mesa_notifyResize;
    exports->notifyDestroy = _mesa_notifyDestroy;
    exports->notifySwapBuffers = _mesa_notifySwapBuffers;
    exports->dispatchExec = _mesa_dispatchExec;
    exports->beginDispatchOverride = _mesa_beginDispatchOverride;
    exports->endDispatchOverride = _mesa_endDispatchOverride;
}



/* exported OpenGL SI interface */
__GLcontext *
__glCoreCreateContext(__GLimports *imports, __GLcontextModes *modes)
{
    GLcontext *ctx;

    ctx = (GLcontext *) (*imports->calloc)(NULL, 1, sizeof(GLcontext));
    if (ctx == NULL) {
	return NULL;
    }

    _mesa_initialize_context(ctx, modes, NULL, imports, GL_FALSE);
    ctx->imports = *imports;

    return ctx;
}


/* exported OpenGL SI interface */
void
__glCoreNopDispatch(void)
{
#if 0
   /* SI */
   __gl_dispatch = __glNopDispatchState;
#else
   /* Mesa */
   _glapi_set_dispatch(NULL);
a86 1
}
d135 1
a135 1
                                   numSamples)) {
a167 2
   (void) numSamples;

d195 36
a230 24
   vis->rgbMode          = rgbFlag;
   vis->doubleBufferMode = dbFlag;
   vis->stereoMode       = stereoFlag;

   vis->redBits          = redBits;
   vis->greenBits        = greenBits;
   vis->blueBits         = blueBits;
   vis->alphaBits        = alphaBits;

   vis->indexBits      = indexBits;
   vis->depthBits      = depthBits;
   vis->accumRedBits   = (accumRedBits > 0) ? (8 * sizeof(GLaccum)) : 0;
   vis->accumGreenBits = (accumGreenBits > 0) ? (8 * sizeof(GLaccum)) : 0;
   vis->accumBlueBits  = (accumBlueBits > 0) ? (8 * sizeof(GLaccum)) : 0;
   vis->accumAlphaBits = (accumAlphaBits > 0) ? (8 * sizeof(GLaccum)) : 0;
   vis->stencilBits    = (stencilBits > 0) ? (8 * sizeof(GLstencil)) : 0;

   vis->haveAccumBuffer   = accumRedBits > 0;
   vis->haveDepthBuffer   = depthBits > 0;
   vis->haveStencilBuffer = stencilBits > 0;

   vis->numAuxBuffers = 0;
   vis->level = 0;
   vis->pixmapMode = 0;
d236 23
d266 9
d284 1
a284 1
 * Input:  visual - a GLvisual pointer (we copy the struct contents)
d289 1
d293 5
a297 5
_mesa_create_framebuffer( const GLvisual *visual,
                          GLboolean softwareDepth,
                          GLboolean softwareStencil,
                          GLboolean softwareAccum,
                          GLboolean softwareAlpha )
d312 1
a312 1
 * Input:  See _mesa_create_framebuffer() above.
d316 1
a316 1
                              const GLvisual *visual,
a324 2
   _mesa_bzero(buffer, sizeof(GLframebuffer));

d327 1
a327 1
      assert(visual->depthBits > 0);
d330 1
a330 1
      assert(visual->stencilBits > 0);
d333 4
a336 4
      assert(visual->rgbMode);
      assert(visual->accumRedBits > 0);
      assert(visual->accumGreenBits > 0);
      assert(visual->accumBlueBits > 0);
d339 2
a340 2
      assert(visual->rgbMode);
      assert(visual->alphaBits > 0);
d343 1
a343 1
   buffer->Visual = *visual;
d355 1
a355 1
_mesa_destroy_framebuffer( GLframebuffer *buffer )
d358 21
a378 1
      _mesa_free_framebuffer_data(buffer);
a383 40
/*
 * Free the data hanging off of <buffer>, but not <buffer> itself.
 */
void
_mesa_free_framebuffer_data( GLframebuffer *buffer )
{
   if (!buffer)
      return;

   if (buffer->DepthBuffer) {
      MESA_PBUFFER_FREE( buffer->DepthBuffer );
      buffer->DepthBuffer = NULL;
   }
   if (buffer->Accum) {
      MESA_PBUFFER_FREE( buffer->Accum );
      buffer->Accum = NULL;
   }
   if (buffer->Stencil) {
      MESA_PBUFFER_FREE( buffer->Stencil );
      buffer->Stencil = NULL;
   }
   if (buffer->FrontLeftAlpha) {
      MESA_PBUFFER_FREE( buffer->FrontLeftAlpha );
      buffer->FrontLeftAlpha = NULL;
   }
   if (buffer->BackLeftAlpha) {
      MESA_PBUFFER_FREE( buffer->BackLeftAlpha );
      buffer->BackLeftAlpha = NULL;
   }
   if (buffer->FrontRightAlpha) {
      MESA_PBUFFER_FREE( buffer->FrontRightAlpha );
      buffer->FrontRightAlpha = NULL;
   }
   if (buffer->BackRightAlpha) {
      MESA_PBUFFER_FREE( buffer->BackRightAlpha );
      buffer->BackRightAlpha = NULL;
   }
}


d397 1
a397 1
one_time_init( GLcontext *ctx )
d410 3
a412 3
      _mesa_init_lists();

      _math_init();
d414 8
d423 1
a423 4
#ifdef USE_SPARC_ASM
      _mesa_init_sparc_glapi_relocs();
#endif
      if (_mesa_getenv("MESA_DEBUG")) {
a424 7
#ifndef GLX_DIRECT_RENDERING
         /* libGL from before 2002/06/28 don't have this function.  Someday,
          * when newer libGL libs are common, remove the #ifdef test.  This
          * only serves to print warnings when calling undefined GL functions.
          */
         _glapi_set_warning_func( (_glapi_warning_func) _mesa_warning );
#endif
d431 1
a431 1
      _mesa_debug(ctx, "Mesa DEBUG build %s %s\n", __DATE__, __TIME__);
a439 30
static void
init_matrix_stack( struct matrix_stack *stack,
                   GLuint maxDepth, GLuint dirtyFlag )
{
   GLuint i;

   stack->Depth = 0;
   stack->MaxDepth = maxDepth;
   stack->DirtyFlag = dirtyFlag;
   /* The stack */
   stack->Stack = (GLmatrix *) CALLOC(maxDepth * sizeof(GLmatrix));
   for (i = 0; i < maxDepth; i++) {
      _math_matrix_ctr(&stack->Stack[i]);
      _math_matrix_alloc_inv(&stack->Stack[i]);
   }
   stack->Top = stack->Stack;
}


static void
free_matrix_stack( struct matrix_stack *stack )
{
   GLuint i;
   for (i = 0; i < stack->MaxDepth; i++) {
      _math_matrix_dtr(&stack->Stack[i]);
   }
   FREE(stack->Stack);
   stack->Stack = stack->Top = NULL;
}

d447 1
d459 2
a460 2
#if FEATURE_NV_vertex_program
   ss->VertexPrograms = _mesa_NewHashTable();
d465 7
a471 4

   ss->Default1D = _mesa_alloc_texture_object(ss, 0, GL_TEXTURE_1D);
   if (!ss->Default1D) {
      outOfMemory = GL_TRUE;
d474 1
a474 12
   ss->Default2D = _mesa_alloc_texture_object(ss, 0, GL_TEXTURE_2D);
   if (!ss->Default2D) {
      outOfMemory = GL_TRUE;
   }

   ss->Default3D = _mesa_alloc_texture_object(ss, 0, GL_TEXTURE_3D);
   if (!ss->Default3D) {
      outOfMemory = GL_TRUE;
   }

   ss->DefaultCubeMap = _mesa_alloc_texture_object(ss, 0,
                                                   GL_TEXTURE_CUBE_MAP_ARB);
d478 2
a479 5

   ss->DefaultRect = _mesa_alloc_texture_object(ss, 0,
                                                GL_TEXTURE_RECTANGLE_NV);
   if (!ss->DefaultRect) {
      outOfMemory = GL_TRUE;
d482 1
a482 5
   if (!ss->DisplayList || !ss->TexObjects
#if FEATURE_NV_vertex_program
       || !ss->VertexPrograms
#endif
       || outOfMemory) {
d488 6
a493 8
      if (ss->VertexPrograms)
         _mesa_DeleteHashTable(ss->VertexPrograms);
      if (ss->Default1D)
         _mesa_free_texture_object(ss, ss->Default1D);
      if (ss->Default2D)
         _mesa_free_texture_object(ss, ss->Default2D);
      if (ss->Default3D)
         _mesa_free_texture_object(ss, ss->Default3D);
d495 1
a495 3
         _mesa_free_texture_object(ss, ss->DefaultCubeMap);
      if (ss->DefaultRect)
         _mesa_free_texture_object(ss, ss->DefaultRect);
d515 1
a515 1
         _mesa_destroy_list(ctx, list);
d524 2
a525 1
   while (ss->TexObjectList) {
d529 1
a529 1
      _mesa_free_texture_object(ss, ss->TexObjectList);
a532 16
#if FEATURE_NV_vertex_program
   /* Free vertex programs */
   while (1) {
      GLuint prog = _mesa_HashFirstEntry(ss->VertexPrograms);
      if (prog) {
         _mesa_delete_program(ctx, prog);
      }
      else {
         break;
      }
   }
   _mesa_DeleteHashTable(ss->VertexPrograms);
#endif

   _glthread_DESTROY_MUTEX(ss->Mutex);

d559 1
a559 1
   _mesa_invalidate_spot_exp_table( l );
d561 1
a561 1
   l->_CosCutoff = 0.0;		/* KW: -ve values not admitted */
d573 1
a573 1
   ASSIGN_4V( lm->Ambient, 0.2F, 0.2F, 0.2F, 1.0F );
d583 4
a586 4
   ASSIGN_4V( m->Ambient,  0.2F, 0.2F, 0.2F, 1.0F );
   ASSIGN_4V( m->Diffuse,  0.8F, 0.8F, 0.8F, 1.0F );
   ASSIGN_4V( m->Specular, 0.0F, 0.0F, 0.0F, 1.0F );
   ASSIGN_4V( m->Emission, 0.0F, 0.0F, 0.0F, 1.0F );
d600 2
d626 4
a629 4
   texUnit->_GenBitS = TEXGEN_EYE_LINEAR;
   texUnit->_GenBitT = TEXGEN_EYE_LINEAR;
   texUnit->_GenBitR = TEXGEN_EYE_LINEAR;
   texUnit->_GenBitQ = TEXGEN_EYE_LINEAR;
d641 3
a643 3
   texUnit->Current1D = ctx->Shared->Default1D;
   texUnit->Current2D = ctx->Shared->Default2D;
   texUnit->Current3D = ctx->Shared->Default3D;
a644 1
   texUnit->CurrentRect = ctx->Shared->DefaultRect;
d648 48
d739 1
a739 1
   GLuint i;
a742 3
   assert(MAX_TEXTURE_LEVELS >= MAX_3D_TEXTURE_LEVELS);
   assert(MAX_TEXTURE_LEVELS >= MAX_CUBE_TEXTURE_LEVELS);

d745 2
a746 3
   ctx->Const.Max3DTextureLevels = MAX_3D_TEXTURE_LEVELS;
   ctx->Const.MaxCubeTextureLevels = MAX_CUBE_TEXTURE_LEVELS;
   ctx->Const.MaxTextureRectSize = MAX_TEXTURE_RECT_SIZE;
a747 2
   ctx->Const.MaxTextureMaxAnisotropy = MAX_TEXTURE_MAX_ANISOTROPY;
   ctx->Const.MaxTextureLodBias = MAX_TEXTURE_LOD_BIAS;
d754 1
a754 1
   ctx->Const.PointSizeGranularity = (GLfloat) POINT_SIZE_GRANULARITY;
d759 1
a759 1
   ctx->Const.LineWidthGranularity = (GLfloat) LINE_WIDTH_GRANULARITY;
d764 19
a782 2
   ctx->Const.MaxClipPlanes = MAX_CLIP_PLANES;
   ctx->Const.MaxLights = MAX_LIGHTS;
d784 18
a801 14
   /* Initialize matrix stacks */
   init_matrix_stack(&ctx->ModelviewMatrixStack, MAX_MODELVIEW_STACK_DEPTH,
                     _NEW_MODELVIEW);
   init_matrix_stack(&ctx->ProjectionMatrixStack, MAX_PROJECTION_STACK_DEPTH,
                     _NEW_PROJECTION);
   init_matrix_stack(&ctx->ColorMatrixStack, MAX_COLOR_STACK_DEPTH,
                     _NEW_COLOR_MATRIX);
   for (i = 0; i < MAX_TEXTURE_UNITS; i++)
      init_matrix_stack(&ctx->TextureMatrixStack[i], MAX_TEXTURE_STACK_DEPTH,
                        _NEW_TEXTURE_MATRIX);
   for (i = 0; i < MAX_PROGRAM_MATRICES; i++)
      init_matrix_stack(&ctx->ProgramMatrixStack[i], MAX_PROGRAM_STACK_DEPTH,
                        _NEW_TRACK_MATRIX);
   ctx->CurrentStack = &ctx->ModelviewMatrixStack;
d803 6
a808 2
   /* Init combined Modelview*Projection matrix */
   _math_matrix_ctr( &ctx->_ModelProjectMatrix );
d819 1
d821 1
a821 1
   ASSIGN_4V( ctx->Color.ClearColor, 0, 0, 0, 0 );
d832 1
d836 1
a836 1
   ctx->Color._LogicOpEnabled = GL_FALSE;
d839 1
d842 1
a842 7
   for (i = 0; i < VERT_ATTRIB_MAX; i++) {
      ASSIGN_4V( ctx->Current.Attrib[i], 0.0, 0.0, 0.0, 1.0 );
   }
   /* special cases: */
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_WEIGHT], 1.0, 0.0, 0.0, 1.0 );
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_NORMAL], 0.0, 0.0, 1.0, 1.0 );
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_COLOR0], 1.0, 1.0, 1.0, 1.0 );
d844 2
a845 2
   ctx->Current.EdgeFlag = GL_TRUE;
   
a848 1
   ASSIGN_4V( ctx->Current.RasterSecondaryColor, 0.0, 0.0, 0.0, 0.0 );
d851 2
a852 1
      ASSIGN_4V( ctx->Current.RasterTexCoords[i], 0.0, 0.0, 0.0, 1.0 );
d854 6
d861 1
a879 1
   MEMSET(ctx->Eval.Map1Attrib, 0, sizeof(ctx->Eval.Map1Attrib));
a888 1
   MEMSET(ctx->Eval.Map2Attrib, 0, sizeof(ctx->Eval.Map2Attrib));
a906 1
      static GLfloat attrib[4] = { 0.0, 0.0, 0.0, 1.0 };
a916 2
      for (i = 0; i < 16; i++)
         init_1d_map( ctx->EvalMap.Map1Attrib + i, 4, attrib );
a926 2
      for (i = 0; i < 16; i++)
         init_2d_map( ctx->EvalMap.Map2Attrib + i, 4, attrib );
a936 2
   ctx->Fog.ColorSumEnabled = GL_FALSE;
   ctx->Fog.FogCoordinateSource = GL_FRAGMENT_DEPTH_EXT;
d944 4
a949 1
   ctx->Hint.GenerateMipmap = GL_DONT_CARE;
d955 5
a959 5
   ctx->Histogram.RedSize       = 0;
   ctx->Histogram.GreenSize     = 0;
   ctx->Histogram.BlueSize      = 0;
   ctx->Histogram.AlphaSize     = 0;
   ctx->Histogram.LuminanceSize = 0;
d975 6
d982 3
a984 1
   _mesa_extensions_ctr( ctx );
d999 4
a1002 3
   ctx->Light.ColorMaterialBitmask = _mesa_material_bitmask( ctx,
                                               GL_FRONT_AND_BACK,
                                               GL_AMBIENT_AND_DIFFUSE, ~0, 0 );
d1007 2
a1008 2
   ctx->_ShineTabList = MALLOC_STRUCT( gl_shine_tab );
   make_empty_list( ctx->_ShineTabList );
d1013 1
a1013 1
      insert_at_tail( ctx->_ShineTabList, s );
d1015 9
a1029 1
   ctx->Line._Width = 1.0;
a1035 8
   /* Multisample */
   ctx->Multisample.Enabled = GL_FALSE;
   ctx->Multisample.SampleAlphaToCoverage = GL_FALSE;
   ctx->Multisample.SampleAlphaToOne = GL_FALSE;
   ctx->Multisample.SampleCoverage = GL_FALSE;
   ctx->Multisample.SampleCoverageValue = 1.0;
   ctx->Multisample.SampleCoverageInvert = GL_FALSE;

d1045 1
a1102 5
   for (i = 0; i < MAX_CONVOLUTION_WIDTH * MAX_CONVOLUTION_WIDTH * 4; i++) {
      ctx->Convolution1D.Filter[i] = 0.0;
      ctx->Convolution2D.Filter[i] = 0.0;
      ctx->Separable2D.Filter[i] = 0.0;
   }
d1108 1
a1109 1
   ctx->Point._Size = 1.0;
d1113 1
a1113 1
   ctx->Point._Attenuated = GL_FALSE;
d1115 1
a1115 1
   ctx->Point.MaxSize = ctx->Const.MaxPointSize;
a1116 5
   ctx->Point.PointSprite = GL_FALSE; /* GL_NV_point_sprite */
   ctx->Point.SpriteRMode = GL_ZERO; /* GL_NV_point_sprite */
   for (i = 0; i < MAX_TEXTURE_UNITS; i++) {
      ctx->Point.CoordReplace[i] = GL_FALSE; /* GL_NV_point_sprite */
   }
d1122 1
a1122 1
   ctx->Polygon._FrontBit = 0;
d1125 1
d1146 6
a1151 16
   ctx->Stencil.TestTwoSide = GL_FALSE;
   ctx->Stencil.ActiveFace = 0;  /* 0 = GL_FRONT, 1 = GL_BACK */
   ctx->Stencil.Function[0] = GL_ALWAYS;
   ctx->Stencil.Function[1] = GL_ALWAYS;
   ctx->Stencil.FailFunc[0] = GL_KEEP;
   ctx->Stencil.FailFunc[1] = GL_KEEP;
   ctx->Stencil.ZPassFunc[0] = GL_KEEP;
   ctx->Stencil.ZPassFunc[1] = GL_KEEP;
   ctx->Stencil.ZFailFunc[0] = GL_KEEP;
   ctx->Stencil.ZFailFunc[1] = GL_KEEP;
   ctx->Stencil.Ref[0] = 0;
   ctx->Stencil.Ref[1] = 0;
   ctx->Stencil.ValueMask[0] = STENCIL_MAX;
   ctx->Stencil.ValueMask[1] = STENCIL_MAX;
   ctx->Stencil.WriteMask[0] = STENCIL_MAX;
   ctx->Stencil.WriteMask[1] = STENCIL_MAX;
d1153 1
d1157 2
a1158 1
   ctx->Texture._EnabledUnits = 0;
a1167 1
   ctx->Transform.RasterPositionUnclipped = GL_FALSE;
d1169 1
d1172 1
a1172 1
   ctx->Transform.ClipPlanesEnabled = 0;
d1181 1
a1181 1
   _math_matrix_ctr(&ctx->Viewport._WindowMap);
d1185 2
a1186 2
   ctx->Viewport._WindowMap.m[Sz] = 0.5F * ctx->DepthMaxF;
   ctx->Viewport._WindowMap.m[Tz] = 0.5F * ctx->DepthMaxF;
d1190 2
a1191 2
   ctx->Viewport._WindowMap.flags = MAT_FLAG_GENERAL_SCALE|MAT_FLAG_TRANSLATION;
   ctx->Viewport._WindowMap.type = MATRIX_3D_NO_ROT;
d1194 7
a1206 1
   ctx->Array.Vertex.Flags = CA_CLIENT_DATA;
a1211 1
   ctx->Array.Normal.Flags = CA_CLIENT_DATA;
a1217 15
   ctx->Array.Color.Flags = CA_CLIENT_DATA;
   ctx->Array.SecondaryColor.Size = 3;
   ctx->Array.SecondaryColor.Type = GL_FLOAT;
   ctx->Array.SecondaryColor.Stride = 0;
   ctx->Array.SecondaryColor.StrideB = 0;
   ctx->Array.SecondaryColor.Ptr = NULL;
   ctx->Array.SecondaryColor.Enabled = GL_FALSE;
   ctx->Array.SecondaryColor.Flags = CA_CLIENT_DATA;
   ctx->Array.FogCoord.Size = 1;
   ctx->Array.FogCoord.Type = GL_FLOAT;
   ctx->Array.FogCoord.Stride = 0;
   ctx->Array.FogCoord.StrideB = 0;
   ctx->Array.FogCoord.Ptr = NULL;
   ctx->Array.FogCoord.Enabled = GL_FALSE;
   ctx->Array.FogCoord.Flags = CA_CLIENT_DATA;
a1222 1
   ctx->Array.Index.Flags = CA_CLIENT_DATA;
a1229 1
      ctx->Array.TexCoord[i].Flags = CA_CLIENT_DATA;
d1236 1
a1236 1
   ctx->Array.EdgeFlag.Flags = CA_CLIENT_DATA;
d1270 4
a1294 12
   /* GL_NV_vertex_program */
   ctx->VertexProgram.Enabled = GL_FALSE;
   ctx->VertexProgram.PointSizeEnabled = GL_FALSE;
   ctx->VertexProgram.TwoSideEnabled = GL_FALSE;
   ctx->VertexProgram.CurrentID = 0;
   ctx->VertexProgram.ErrorPos = -1;
   ctx->VertexProgram.Current = NULL;
   for (i = 0; i < VP_NUM_PROG_REGS / 4; i++) {
      ctx->VertexProgram.TrackMatrix[i] = GL_NONE;
      ctx->VertexProgram.TrackMatrixTransform[i] = GL_IDENTITY_NV;
   }

d1296 1
a1296 1
   ctx->NewState = _NEW_ALL;
d1298 7
a1304 5
   ctx->_ImageTransferState = 0;

   ctx->_NeedNormals = 0;
   ctx->_NeedEyeCoords = 0;
   ctx->_ModelViewInvScale = 1.0;
a1310 1
   ctx->_Facing = 0;
d1313 1
a1313 1
   ctx->NoRaster = _mesa_getenv("MESA_NO_RASTER") ? GL_TRUE : GL_FALSE;
d1317 1
a1317 1
   ctx->NoDither = _mesa_getenv("MESA_NO_DITHER") ? GL_TRUE : GL_FALSE;
d1319 2
a1320 2
      if (_mesa_getenv("MESA_DEBUG")) {
         _mesa_debug(ctx, "MESA_NO_DITHER set - dithering disabled\n");
d1340 1
a1340 1
   ctx->Texture.Proxy1D = _mesa_alloc_texture_object(NULL, 0, GL_TEXTURE_1D);
d1345 1
a1345 1
   ctx->Texture.Proxy2D = _mesa_alloc_texture_object(NULL, 0, GL_TEXTURE_2D);
d1347 1
a1347 1
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy1D);
d1351 1
a1351 1
   ctx->Texture.Proxy3D = _mesa_alloc_texture_object(NULL, 0, GL_TEXTURE_3D);
d1353 2
a1354 21
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy1D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy2D);
      return GL_FALSE;
   }

   ctx->Texture.ProxyCubeMap = _mesa_alloc_texture_object(NULL, 0,
                                                     GL_TEXTURE_CUBE_MAP_ARB);
   if (!ctx->Texture.ProxyCubeMap) {
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy1D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy2D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy3D);
      return GL_FALSE;
   }

   ctx->Texture.ProxyRect = _mesa_alloc_texture_object(NULL, 0,
                                                      GL_TEXTURE_RECTANGLE_NV);
   if (!ctx->Texture.ProxyRect) {
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy1D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy2D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy3D);
      _mesa_free_texture_object(NULL, ctx->Texture.ProxyCubeMap);
a1362 1
      ctx->Texture.ProxyCubeMap->Image[i] = _mesa_alloc_texture_image();
d1365 1
a1365 2
          || !ctx->Texture.Proxy3D->Image[i]
          || !ctx->Texture.ProxyCubeMap->Image[i]) {
a1368 4
   ctx->Texture.ProxyRect->Image[0] = _mesa_alloc_texture_image();
   if (!ctx->Texture.ProxyRect->Image[0])
      out_of_memory = GL_TRUE;

a1379 3
         if (ctx->Texture.ProxyCubeMap->Image[i]) {
            _mesa_free_texture_image(ctx->Texture.ProxyCubeMap->Image[i]);
         }
d1381 3
a1383 8
      if (ctx->Texture.ProxyRect->Image[0]) {
         _mesa_free_texture_image(ctx->Texture.ProxyRect->Image[0]);
      }
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy1D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy2D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy3D);
      _mesa_free_texture_object(NULL, ctx->Texture.ProxyCubeMap);
      _mesa_free_texture_object(NULL, ctx->Texture.ProxyRect);
a1391 37
static void add_debug_flags( const char *debug )
{
#ifdef MESA_DEBUG
   if (_mesa_strstr(debug, "varray")) 
      MESA_VERBOSE |= VERBOSE_VARRAY;

   if (_mesa_strstr(debug, "tex")) 
      MESA_VERBOSE |= VERBOSE_TEXTURE;

   if (_mesa_strstr(debug, "imm")) 
      MESA_VERBOSE |= VERBOSE_IMMEDIATE;

   if (_mesa_strstr(debug, "pipe")) 
      MESA_VERBOSE |= VERBOSE_PIPELINE;

   if (_mesa_strstr(debug, "driver")) 
      MESA_VERBOSE |= VERBOSE_DRIVER;

   if (_mesa_strstr(debug, "state")) 
      MESA_VERBOSE |= VERBOSE_STATE;

   if (_mesa_strstr(debug, "api")) 
      MESA_VERBOSE |= VERBOSE_API;

   if (_mesa_strstr(debug, "list")) 
      MESA_VERBOSE |= VERBOSE_DISPLAY_LIST;

   if (_mesa_strstr(debug, "lighting")) 
      MESA_VERBOSE |= VERBOSE_LIGHTING;
   
   /* Debug flag:
    */
   if (_mesa_strstr(debug, "flush")) 
      MESA_DEBUG_FLAGS |= DEBUG_ALWAYS_FLUSH;
#endif
}

d1399 1
a1399 1
                          const GLvisual *visual,
a1404 3
   const char *c;

   ASSERT(driver_ctx);
d1406 1
a1406 7
   /* If the driver wants core Mesa to use special imports, it'll have to
    * override these defaults.
    */
   _mesa_init_default_imports( &(ctx->imports), driver_ctx );

   /* initialize the exports (Mesa functions called by the window system) */
   _mesa_init_default_exports( &(ctx->exports) );
d1409 1
a1409 1
   one_time_init(ctx);
d1412 1
a1412 1
   ctx->Visual = *visual;
d1416 12
d1429 1
a1429 1
      /* share state with another context */
d1433 1
a1433 1
      /* allocate new, unshared state */
d1436 2
d1445 1
a1445 6
   /* Effectively bind the default textures to all texture units */
   ctx->Shared->Default1D->RefCount += MAX_TEXTURE_UNITS;
   ctx->Shared->Default2D->RefCount += MAX_TEXTURE_UNITS;
   ctx->Shared->Default3D->RefCount += MAX_TEXTURE_UNITS;
   ctx->Shared->DefaultCubeMap->RefCount += MAX_TEXTURE_UNITS;
   ctx->Shared->DefaultRect->RefCount += MAX_TEXTURE_UNITS;
d1447 2
a1448 1
   init_attrib_groups( ctx );
d1450 1
a1450 1
   if (visual->doubleBufferMode) {
d1452 2
a1453 1
      ctx->Color._DrawDestMask = BACK_LEFT_BIT;
d1455 1
a1455 1
      ctx->Pixel._ReadSrcMask = BACK_LEFT_BIT;
d1459 2
a1460 1
      ctx->Color._DrawDestMask = FRONT_LEFT_BIT;
d1462 1
a1462 1
      ctx->Pixel._ReadSrcMask = FRONT_LEFT_BIT;
d1467 2
d1472 9
a1480 100
   /*
    * For XFree86/DRI: tell libGL to add these functions to the dispatcher.
    * Basically, we should add all extension functions above offset 577.
    * This enables older libGL libraries to work with newer drivers that
    * have newer extensions.
    */
   /* GL_ARB_window_pos aliases with GL_MESA_window_pos */
   _glapi_add_entrypoint("glWindowPos2dARB", 513);
   _glapi_add_entrypoint("glWindowPos2dvARB", 514);
   _glapi_add_entrypoint("glWindowPos2fARB", 515);
   _glapi_add_entrypoint("glWindowPos2fvARB", 516);
   _glapi_add_entrypoint("glWindowPos2iARB", 517);
   _glapi_add_entrypoint("glWindowPos2ivARB", 518);
   _glapi_add_entrypoint("glWindowPos2sARB", 519);
   _glapi_add_entrypoint("glWindowPos2svARB", 520);
   _glapi_add_entrypoint("glWindowPos3dARB", 521);
   _glapi_add_entrypoint("glWindowPos3dvARB", 522);
   _glapi_add_entrypoint("glWindowPos3fARB", 523);
   _glapi_add_entrypoint("glWindowPos3fvARB", 524);
   _glapi_add_entrypoint("glWindowPos3iARB", 525);
   _glapi_add_entrypoint("glWindowPos3ivARB", 526);
   _glapi_add_entrypoint("glWindowPos3sARB", 527);
   _glapi_add_entrypoint("glWindowPos3svARB", 528);
   /* new extension functions */
   _glapi_add_entrypoint("glAreProgramsResidentNV", 578);
   _glapi_add_entrypoint("glBindProgramNV", 579);
   _glapi_add_entrypoint("glDeleteProgramsNV", 580);
   _glapi_add_entrypoint("glExecuteProgramNV", 581);
   _glapi_add_entrypoint("glGenProgramsNV", 582);
   _glapi_add_entrypoint("glGetProgramParameterdvNV", 583);
   _glapi_add_entrypoint("glGetProgramParameterfvNV", 584);
   _glapi_add_entrypoint("glGetProgramivNV", 585);
   _glapi_add_entrypoint("glGetProgramStringNV", 586);
   _glapi_add_entrypoint("glGetTrackMatrixivNV", 587);
   _glapi_add_entrypoint("glGetVertexAttribdvNV", 588);
   _glapi_add_entrypoint("glGetVertexAttribfvNV", 589);
   _glapi_add_entrypoint("glGetVertexAttribivNV", 590);
   _glapi_add_entrypoint("glGetVertexAttribPointervNV", 591);
   _glapi_add_entrypoint("glIsProgramNV", 592);
   _glapi_add_entrypoint("glLoadProgramNV", 593);
   _glapi_add_entrypoint("glProgramParameter4dNV", 594);
   _glapi_add_entrypoint("glProgramParameter4dvNV", 595);
   _glapi_add_entrypoint("glProgramParameter4fNV", 596);
   _glapi_add_entrypoint("glProgramParameter4fvNV", 597);
   _glapi_add_entrypoint("glProgramParameters4dvNV", 598);
   _glapi_add_entrypoint("glProgramParameters4fvNV", 599);
   _glapi_add_entrypoint("glRequestResidentProgramsNV", 600);
   _glapi_add_entrypoint("glTrackMatrixNV", 601);
   _glapi_add_entrypoint("glVertexAttribPointerNV", 602);
   _glapi_add_entrypoint("glVertexAttrib1dNV", 603);
   _glapi_add_entrypoint("glVertexAttrib1dvNV", 604);
   _glapi_add_entrypoint("glVertexAttrib1fNV", 605);
   _glapi_add_entrypoint("glVertexAttrib1fvNV", 606);
   _glapi_add_entrypoint("glVertexAttrib1sNV", 607);
   _glapi_add_entrypoint("glVertexAttrib1svNV", 608);
   _glapi_add_entrypoint("glVertexAttrib2dNV", 609);
   _glapi_add_entrypoint("glVertexAttrib2dvNV", 610);
   _glapi_add_entrypoint("glVertexAttrib2fNV", 611);
   _glapi_add_entrypoint("glVertexAttrib2fvNV", 612);
   _glapi_add_entrypoint("glVertexAttrib2sNV", 613);
   _glapi_add_entrypoint("glVertexAttrib2svNV", 614);
   _glapi_add_entrypoint("glVertexAttrib3dNV", 615);
   _glapi_add_entrypoint("glVertexAttrib3dvNV", 616);
   _glapi_add_entrypoint("glVertexAttrib3fNV", 617);
   _glapi_add_entrypoint("glVertexAttrib3fvNV", 618);
   _glapi_add_entrypoint("glVertexAttrib3sNV", 619);
   _glapi_add_entrypoint("glVertexAttrib3svNV", 620);
   _glapi_add_entrypoint("glVertexAttrib4dNV", 621);
   _glapi_add_entrypoint("glVertexAttrib4dvNV", 622);
   _glapi_add_entrypoint("glVertexAttrib4fNV", 623);
   _glapi_add_entrypoint("glVertexAttrib4fvNV", 624);
   _glapi_add_entrypoint("glVertexAttrib4sNV", 625);
   _glapi_add_entrypoint("glVertexAttrib4svNV", 626);
   _glapi_add_entrypoint("glVertexAttrib4ubNV", 627);
   _glapi_add_entrypoint("glVertexAttrib4ubvNV", 628);
   _glapi_add_entrypoint("glVertexAttribs1dvNV", 629);
   _glapi_add_entrypoint("glVertexAttribs1fvNV", 630);
   _glapi_add_entrypoint("glVertexAttribs1svNV", 631);
   _glapi_add_entrypoint("glVertexAttribs2dvNV", 632);
   _glapi_add_entrypoint("glVertexAttribs2fvNV", 633);
   _glapi_add_entrypoint("glVertexAttribs2svNV", 634);
   _glapi_add_entrypoint("glVertexAttribs3dvNV", 635);
   _glapi_add_entrypoint("glVertexAttribs3fvNV", 636);
   _glapi_add_entrypoint("glVertexAttribs3svNV", 637);
   _glapi_add_entrypoint("glVertexAttribs4dvNV", 638);
   _glapi_add_entrypoint("glVertexAttribs4fvNV", 639);
   _glapi_add_entrypoint("glVertexAttribs4svNV", 640);
   _glapi_add_entrypoint("glVertexAttribs4ubvNV", 641);
   _glapi_add_entrypoint("glPointParameteriNV", 642);
   _glapi_add_entrypoint("glPointParameterivNV", 643);
   _glapi_add_entrypoint("glMultiDrawArraysEXT", 644);
   _glapi_add_entrypoint("glMultiDrawElementsEXT", 645);
   _glapi_add_entrypoint("glActiveStencilFaceEXT", 646);
   _glapi_add_entrypoint("glDeleteFencesNV", 647);
   _glapi_add_entrypoint("glGenFencesNV", 648);
   _glapi_add_entrypoint("glIsFenceNV", 649);
   _glapi_add_entrypoint("glTestFenceNV", 650);
   _glapi_add_entrypoint("glGetFenceivNV", 651);
   _glapi_add_entrypoint("glFinishFenceNV", 652);
   _glapi_add_entrypoint("glSetFenceNV", 653);
d1495 2
a1503 38
   ctx->ExecPrefersFloat = GL_FALSE;
   ctx->SavePrefersFloat = GL_FALSE;

   /* Neutral tnl module stuff */
   _mesa_init_exec_vtxfmt( ctx );
   ctx->TnlModule.Current = NULL;
   ctx->TnlModule.SwapCount = 0;

   /* Z buffer stuff */
   if (ctx->Visual.depthBits == 0) {
      /* Special case.  Even if we don't have a depth buffer we need
       * good values for DepthMax for Z vertex transformation purposes
       * and for per-fragment fog computation.
       */
      ctx->DepthMax = 1 << 16;
      ctx->DepthMaxF = (GLfloat) ctx->DepthMax;
   }
   else if (ctx->Visual.depthBits < 32) {
      ctx->DepthMax = (1 << ctx->Visual.depthBits) - 1;
      ctx->DepthMaxF = (GLfloat) ctx->DepthMax;
   }
   else {
      /* Special case since shift values greater than or equal to the
       * number of bits in the left hand expression's type are undefined.
       */
      ctx->DepthMax = 0xffffffff;
      ctx->DepthMaxF = (GLfloat) ctx->DepthMax;
   }
   ctx->MRD = 1.0;  /* Minimum resolvable depth value, for polygon offset */

   c = _mesa_getenv("MESA_DEBUG");
   if (c)
      add_debug_flags(c);

   c = _mesa_getenv("MESA_VERBOSE");
   if (c)
      add_debug_flags(c);

d1511 1
a1511 1
 * Input:  visual - a GLvisual pointer (we copy the struct contents)
d1514 1
a1514 2
 *         direct - direct rendering?
 * Return:  pointer to a new __GLcontextRec or NULL if error.
d1517 4
a1520 5
_mesa_create_context( const GLvisual *visual,
                      GLcontext *share_list,
                      void *driver_ctx,
                      GLboolean direct )

d1522 2
a1523 7
   GLcontext *ctx;

   ASSERT(visual);
   ASSERT(driver_ctx);

   ctx = (GLcontext *) _mesa_calloc(sizeof(GLcontext));
   if (!ctx)
d1525 1
d1531 1
a1531 1
      _mesa_free(ctx);
d1543 1
a1543 1
_mesa_free_context_data( GLcontext *ctx )
d1546 1
a1546 1
   GLuint i;
d1549 2
a1550 2
   if (ctx == _mesa_get_current_context()) {
      _mesa_make_current(NULL, NULL);
d1553 13
a1565 19
   /*
    * Free transformation matrix stacks
    */
   free_matrix_stack(&ctx->ModelviewMatrixStack);
   free_matrix_stack(&ctx->ProjectionMatrixStack);
   free_matrix_stack(&ctx->ColorMatrixStack);
   for (i = 0; i < MAX_TEXTURE_UNITS; i++)
      free_matrix_stack(&ctx->TextureMatrixStack[i]);
   for (i = 0; i < MAX_PROGRAM_MATRICES; i++)
      free_matrix_stack(&ctx->ProgramMatrixStack[i]);
   /* combined Modelview*Projection matrix */
   _math_matrix_dtr( &ctx->_ModelProjectMatrix );


#if FEATURE_NV_vertex_program
   if (ctx->VertexProgram.Current) {
      ctx->VertexProgram.Current->RefCount--;
      if (ctx->VertexProgram.Current->RefCount <= 0)
         _mesa_delete_program(ctx, ctx->VertexProgram.CurrentID);
a1566 1
#endif
d1568 7
a1574 1
   /* Shared context state (display lists, textures, etc) */
d1584 1
a1584 2
   /* Free lighting shininess exponentiation table */
   foreach_s( s, tmps, ctx->_ShineTabList ) {
d1587 1
a1587 1
   FREE( ctx->_ShineTabList );
d1590 3
a1592 5
   _mesa_free_texture_object( NULL, ctx->Texture.Proxy1D );
   _mesa_free_texture_object( NULL, ctx->Texture.Proxy2D );
   _mesa_free_texture_object( NULL, ctx->Texture.Proxy3D );
   _mesa_free_texture_object( NULL, ctx->Texture.ProxyCubeMap );
   _mesa_free_texture_object( NULL, ctx->Texture.ProxyRect );
a1612 2
   for (i = 0; i < 16; i++)
      FREE((ctx->EvalMap.Map1Attrib[i].Points));
a1631 2
   for (i = 0; i < 16; i++)
      FREE((ctx->EvalMap.Map2Attrib[i].Points));
d1638 7
a1644 3
   _math_matrix_dtr(&ctx->Viewport._WindowMap);

   _mesa_extensions_dtr(ctx);
d1656 1
a1656 1
_mesa_destroy_context( GLcontext *ctx )
d1659 1
a1659 1
      _mesa_free_context_data(ctx);
d1667 12
d1685 1
a1685 1
_mesa_copy_context( const GLcontext *src, GLcontext *dst, GLuint mask )
d1688 1
a1688 2
      /* OK to memcpy */
      dst->Accum = src->Accum;
d1691 1
a1691 2
      /* OK to memcpy */
      dst->Color = src->Color;
d1694 1
a1694 2
      /* OK to memcpy */
      dst->Current = src->Current;
d1697 1
a1697 2
      /* OK to memcpy */
      dst->Depth = src->Depth;
d1703 1
a1703 2
      /* OK to memcpy */
      dst->Eval = src->Eval;
d1706 1
a1706 2
      /* OK to memcpy */
      dst->Fog = src->Fog;
d1709 1
a1709 2
      /* OK to memcpy */
      dst->Hint = src->Hint;
d1712 2
a1713 10
      GLuint i;
      /* begin with memcpy */
      MEMCPY( &dst->Light, &src->Light, sizeof(struct gl_light) );
      /* fixup linked lists to prevent pointer insanity */
      make_empty_list( &(dst->Light.EnabledList) );
      for (i = 0; i < MAX_LIGHTS; i++) {
         if (dst->Light.Light[i].Enabled) {
            insert_at_tail(&(dst->Light.EnabledList), &(dst->Light.Light[i]));
         }
      }
d1716 1
a1716 2
      /* OK to memcpy */
      dst->Line = src->Line;
d1719 1
a1719 2
      /* OK to memcpy */
      dst->List = src->List;
d1722 1
a1722 2
      /* OK to memcpy */
      dst->Pixel = src->Pixel;
d1725 1
a1725 2
      /* OK to memcpy */
      dst->Point = src->Point;
d1728 1
a1728 2
      /* OK to memcpy */
      dst->Polygon = src->Polygon;
d1734 2
a1735 2
      GLuint i;
      for (i = 0; i < 32; i++) {
d1740 1
a1740 2
      /* OK to memcpy */
      dst->Scissor = src->Scissor;
d1743 1
a1743 2
      /* OK to memcpy */
      dst->Stencil = src->Stencil;
d1746 1
a1746 2
      /* Cannot memcpy because of pointers */
      _mesa_copy_texture_state(src, dst);
d1749 1
a1749 2
      /* OK to memcpy */
      dst->Transform = src->Transform;
d1752 1
a1752 8
      /* Cannot use memcpy, because of pointers in GLmatrix _WindowMap */
      dst->Viewport.X = src->Viewport.X;
      dst->Viewport.Y = src->Viewport.Y;
      dst->Viewport.Width = src->Viewport.Width;
      dst->Viewport.Height = src->Viewport.Height;
      dst->Viewport.Near = src->Viewport.Near;
      dst->Viewport.Far = src->Viewport.Far;
      _math_matrix_copy(&dst->Viewport._WindowMap, &src->Viewport._WindowMap);
a1753 33

   /* XXX FIXME:  Call callbacks?
    */
   dst->NewState = _NEW_ALL;
}



static void print_info( void )
{
   _mesa_debug(NULL, "Mesa GL_VERSION = %s\n",
	   (char *) _mesa_GetString(GL_VERSION));
   _mesa_debug(NULL, "Mesa GL_RENDERER = %s\n",
	   (char *) _mesa_GetString(GL_RENDERER));
   _mesa_debug(NULL, "Mesa GL_VENDOR = %s\n",
	   (char *) _mesa_GetString(GL_VENDOR));
   _mesa_debug(NULL, "Mesa GL_EXTENSIONS = %s\n",
	   (char *) _mesa_GetString(GL_EXTENSIONS));
#if defined(THREADS)
   _mesa_debug(NULL, "Mesa thread-safe: YES\n");
#else
   _mesa_debug(NULL, "Mesa thread-safe: NO\n");
#endif
#if defined(USE_X86_ASM)
   _mesa_debug(NULL, "Mesa x86-optimized: YES\n");
#else
   _mesa_debug(NULL, "Mesa x86-optimized: NO\n");
#endif
#if defined(USE_SPARC_ASM)
   _mesa_debug(NULL, "Mesa sparc-optimized: YES\n");
#else
   _mesa_debug(NULL, "Mesa sparc-optimized: NO\n");
#endif
d1760 1
a1760 2
void
_mesa_make_current( GLcontext *newCtx, GLframebuffer *buffer )
d1762 1
a1762 1
   _mesa_make_current2( newCtx, buffer, buffer );
d1770 2
a1771 3
void
_mesa_make_current2( GLcontext *newCtx, GLframebuffer *drawBuffer,
                     GLframebuffer *readBuffer )
d1773 2
a1774 2
   if (MESA_VERBOSE)
      _mesa_debug(newCtx, "_mesa_make_current2()\n");
d1776 1
a1776 3
   /* Check that the context's and framebuffer's visuals are compatible.
    * We could do a lot more checking here but this'll catch obvious
    * problems.
d1778 9
a1786 7
   if (newCtx && drawBuffer && readBuffer) {
      if (newCtx->Visual.rgbMode != drawBuffer->Visual.rgbMode ||
          newCtx->Visual.redBits != drawBuffer->Visual.redBits ||
          newCtx->Visual.depthBits != drawBuffer->Visual.depthBits ||
          newCtx->Visual.stencilBits != drawBuffer->Visual.stencilBits ||
          newCtx->Visual.accumRedBits != drawBuffer->Visual.accumRedBits) {
         return; /* incompatible */
d1789 1
d1797 6
a1802 4
   ASSERT(_mesa_get_current_context() == newCtx);


   if (!newCtx) {
a1804 2
   else {
      _glapi_set_dispatch(newCtx->CurrentDispatch);
d1806 1
a1806 12
      if (drawBuffer && readBuffer) {
	 /* TODO: check if newCtx and buffer's visual match??? */
	 newCtx->DrawBuffer = drawBuffer;
	 newCtx->ReadBuffer = readBuffer;
	 newCtx->NewState |= _NEW_BUFFERS;

         if (drawBuffer->Width == 0 && drawBuffer->Height == 0) {
            /* get initial window size */
            GLuint bufWidth, bufHeight;

            /* ask device driver for size of output buffer */
            (*newCtx->Driver.GetBufferSize)( drawBuffer, &bufWidth, &bufHeight );
d1808 7
a1814 2
            if (drawBuffer->Width == bufWidth && drawBuffer->Height == bufHeight)
               return; /* size is as expected */
d1816 21
a1836 38
            drawBuffer->Width = bufWidth;
            drawBuffer->Height = bufHeight;

            newCtx->Driver.ResizeBuffers( drawBuffer );
         }

         if (readBuffer != drawBuffer &&
             readBuffer->Width == 0 && readBuffer->Height == 0) {
            /* get initial window size */
            GLuint bufWidth, bufHeight;

            /* ask device driver for size of output buffer */
            (*newCtx->Driver.GetBufferSize)( readBuffer, &bufWidth, &bufHeight );

            if (readBuffer->Width == bufWidth && readBuffer->Height == bufHeight)
               return; /* size is as expected */

            readBuffer->Width = bufWidth;
            readBuffer->Height = bufHeight;

            newCtx->Driver.ResizeBuffers( readBuffer );
         }
      }

      /* This is only for T&L - a bit out of place, or misnamed (BP) */
      if (newCtx->Driver.MakeCurrent)
	 newCtx->Driver.MakeCurrent( newCtx, drawBuffer, readBuffer );

      /* We can use this to help debug user's problems.  Tell them to set
       * the MESA_INFO env variable before running their app.  Then the
       * first time each context is made current we'll print some useful
       * information.
       */
      if (newCtx->FirstTimeCurrent) {
	 if (_mesa_getenv("MESA_INFO")) {
	    print_info();
	 }
	 newCtx->FirstTimeCurrent = GL_FALSE;
d1838 1
d1849 1
a1849 2
GLcontext *
_mesa_get_current_context( void )
d1855 13
d1887 64
a1950 2
 * Record the given error code and call the driver's Error function if defined.
 * This is called via _mesa_error().
d1953 1
a1953 1
_mesa_record_error( GLcontext *ctx, GLenum error )
d1955 48
a2002 2
   if (!ctx)
      return;
d2015 1
d2020 1
a2020 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2032 1
a2032 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
a2036 18



const char *_mesa_prim_name[GL_POLYGON+4] = {
   "GL_POINTS",
   "GL_LINES",
   "GL_LINE_LOOP",
   "GL_LINE_STRIP",
   "GL_TRIANGLES",
   "GL_TRIANGLE_STRIP",
   "GL_TRIANGLE_FAN",
   "GL_QUADS",
   "GL_QUAD_STRIP",
   "GL_POLYGON",
   "outside begin/end",
   "inside unkown primitive",
   "unknown state"
};
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d4 1
a4 1
 * Version:  4.0.4
d6 1
a6 1
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
d31 2
a32 1
#include "buffers.h"
d36 2
d44 2
a47 1
#include "imports.h"
d50 1
d53 3
d57 2
d60 1
d64 2
a65 1
#include "mtypes.h"
d67 6
a72 16
#include "vtxfmt.h"

#include "math/m_translate.h"
#include "math/m_vertices.h"
#include "math/m_matrix.h"
#include "math/m_xform.h"
#include "math/mathmod.h"
#endif

#if defined(MESA_TRACE)
#include "Trace/tr_context.h"
#include "Trace/tr_wrapper.h"
#endif

#ifdef USE_SPARC_ASM
#include "SPARC/sparc.h"
a74 3
#ifndef MESA_VERBOSE
int MESA_VERBOSE = 0;
#endif
a75 3
#ifndef MESA_DEBUG_FLAGS
int MESA_DEBUG_FLAGS = 0;
#endif
d78 1
a78 1
/*****       OpenGL SI-style interface (new in Mesa 3.5)          *****/
a80 43
static GLboolean
_mesa_DestroyContext(__GLcontext *gc)
{
   if (gc) {
      _mesa_free_context_data(gc);
      (*gc->imports.free)(gc, gc);
   }
   return GL_TRUE;
}


/* exported OpenGL SI interface */
__GLcontext *
__glCoreCreateContext(__GLimports *imports, __GLcontextModes *modes)
{
    GLcontext *ctx;

    ctx = (GLcontext *) (*imports->calloc)(0, 1, sizeof(GLcontext));
    if (ctx == NULL) {
	return NULL;
    }
   ctx->Driver.CurrentExecPrimitive=0;
    ctx->imports = *imports;

    _mesa_initialize_visual(&ctx->Visual,
                            modes->rgbMode,
                            modes->doubleBufferMode,
                            modes->stereoMode,
                            modes->redBits,
                            modes->greenBits,
                            modes->blueBits,
                            modes->alphaBits,
                            modes->indexBits,
                            modes->depthBits,
                            modes->stencilBits,
                            modes->accumRedBits,
                            modes->accumGreenBits,
                            modes->accumBlueBits,
                            modes->accumAlphaBits,
                            0);

    /* KW: was imports->wscx */
    _mesa_initialize_context(ctx, &ctx->Visual, NULL, imports->other, GL_FALSE);
d82 1
a82 4
    ctx->exports.destroyContext = _mesa_DestroyContext;

    return ctx;
}
d84 1
a85 10
/* exported OpenGL SI interface */
void
__glCoreNopDispatch(void)
{
#if 0
   /* SI */
   __gl_dispatch = __glNopDispatchState;
#else
   /* Mesa */
   _glapi_set_dispatch(NULL);
a86 7
}


/**********************************************************************/
/*****                  Context and Thread management             *****/
/**********************************************************************/

d135 1
a135 1
                                   numSamples)) {
a167 2
   (void) numSamples;

d195 36
a230 15
   vis->rgbMode          = rgbFlag;
   vis->doubleBufferMode = dbFlag;
   vis->stereoMode       = stereoFlag;
   vis->redBits          = redBits;
   vis->greenBits        = greenBits;
   vis->blueBits         = blueBits;
   vis->alphaBits        = alphaBits;

   vis->indexBits      = indexBits;
   vis->depthBits      = depthBits;
   vis->accumRedBits   = (accumRedBits > 0) ? (8 * sizeof(GLaccum)) : 0;
   vis->accumGreenBits = (accumGreenBits > 0) ? (8 * sizeof(GLaccum)) : 0;
   vis->accumBlueBits  = (accumBlueBits > 0) ? (8 * sizeof(GLaccum)) : 0;
   vis->accumAlphaBits = (accumAlphaBits > 0) ? (8 * sizeof(GLaccum)) : 0;
   vis->stencilBits    = (stencilBits > 0) ? (8 * sizeof(GLstencil)) : 0;
d236 23
d266 9
d284 1
a284 1
 * Input:  visual - a GLvisual pointer (we copy the struct contents)
d289 1
d293 5
a297 5
_mesa_create_framebuffer( const GLvisual *visual,
                          GLboolean softwareDepth,
                          GLboolean softwareStencil,
                          GLboolean softwareAccum,
                          GLboolean softwareAlpha )
d312 1
a312 1
 * Input:  See _mesa_create_framebuffer() above.
d316 1
a316 1
                              const GLvisual *visual,
a324 2
   BZERO(buffer, sizeof(GLframebuffer));

d327 1
a327 1
      assert(visual->depthBits > 0);
d330 1
a330 1
      assert(visual->stencilBits > 0);
d333 4
a336 4
      assert(visual->rgbMode);
      assert(visual->accumRedBits > 0);
      assert(visual->accumGreenBits > 0);
      assert(visual->accumBlueBits > 0);
d339 2
a340 2
      assert(visual->rgbMode);
      assert(visual->alphaBits > 0);
d343 1
a343 1
   buffer->Visual = *visual;
d355 1
a355 1
_mesa_destroy_framebuffer( GLframebuffer *buffer )
d358 21
a378 1
      _mesa_free_framebuffer_data(buffer);
a383 40
/*
 * Free the data hanging off of <buffer>, but not <buffer> itself.
 */
void
_mesa_free_framebuffer_data( GLframebuffer *buffer )
{
   if (!buffer)
      return;

   if (buffer->DepthBuffer) {
      MESA_PBUFFER_FREE( buffer->DepthBuffer );
      buffer->DepthBuffer = NULL;
   }
   if (buffer->Accum) {
      MESA_PBUFFER_FREE( buffer->Accum );
      buffer->Accum = NULL;
   }
   if (buffer->Stencil) {
      MESA_PBUFFER_FREE( buffer->Stencil );
      buffer->Stencil = NULL;
   }
   if (buffer->FrontLeftAlpha) {
      MESA_PBUFFER_FREE( buffer->FrontLeftAlpha );
      buffer->FrontLeftAlpha = NULL;
   }
   if (buffer->BackLeftAlpha) {
      MESA_PBUFFER_FREE( buffer->BackLeftAlpha );
      buffer->BackLeftAlpha = NULL;
   }
   if (buffer->FrontRightAlpha) {
      MESA_PBUFFER_FREE( buffer->FrontRightAlpha );
      buffer->FrontRightAlpha = NULL;
   }
   if (buffer->BackRightAlpha) {
      MESA_PBUFFER_FREE( buffer->BackRightAlpha );
      buffer->BackRightAlpha = NULL;
   }
}


d410 3
a412 3
      _mesa_init_lists();

      _math_init();
d414 8
a422 3
#ifdef USE_SPARC_ASM
      _mesa_init_sparc_glapi_relocs();
#endif
d447 1
d459 3
d465 7
a471 4

   ss->Default1D = _mesa_alloc_texture_object(ss, 0, GL_TEXTURE_1D);
   if (!ss->Default1D) {
      outOfMemory = GL_TRUE;
d474 1
a474 12
   ss->Default2D = _mesa_alloc_texture_object(ss, 0, GL_TEXTURE_2D);
   if (!ss->Default2D) {
      outOfMemory = GL_TRUE;
   }

   ss->Default3D = _mesa_alloc_texture_object(ss, 0, GL_TEXTURE_3D);
   if (!ss->Default3D) {
      outOfMemory = GL_TRUE;
   }

   ss->DefaultCubeMap = _mesa_alloc_texture_object(ss, 0,
                                                   GL_TEXTURE_CUBE_MAP_ARB);
d478 2
a479 5

   ss->DefaultRect = _mesa_alloc_texture_object(ss, 0,
                                                GL_TEXTURE_RECTANGLE_NV);
   if (!ss->DefaultRect) {
      outOfMemory = GL_TRUE;
d488 6
a493 6
      if (ss->Default1D)
         _mesa_free_texture_object(ss, ss->Default1D);
      if (ss->Default2D)
         _mesa_free_texture_object(ss, ss->Default2D);
      if (ss->Default3D)
         _mesa_free_texture_object(ss, ss->Default3D);
d495 1
a495 3
         _mesa_free_texture_object(ss, ss->DefaultCubeMap);
      if (ss->DefaultRect)
         _mesa_free_texture_object(ss, ss->DefaultRect);
d515 1
a515 1
         _mesa_destroy_list(ctx, list);
d524 2
a525 1
   while (ss->TexObjectList) {
d529 1
a529 1
      _mesa_free_texture_object(ss, ss->TexObjectList);
d559 1
a559 1
   _mesa_invalidate_spot_exp_table( l );
d561 1
a561 1
   l->_CosCutoff = 0.0;		/* KW: -ve values not admitted */
d573 1
a573 1
   ASSIGN_4V( lm->Ambient, 0.2F, 0.2F, 0.2F, 1.0F );
d583 4
a586 4
   ASSIGN_4V( m->Ambient,  0.2F, 0.2F, 0.2F, 1.0F );
   ASSIGN_4V( m->Diffuse,  0.8F, 0.8F, 0.8F, 1.0F );
   ASSIGN_4V( m->Specular, 0.0F, 0.0F, 0.0F, 1.0F );
   ASSIGN_4V( m->Emission, 0.0F, 0.0F, 0.0F, 1.0F );
d600 2
d626 4
a629 4
   texUnit->_GenBitS = TEXGEN_EYE_LINEAR;
   texUnit->_GenBitT = TEXGEN_EYE_LINEAR;
   texUnit->_GenBitR = TEXGEN_EYE_LINEAR;
   texUnit->_GenBitQ = TEXGEN_EYE_LINEAR;
d641 3
a643 3
   texUnit->Current1D = ctx->Shared->Default1D;
   texUnit->Current2D = ctx->Shared->Default2D;
   texUnit->Current3D = ctx->Shared->Default3D;
a644 1
   texUnit->CurrentRect = ctx->Shared->DefaultRect;
d648 48
a742 3
   assert(MAX_TEXTURE_LEVELS >= MAX_3D_TEXTURE_LEVELS);
   assert(MAX_TEXTURE_LEVELS >= MAX_CUBE_TEXTURE_LEVELS);

d745 2
a746 3
   ctx->Const.Max3DTextureLevels = MAX_3D_TEXTURE_LEVELS;
   ctx->Const.MaxCubeTextureLevels = MAX_CUBE_TEXTURE_LEVELS;
   ctx->Const.MaxTextureRectSize = MAX_TEXTURE_RECT_SIZE;
a747 2
   ctx->Const.MaxTextureMaxAnisotropy = MAX_TEXTURE_MAX_ANISOTROPY;
   ctx->Const.MaxTextureLodBias = MAX_TEXTURE_LOD_BIAS;
d754 1
a754 1
   ctx->Const.PointSizeGranularity = (GLfloat) POINT_SIZE_GRANULARITY;
d759 1
a759 1
   ctx->Const.LineWidthGranularity = (GLfloat) LINE_WIDTH_GRANULARITY;
a764 2
   ctx->Const.MaxClipPlanes = MAX_CLIP_PLANES;
   ctx->Const.MaxLights = MAX_LIGHTS;
d767 2
a768 2
   _math_matrix_ctr( &ctx->ModelView );
   _math_matrix_alloc_inv( &ctx->ModelView );
d772 2
a773 2
      _math_matrix_ctr( &ctx->ModelViewStack[i] );
      _math_matrix_alloc_inv( &ctx->ModelViewStack[i] );
d777 6
a782 2
   _math_matrix_ctr( &ctx->ProjectionMatrix );
   _math_matrix_alloc_inv( &ctx->ProjectionMatrix );
d785 3
d789 2
a790 2
      _math_matrix_ctr( &ctx->ProjectionStack[i] );
      _math_matrix_alloc_inv( &ctx->ProjectionStack[i] );
a792 3
   /* Derived ModelProject matrix */
   _math_matrix_ctr( &ctx->_ModelProjectMatrix );

d795 1
a795 1
      _math_matrix_ctr( &ctx->TextureMatrix[i] );
d798 1
a798 1
         _math_matrix_ctr( &ctx->TextureStack[i][j] );
d804 1
a804 1
   _math_matrix_ctr(&ctx->ColorMatrix);
d807 1
a807 1
      _math_matrix_ctr(&ctx->ColorStack[j]);
d819 1
d821 1
a821 1
   ASSIGN_4V( ctx->Color.ClearColor, 0, 0, 0, 0 );
d832 1
d836 1
d839 1
d842 1
a842 1
   ASSIGN_4V( ctx->Current.Color, 1.0, 1.0, 1.0, 1.0 );
d856 4
d861 1
a936 2
   ctx->Fog.ColorSumEnabled = GL_FALSE;
   ctx->Fog.FogCoordinateSource = GL_FRAGMENT_DEPTH_EXT;
d944 4
a949 1
   ctx->Hint.GenerateMipmap = GL_DONT_CARE;
d955 5
a959 5
   ctx->Histogram.RedSize       = 0;
   ctx->Histogram.GreenSize     = 0;
   ctx->Histogram.BlueSize      = 0;
   ctx->Histogram.AlphaSize     = 0;
   ctx->Histogram.LuminanceSize = 0;
d975 6
d982 3
a984 1
   _mesa_extensions_ctr( ctx );
d999 4
a1002 3
   ctx->Light.ColorMaterialBitmask = _mesa_material_bitmask( ctx,
                                               GL_FRONT_AND_BACK,
                                               GL_AMBIENT_AND_DIFFUSE, ~0, 0 );
d1007 2
a1008 2
   ctx->_ShineTabList = MALLOC_STRUCT( gl_shine_tab );
   make_empty_list( ctx->_ShineTabList );
d1013 1
a1013 1
      insert_at_tail( ctx->_ShineTabList, s );
d1015 9
a1029 1
   ctx->Line._Width = 1.0;
a1035 8
   /* Multisample */
   ctx->Multisample.Enabled = GL_FALSE;
   ctx->Multisample.SampleAlphaToCoverage = GL_FALSE;
   ctx->Multisample.SampleAlphaToOne = GL_FALSE;
   ctx->Multisample.SampleCoverage = GL_FALSE;
   ctx->Multisample.SampleCoverageValue = 1.0;
   ctx->Multisample.SampleCoverageInvert = GL_FALSE;

d1045 1
a1102 5
   for (i = 0; i < MAX_CONVOLUTION_WIDTH * MAX_CONVOLUTION_WIDTH * 4; i++) {
      ctx->Convolution1D.Filter[i] = 0.0;
      ctx->Convolution2D.Filter[i] = 0.0;
      ctx->Separable2D.Filter[i] = 0.0;
   }
d1108 1
a1109 1
   ctx->Point._Size = 1.0;
d1113 1
a1113 1
   ctx->Point._Attenuated = GL_FALSE;
d1115 1
a1115 1
   ctx->Point.MaxSize = ctx->Const.MaxPointSize;
d1122 1
a1122 1
   ctx->Polygon._FrontBit = 0;
d1125 1
a1129 1
   ctx->Polygon.OffsetMRD = 0.0F;
d1157 2
a1158 1
   ctx->Texture._ReallyEnabled = 0;
a1167 1
   ctx->Transform.RasterPositionUnclipped = GL_FALSE;
d1172 1
a1172 1
   ctx->Transform._AnyClip = GL_FALSE;
d1181 1
a1181 1
   _math_matrix_ctr(&ctx->Viewport._WindowMap);
d1185 2
a1186 2
   ctx->Viewport._WindowMap.m[Sz] = 0.5F * ctx->DepthMaxF;
   ctx->Viewport._WindowMap.m[Tz] = 0.5F * ctx->DepthMaxF;
d1190 2
a1191 2
   ctx->Viewport._WindowMap.flags = MAT_FLAG_GENERAL_SCALE|MAT_FLAG_TRANSLATION;
   ctx->Viewport._WindowMap.type = MATRIX_3D_NO_ROT;
d1194 7
a1206 1
   ctx->Array.Vertex.Flags = CA_CLIENT_DATA;
a1211 1
   ctx->Array.Normal.Flags = CA_CLIENT_DATA;
a1217 15
   ctx->Array.Color.Flags = CA_CLIENT_DATA;
   ctx->Array.SecondaryColor.Size = 4;
   ctx->Array.SecondaryColor.Type = GL_FLOAT;
   ctx->Array.SecondaryColor.Stride = 0;
   ctx->Array.SecondaryColor.StrideB = 0;
   ctx->Array.SecondaryColor.Ptr = NULL;
   ctx->Array.SecondaryColor.Enabled = GL_FALSE;
   ctx->Array.SecondaryColor.Flags = CA_CLIENT_DATA;
   ctx->Array.FogCoord.Size = 1;
   ctx->Array.FogCoord.Type = GL_FLOAT;
   ctx->Array.FogCoord.Stride = 0;
   ctx->Array.FogCoord.StrideB = 0;
   ctx->Array.FogCoord.Ptr = NULL;
   ctx->Array.FogCoord.Enabled = GL_FALSE;
   ctx->Array.FogCoord.Flags = CA_CLIENT_DATA;
a1222 1
   ctx->Array.Index.Flags = CA_CLIENT_DATA;
a1229 1
      ctx->Array.TexCoord[i].Flags = CA_CLIENT_DATA;
d1236 1
a1236 1
   ctx->Array.EdgeFlag.Flags = CA_CLIENT_DATA;
d1270 4
d1296 1
a1296 1
   ctx->NewState = _NEW_ALL;
d1298 7
a1304 5
   ctx->_ImageTransferState = 0;

   ctx->_NeedNormals = 0;
   ctx->_NeedEyeCoords = 0;
   ctx->_ModelViewInvScale = 1.0;
a1319 2
	/* XXX This causes an OSMesa build problem on Solaris 2.6 */
#ifndef SVR4
a1320 1
#endif
d1340 1
a1340 1
   ctx->Texture.Proxy1D = _mesa_alloc_texture_object(NULL, 0, GL_TEXTURE_1D);
d1345 1
a1345 1
   ctx->Texture.Proxy2D = _mesa_alloc_texture_object(NULL, 0, GL_TEXTURE_2D);
d1347 1
a1347 1
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy1D);
d1351 1
a1351 1
   ctx->Texture.Proxy3D = _mesa_alloc_texture_object(NULL, 0, GL_TEXTURE_3D);
d1353 2
a1354 19
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy1D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy2D);
      return GL_FALSE;
   }

   ctx->Texture.ProxyCubeMap = _mesa_alloc_texture_object(NULL, 0, GL_TEXTURE_CUBE_MAP_ARB);
   if (!ctx->Texture.ProxyCubeMap) {
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy1D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy2D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy3D);
      return GL_FALSE;
   }

   ctx->Texture.ProxyRect = _mesa_alloc_texture_object(NULL, 0, GL_TEXTURE_RECTANGLE_NV);
   if (!ctx->Texture.ProxyRect) {
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy1D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy2D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy3D);
      _mesa_free_texture_object(NULL, ctx->Texture.ProxyCubeMap);
a1362 2
      ctx->Texture.ProxyCubeMap->Image[i] = _mesa_alloc_texture_image();
      ctx->Texture.ProxyRect->Image[i] = _mesa_alloc_texture_image();
d1365 1
a1365 3
          || !ctx->Texture.Proxy3D->Image[i]
          || !ctx->Texture.ProxyCubeMap->Image[i]
          || !ctx->Texture.ProxyRect->Image[i]) {
a1379 6
         if (ctx->Texture.ProxyCubeMap->Image[i]) {
            _mesa_free_texture_image(ctx->Texture.ProxyCubeMap->Image[i]);
         }
         if (ctx->Texture.ProxyRect->Image[i]) {
            _mesa_free_texture_image(ctx->Texture.ProxyRect->Image[i]);
         }
d1381 3
a1383 5
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy1D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy2D);
      _mesa_free_texture_object(NULL, ctx->Texture.Proxy3D);
      _mesa_free_texture_object(NULL, ctx->Texture.ProxyCubeMap);
      _mesa_free_texture_object(NULL, ctx->Texture.ProxyRect);
a1391 37
static void add_debug_flags( const char *debug )
{
#ifdef MESA_DEBUG
   if (strstr(debug, "varray")) 
      MESA_VERBOSE |= VERBOSE_VARRAY;

   if (strstr(debug, "tex")) 
      MESA_VERBOSE |= VERBOSE_TEXTURE;

   if (strstr(debug, "imm")) 
      MESA_VERBOSE |= VERBOSE_IMMEDIATE;

   if (strstr(debug, "pipe")) 
      MESA_VERBOSE |= VERBOSE_PIPELINE;

   if (strstr(debug, "driver")) 
      MESA_VERBOSE |= VERBOSE_DRIVER;

   if (strstr(debug, "state")) 
      MESA_VERBOSE |= VERBOSE_STATE;

   if (strstr(debug, "api")) 
      MESA_VERBOSE |= VERBOSE_API;

   if (strstr(debug, "list")) 
      MESA_VERBOSE |= VERBOSE_DISPLAY_LIST;

   if (strstr(debug, "lighting")) 
      MESA_VERBOSE |= VERBOSE_LIGHTING;
   
   /* Debug flag:
    */
   if (strstr(debug, "flush")) 
      MESA_DEBUG_FLAGS |= DEBUG_ALWAYS_FLUSH;
#endif
}

d1399 1
a1399 1
                          const GLvisual *visual,
a1410 8
   /**
    ** OpenGL SI stuff
    **/
   if (!ctx->imports.malloc) {
      _mesa_InitDefaultImports(&ctx->imports, driver_ctx, NULL);
   }
   /* exports are setup by the device driver */

d1412 1
a1412 1
   ctx->Visual = *visual;
d1416 12
d1429 1
a1429 1
      /* share state with another context */
d1433 1
a1433 1
      /* allocate new, unshared state */
d1436 2
d1445 1
a1445 6
   /* Effectively bind the default textures to all texture units */
   ctx->Shared->Default1D->RefCount += MAX_TEXTURE_UNITS;
   ctx->Shared->Default2D->RefCount += MAX_TEXTURE_UNITS;
   ctx->Shared->Default3D->RefCount += MAX_TEXTURE_UNITS;
   ctx->Shared->DefaultCubeMap->RefCount += MAX_TEXTURE_UNITS;
   ctx->Shared->DefaultRect->RefCount += MAX_TEXTURE_UNITS;
d1447 2
a1448 1
   init_attrib_groups( ctx );
d1450 1
a1450 1
   if (visual->doubleBufferMode) {
d1467 2
d1495 2
a1503 36
   ctx->ExecPrefersFloat = GL_FALSE;
   ctx->SavePrefersFloat = GL_FALSE;

   /* Neutral tnl module stuff */
   _mesa_init_exec_vtxfmt( ctx );
   ctx->TnlModule.Current = NULL;
   ctx->TnlModule.SwapCount = 0;

   /* Z buffer stuff */
   if (ctx->Visual.depthBits == 0) {
      /* Special case.  Even if we don't have a depth buffer we need
       * good values for DepthMax for Z vertex transformation purposes
       * and for per-fragment fog computation.
       */
      ctx->DepthMax = 1 << 16;
      ctx->DepthMaxF = (GLfloat) ctx->DepthMax;
   }
   else if (ctx->Visual.depthBits < 32) {
      ctx->DepthMax = (1 << ctx->Visual.depthBits) - 1;
      ctx->DepthMaxF = (GLfloat) ctx->DepthMax;
   }
   else {
      /* Special case since shift values greater than or equal to the
       * number of bits in the left hand expression's type are undefined.
       */
      ctx->DepthMax = 0xffffffff;
      ctx->DepthMaxF = (GLfloat) ctx->DepthMax;
   }
   ctx->MRD = 1.0;  /* Minimum resolvable depth value, for polygon offset */

   if (getenv("MESA_DEBUG"))
      add_debug_flags(getenv("MESA_DEBUG"));

   if (getenv("MESA_VERBOSE"))
      add_debug_flags(getenv("MESA_VERBOSE"));

d1511 1
a1511 1
 * Input:  visual - a GLvisual pointer (we copy the struct contents)
d1514 1
a1514 1
 * Return:  pointer to a new __GLcontextRec or NULL if error.
d1517 4
a1520 4
_mesa_create_context( const GLvisual *visual,
                      GLcontext *share_list,
                      void *driver_ctx,
                      GLboolean direct )
d1526 1
a1526 1
   ctx->Driver.CurrentExecPrimitive = 0;
d1543 1
a1543 1
_mesa_free_context_data( GLcontext *ctx )
d1549 2
a1550 2
   if (ctx == _mesa_get_current_context()) {
      _mesa_make_current(NULL, NULL);
d1553 1
a1553 1
   _math_matrix_dtr( &ctx->ModelView );
d1555 1
a1555 1
      _math_matrix_dtr( &ctx->ModelViewStack[i] );
d1557 1
a1557 1
   _math_matrix_dtr( &ctx->ProjectionMatrix );
d1559 1
a1559 1
      _math_matrix_dtr( &ctx->ProjectionStack[i] );
d1562 1
a1562 1
      _math_matrix_dtr( &ctx->TextureMatrix[i] );
d1564 1
a1564 1
         _math_matrix_dtr( &ctx->TextureStack[i][j] );
d1568 1
a1568 1
   _math_matrix_dtr( &ctx->_ModelProjectMatrix );
d1570 4
a1573 4
   _math_matrix_dtr(&ctx->ColorMatrix);
   for (j = 0; j < MAX_COLOR_STACK_DEPTH - 1; j++) {
      _math_matrix_dtr(&ctx->ColorStack[j]);
   }
d1584 1
a1584 1
   foreach_s( s, tmps, ctx->_ShineTabList ) {
d1587 1
a1587 1
   FREE( ctx->_ShineTabList );
d1590 3
a1592 5
   _mesa_free_texture_object( NULL, ctx->Texture.Proxy1D );
   _mesa_free_texture_object( NULL, ctx->Texture.Proxy2D );
   _mesa_free_texture_object( NULL, ctx->Texture.Proxy3D );
   _mesa_free_texture_object( NULL, ctx->Texture.ProxyCubeMap );
   _mesa_free_texture_object( NULL, ctx->Texture.ProxyRect );
d1638 7
a1644 3
   _math_matrix_dtr(&ctx->Viewport._WindowMap);

   _mesa_extensions_dtr(ctx);
d1656 1
a1656 1
_mesa_destroy_context( GLcontext *ctx )
d1659 1
a1659 1
      _mesa_free_context_data(ctx);
d1667 12
d1685 1
a1685 1
_mesa_copy_context( const GLcontext *src, GLcontext *dst, GLuint mask )
d1688 1
a1688 2
      /* OK to memcpy */
      dst->Accum = src->Accum;
d1691 1
a1691 2
      /* OK to memcpy */
      dst->Color = src->Color;
d1694 1
a1694 2
      /* OK to memcpy */
      dst->Current = src->Current;
d1697 1
a1697 2
      /* OK to memcpy */
      dst->Depth = src->Depth;
d1703 1
a1703 2
      /* OK to memcpy */
      dst->Eval = src->Eval;
d1706 1
a1706 2
      /* OK to memcpy */
      dst->Fog = src->Fog;
d1709 1
a1709 2
      /* OK to memcpy */
      dst->Hint = src->Hint;
d1712 2
a1713 10
      GLuint i;
      /* begin with memcpy */
      MEMCPY( &dst->Light, &src->Light, sizeof(struct gl_light) );
      /* fixup linked lists to prevent pointer insanity */
      make_empty_list( &(dst->Light.EnabledList) );
      for (i = 0; i < MAX_LIGHTS; i++) {
         if (dst->Light.Light[i].Enabled) {
            insert_at_tail(&(dst->Light.EnabledList), &(dst->Light.Light[i]));
         }
      }
d1716 1
a1716 2
      /* OK to memcpy */
      dst->Line = src->Line;
d1719 1
a1719 2
      /* OK to memcpy */
      dst->List = src->List;
d1722 1
a1722 2
      /* OK to memcpy */
      dst->Pixel = src->Pixel;
d1725 1
a1725 2
      /* OK to memcpy */
      dst->Point = src->Point;
d1728 1
a1728 2
      /* OK to memcpy */
      dst->Polygon = src->Polygon;
d1734 2
a1735 2
      GLuint i;
      for (i = 0; i < 32; i++) {
d1740 1
a1740 2
      /* OK to memcpy */
      dst->Scissor = src->Scissor;
d1743 1
a1743 2
      /* OK to memcpy */
      dst->Stencil = src->Stencil;
d1746 1
a1746 2
      /* Cannot memcpy because of pointers */
      _mesa_copy_texture_state(src, dst);
d1749 1
a1749 2
      /* OK to memcpy */
      dst->Transform = src->Transform;
d1752 1
a1752 8
      /* Cannot use memcpy, because of pointers in GLmatrix _WindowMap */
      dst->Viewport.X = src->Viewport.X;
      dst->Viewport.Y = src->Viewport.Y;
      dst->Viewport.Width = src->Viewport.Width;
      dst->Viewport.Height = src->Viewport.Height;
      dst->Viewport.Near = src->Viewport.Near;
      dst->Viewport.Far = src->Viewport.Far;
      _math_matrix_copy(&dst->Viewport._WindowMap, &src->Viewport._WindowMap);
a1753 4

   /* XXX FIXME:  Call callbacks?
    */
   dst->NewState = _NEW_ALL;
d1760 1
a1760 2
void
_mesa_make_current( GLcontext *newCtx, GLframebuffer *buffer )
d1762 1
a1762 29
   _mesa_make_current2( newCtx, buffer, buffer );
}


static void print_info( void )
{
   fprintf(stderr, "Mesa GL_VERSION = %s\n",
	   (char *) _mesa_GetString(GL_VERSION));
   fprintf(stderr, "Mesa GL_RENDERER = %s\n",
	   (char *) _mesa_GetString(GL_RENDERER));
   fprintf(stderr, "Mesa GL_VENDOR = %s\n",
	   (char *) _mesa_GetString(GL_VENDOR));
   fprintf(stderr, "Mesa GL_EXTENSIONS = %s\n",
	   (char *) _mesa_GetString(GL_EXTENSIONS));
#if defined(THREADS)
   fprintf(stderr, "Mesa thread-safe: YES\n");
#else
   fprintf(stderr, "Mesa thread-safe: NO\n");
#endif
#if defined(USE_X86_ASM)
   fprintf(stderr, "Mesa x86-optimized: YES\n");
#else
   fprintf(stderr, "Mesa x86-optimized: NO\n");
#endif
#if defined(USE_SPARC_ASM)
   fprintf(stderr, "Mesa sparc-optimized: YES\n");
#else
   fprintf(stderr, "Mesa sparc-optimized: NO\n");
#endif
d1770 2
a1771 3
void
_mesa_make_current2( GLcontext *newCtx, GLframebuffer *drawBuffer,
                     GLframebuffer *readBuffer )
d1773 2
a1774 2
   if (MESA_VERBOSE)
      fprintf(stderr, "_mesa_make_current2()\n");
d1776 1
a1776 3
   /* Check that the context's and framebuffer's visuals are compatible.
    * We could do a lot more checking here but this'll catch obvious
    * problems.
d1778 9
a1786 7
   if (newCtx && drawBuffer && readBuffer) {
      if (newCtx->Visual.rgbMode != drawBuffer->Visual.rgbMode ||
          newCtx->Visual.redBits != drawBuffer->Visual.redBits ||
          newCtx->Visual.depthBits != drawBuffer->Visual.depthBits ||
          newCtx->Visual.stencilBits != drawBuffer->Visual.stencilBits ||
          newCtx->Visual.accumRedBits != drawBuffer->Visual.accumRedBits) {
         return; /* incompatible */
d1789 1
d1797 6
a1802 4
   ASSERT(_mesa_get_current_context() == newCtx);


   if (!newCtx) {
a1804 2
   else {
      _glapi_set_dispatch(newCtx->CurrentDispatch);
d1806 1
a1806 12
      if (drawBuffer && readBuffer) {
	 /* TODO: check if newCtx and buffer's visual match??? */
	 newCtx->DrawBuffer = drawBuffer;
	 newCtx->ReadBuffer = readBuffer;
	 newCtx->NewState |= _NEW_BUFFERS;

         if (drawBuffer->Width == 0 && drawBuffer->Height == 0) {
            /* get initial window size */
            GLuint bufWidth, bufHeight;

            /* ask device driver for size of output buffer */
            (*newCtx->Driver.GetBufferSize)( drawBuffer, &bufWidth, &bufHeight );
d1808 7
a1814 2
            if (drawBuffer->Width == bufWidth && drawBuffer->Height == bufHeight)
               return; /* size is as expected */
d1816 21
a1836 37
            drawBuffer->Width = bufWidth;
            drawBuffer->Height = bufHeight;

            newCtx->Driver.ResizeBuffers( drawBuffer );
         }

         if (readBuffer != drawBuffer &&
             readBuffer->Width == 0 && readBuffer->Height == 0) {
            /* get initial window size */
            GLuint bufWidth, bufHeight;

            /* ask device driver for size of output buffer */
            (*newCtx->Driver.GetBufferSize)( readBuffer, &bufWidth, &bufHeight );

            if (readBuffer->Width == bufWidth && readBuffer->Height == bufHeight)
               return; /* size is as expected */

            readBuffer->Width = bufWidth;
            readBuffer->Height = bufHeight;

            newCtx->Driver.ResizeBuffers( readBuffer );
         }
      }

      if (newCtx->Driver.MakeCurrent)
	 newCtx->Driver.MakeCurrent( newCtx, drawBuffer, readBuffer );

      /* We can use this to help debug user's problems.  Tell them to set
       * the MESA_INFO env variable before running their app.  Then the
       * first time each context is made current we'll print some useful
       * information.
       */
      if (newCtx->FirstTimeCurrent) {
	 if (getenv("MESA_INFO")) {
	    print_info();
	 }
	 newCtx->FirstTimeCurrent = GL_FALSE;
d1838 1
d1849 1
a1849 2
GLcontext *
_mesa_get_current_context( void )
d1863 1
a1863 1
   FLUSH_VERTICES( ctx, 0 );
d1890 1
a1890 1
void _mesa_problem( const GLcontext *ctx, const char *s )
d1908 1
a1908 2
void
_mesa_warning( const GLcontext *ctx, const char *s )
d1910 15
a1924 1
   (*ctx->imports.warning)((__GLcontext *) ctx, (char *) s);
d1932 1
a1932 2
void
_mesa_compile_error( GLcontext *ctx, GLenum error, const char *s )
d1935 1
a1935 1
      _mesa_save_error( ctx, error, s );
d1938 1
a1938 1
      _mesa_error( ctx, error, s );
d1953 1
a1953 1
_mesa_error( GLcontext *ctx, GLenum error, const char *where )
a2003 3
   if (!ctx)
      return;

d2020 1
a2020 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
d2032 1
a2032 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
a2036 18



const char *_mesa_prim_name[GL_POLYGON+4] = {
   "GL_POINTS",
   "GL_LINES",
   "GL_LINE_LOOP",
   "GL_LINE_STRIP",
   "GL_TRIANGLES",
   "GL_TRIANGLE_STRIP",
   "GL_TRIANGLE_FAN",
   "GL_QUADS",
   "GL_QUAD_STRIP",
   "GL_POLYGON",
   "outside begin/end",
   "inside unkown primitive",
   "unknown state"
};
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d4 1
a4 1
 * Version:  4.1
d27 3
a30 1
#include "imports.h"
d43 1
d46 1
a54 3
#if FEATURE_NV_vertex_program
#include "vpstate.h"
#endif
d56 1
d58 1
d62 1
a62 1

a80 5

static void
free_shared_state( GLcontext *ctx, struct gl_shared_state *ss );


d85 2
a86 5
/* Called by window system/device driver (via gc->exports.destroyCurrent())
 * when the rendering context is to be destroyed.
 */
GLboolean
_mesa_destroyContext(__GLcontext *gc)
d90 1
a90 1
      _mesa_free(gc);
a94 129
/* Called by window system/device driver (via gc->exports.loseCurrent())
 * when the rendering context is made non-current.
 */
GLboolean
_mesa_loseCurrent(__GLcontext *gc)
{
   /* XXX unbind context from thread */
   return GL_TRUE;
}

/* Called by window system/device driver (via gc->exports.makeCurrent())
 * when the rendering context is made current.
 */
GLboolean
_mesa_makeCurrent(__GLcontext *gc)
{
   /* XXX bind context to thread */
   return GL_TRUE;
}

/* Called by window system/device driver - yadda, yadda, yadda.
 * See above comments.
 */
GLboolean
_mesa_shareContext(__GLcontext *gc, __GLcontext *gcShare)
{
   if (gc && gcShare && gc->Shared && gcShare->Shared) {
      gc->Shared->RefCount--;
      if (gc->Shared->RefCount == 0) {
         free_shared_state(gc, gc->Shared);
      }
      gc->Shared = gcShare->Shared;
      gc->Shared->RefCount++;
      return GL_TRUE;
   }
   else {
      return GL_FALSE;
   }
}

GLboolean
_mesa_copyContext(__GLcontext *dst, const __GLcontext *src, GLuint mask)
{
   if (dst && src) {
      _mesa_copy_context( src, dst, mask );
      return GL_TRUE;
   }
   else {
      return GL_FALSE;
   }
}

GLboolean
_mesa_forceCurrent(__GLcontext *gc)
{
   return GL_TRUE;
}

GLboolean
_mesa_notifyResize(__GLcontext *gc)
{
   GLint x, y;
   GLuint width, height;
   __GLdrawablePrivate *d = gc->imports.getDrawablePrivate(gc);
   if (!d || !d->getDrawableSize)
      return GL_FALSE;
   d->getDrawableSize( d, &x, &y, &width, &height );
   /* update viewport, resize software buffers, etc. */
   return GL_TRUE;
}

void
_mesa_notifyDestroy(__GLcontext *gc)
{
   /* Called when the context's window/buffer is going to be destroyed. */
   /* Unbind from it. */
}

/* Called by window system just before swapping buffers.
 * We have to finish any pending rendering.
 */
void
_mesa_notifySwapBuffers(__GLcontext *gc)
{
   FLUSH_VERTICES( gc, 0 );
}

struct __GLdispatchStateRec *
_mesa_dispatchExec(__GLcontext *gc)
{
   return NULL;
}

void
_mesa_beginDispatchOverride(__GLcontext *gc)
{
}

void
_mesa_endDispatchOverride(__GLcontext *gc)
{
}

/* Setup the exports.  The window system will call these functions
 * when it needs Mesa to do something.
 * NOTE: Device drivers should override these functions!  For example,
 * the Xlib driver should plug in the XMesa*-style functions into this
 * structure.  The XMesa-style functions should then call the _mesa_*
 * version of these functions.  This is an approximation to OO design
 * (inheritance and virtual functions).
 */
static void
_mesa_init_default_exports(__GLexports *exports)
{
    exports->destroyContext = _mesa_destroyContext;
    exports->loseCurrent = _mesa_loseCurrent;
    exports->makeCurrent = _mesa_makeCurrent;
    exports->shareContext = _mesa_shareContext;
    exports->copyContext = _mesa_copyContext;
    exports->forceCurrent = _mesa_forceCurrent;
    exports->notifyResize = _mesa_notifyResize;
    exports->notifyDestroy = _mesa_notifyDestroy;
    exports->notifySwapBuffers = _mesa_notifySwapBuffers;
    exports->dispatchExec = _mesa_dispatchExec;
    exports->beginDispatchOverride = _mesa_beginDispatchOverride;
    exports->endDispatchOverride = _mesa_endDispatchOverride;
}


d102 1
a102 1
    ctx = (GLcontext *) (*imports->calloc)(NULL, 1, sizeof(GLcontext));
d106 19
d126 4
a129 2
    _mesa_initialize_context(ctx, modes, NULL, imports, GL_FALSE);
    ctx->imports = *imports;
d150 6
a265 1

a278 8
   vis->haveAccumBuffer   = accumRedBits > 0;
   vis->haveDepthBuffer   = depthBits > 0;
   vis->haveStencilBuffer = stencilBits > 0;

   vis->numAuxBuffers = 0;
   vis->level = 0;
   vis->pixmapMode = 0;

d339 1
a339 1
   _mesa_bzero(buffer, sizeof(GLframebuffer));
d433 1
a433 1
one_time_init( GLcontext *ctx )
d454 1
a454 1
      if (_mesa_getenv("MESA_DEBUG")) {
a455 7
#ifndef GLX_DIRECT_RENDERING
         /* libGL from before 2002/06/28 don't have this function.  Someday,
          * when newer libGL libs are common, remove the #ifdef test.  This
          * only serves to print warnings when calling undefined GL functions.
          */
         _glapi_set_warning_func( (_glapi_warning_func) _mesa_warning );
#endif
d462 1
a462 1
      _mesa_debug(ctx, "Mesa DEBUG build %s %s\n", __DATE__, __TIME__);
a470 30
static void
init_matrix_stack( struct matrix_stack *stack,
                   GLuint maxDepth, GLuint dirtyFlag )
{
   GLuint i;

   stack->Depth = 0;
   stack->MaxDepth = maxDepth;
   stack->DirtyFlag = dirtyFlag;
   /* The stack */
   stack->Stack = (GLmatrix *) CALLOC(maxDepth * sizeof(GLmatrix));
   for (i = 0; i < maxDepth; i++) {
      _math_matrix_ctr(&stack->Stack[i]);
      _math_matrix_alloc_inv(&stack->Stack[i]);
   }
   stack->Top = stack->Stack;
}


static void
free_matrix_stack( struct matrix_stack *stack )
{
   GLuint i;
   for (i = 0; i < stack->MaxDepth; i++) {
      _math_matrix_dtr(&stack->Stack[i]);
   }
   FREE(stack->Stack);
   stack->Stack = stack->Top = NULL;
}

a488 3
#if FEATURE_NV_vertex_program
   ss->VertexPrograms = _mesa_NewHashTable();
#endif
d520 1
a520 5
   if (!ss->DisplayList || !ss->TexObjects
#if FEATURE_NV_vertex_program
       || !ss->VertexPrograms
#endif
       || outOfMemory) {
a525 2
      if (ss->VertexPrograms)
         _mesa_DeleteHashTable(ss->VertexPrograms);
a571 16
#if FEATURE_NV_vertex_program
   /* Free vertex programs */
   while (1) {
      GLuint prog = _mesa_HashFirstEntry(ss->VertexPrograms);
      if (prog) {
         _mesa_delete_program(ctx, prog);
      }
      else {
         break;
      }
   }
   _mesa_DeleteHashTable(ss->VertexPrograms);
#endif

   _glthread_DESTROY_MUTEX(ss->Mutex);

d729 1
a729 1
   GLuint i;
d760 1
d764 19
a782 14
   /* Initialize matrix stacks */
   init_matrix_stack(&ctx->ModelviewMatrixStack, MAX_MODELVIEW_STACK_DEPTH,
                     _NEW_MODELVIEW);
   init_matrix_stack(&ctx->ProjectionMatrixStack, MAX_PROJECTION_STACK_DEPTH,
                     _NEW_PROJECTION);
   init_matrix_stack(&ctx->ColorMatrixStack, MAX_COLOR_STACK_DEPTH,
                     _NEW_COLOR_MATRIX);
   for (i = 0; i < MAX_TEXTURE_UNITS; i++)
      init_matrix_stack(&ctx->TextureMatrixStack[i], MAX_TEXTURE_STACK_DEPTH,
                        _NEW_TEXTURE_MATRIX);
   for (i = 0; i < MAX_PROGRAM_MATRICES; i++)
      init_matrix_stack(&ctx->ProgramMatrixStack[i], MAX_PROGRAM_STACK_DEPTH,
                        _NEW_TRACK_MATRIX);
   ctx->CurrentStack = &ctx->ModelviewMatrixStack;
d784 1
a784 1
   /* Init combined Modelview*Projection matrix */
d787 17
a827 1
   ctx->Color._LogicOpEnabled = GL_FALSE;
d832 1
a832 7
   for (i = 0; i < VERT_ATTRIB_MAX; i++) {
      ASSIGN_4V( ctx->Current.Attrib[i], 0.0, 0.0, 0.0, 1.0 );
   }
   /* special cases: */
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_WEIGHT], 1.0, 0.0, 0.0, 1.0 );
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_NORMAL], 0.0, 0.0, 1.0, 1.0 );
   ASSIGN_4V( ctx->Current.Attrib[VERT_ATTRIB_COLOR0], 1.0, 1.0, 1.0, 1.0 );
d834 2
a835 2
   ctx->Current.EdgeFlag = GL_TRUE;
   
a838 1
   ASSIGN_4V( ctx->Current.RasterSecondaryColor, 0.0, 0.0, 0.0, 0.0 );
d841 2
a842 1
      ASSIGN_4V( ctx->Current.RasterTexCoords[i], 0.0, 0.0, 0.0, 1.0 );
d844 2
a864 1
   MEMSET(ctx->Eval.Map1Attrib, 0, sizeof(ctx->Eval.Map1Attrib));
a873 1
   MEMSET(ctx->Eval.Map2Attrib, 0, sizeof(ctx->Eval.Map2Attrib));
a891 1
      static GLfloat attrib[4] = { 0.0, 0.0, 0.0, 1.0 };
a901 2
      for (i = 0; i < 16; i++)
         init_1d_map( ctx->EvalMap.Map1Attrib + i, 4, attrib );
a911 2
      for (i = 0; i < 16; i++)
         init_2d_map( ctx->EvalMap.Map2Attrib + i, 4, attrib );
a1095 5
   ctx->Point.PointSprite = GL_FALSE; /* GL_NV_point_sprite */
   ctx->Point.SpriteRMode = GL_ZERO; /* GL_NV_point_sprite */
   for (i = 0; i < MAX_TEXTURE_UNITS; i++) {
      ctx->Point.CoordReplace[i] = GL_FALSE; /* GL_NV_point_sprite */
   }
d1108 1
d1125 6
a1130 16
   ctx->Stencil.TestTwoSide = GL_FALSE;
   ctx->Stencil.ActiveFace = 0;  /* 0 = GL_FRONT, 1 = GL_BACK */
   ctx->Stencil.Function[0] = GL_ALWAYS;
   ctx->Stencil.Function[1] = GL_ALWAYS;
   ctx->Stencil.FailFunc[0] = GL_KEEP;
   ctx->Stencil.FailFunc[1] = GL_KEEP;
   ctx->Stencil.ZPassFunc[0] = GL_KEEP;
   ctx->Stencil.ZPassFunc[1] = GL_KEEP;
   ctx->Stencil.ZFailFunc[0] = GL_KEEP;
   ctx->Stencil.ZFailFunc[1] = GL_KEEP;
   ctx->Stencil.Ref[0] = 0;
   ctx->Stencil.Ref[1] = 0;
   ctx->Stencil.ValueMask[0] = STENCIL_MAX;
   ctx->Stencil.ValueMask[1] = STENCIL_MAX;
   ctx->Stencil.WriteMask[0] = STENCIL_MAX;
   ctx->Stencil.WriteMask[1] = STENCIL_MAX;
d1132 1
d1136 1
a1136 1
   ctx->Texture._EnabledUnits = 0;
d1148 1
d1151 1
a1151 1
   ctx->Transform.ClipPlanesEnabled = 0;
d1193 1
a1193 1
   ctx->Array.SecondaryColor.Size = 3;
a1281 12
   /* GL_NV_vertex_program */
   ctx->VertexProgram.Enabled = GL_FALSE;
   ctx->VertexProgram.PointSizeEnabled = GL_FALSE;
   ctx->VertexProgram.TwoSideEnabled = GL_FALSE;
   ctx->VertexProgram.CurrentID = 0;
   ctx->VertexProgram.ErrorPos = -1;
   ctx->VertexProgram.Current = NULL;
   for (i = 0; i < VP_NUM_PROG_REGS / 4; i++) {
      ctx->VertexProgram.TrackMatrix[i] = GL_NONE;
      ctx->VertexProgram.TrackMatrixTransform[i] = GL_IDENTITY_NV;
   }

a1295 1
   ctx->_Facing = 0;
d1298 1
a1298 1
   ctx->NoRaster = _mesa_getenv("MESA_NO_RASTER") ? GL_TRUE : GL_FALSE;
d1302 1
a1302 1
   ctx->NoDither = _mesa_getenv("MESA_NO_DITHER") ? GL_TRUE : GL_FALSE;
d1304 5
a1308 2
      if (_mesa_getenv("MESA_DEBUG")) {
         _mesa_debug(ctx, "MESA_NO_DITHER set - dithering disabled\n");
d1346 1
a1346 2
   ctx->Texture.ProxyCubeMap = _mesa_alloc_texture_object(NULL, 0,
                                                     GL_TEXTURE_CUBE_MAP_ARB);
d1354 1
a1354 2
   ctx->Texture.ProxyRect = _mesa_alloc_texture_object(NULL, 0,
                                                      GL_TEXTURE_RECTANGLE_NV);
d1369 1
d1373 2
a1374 1
          || !ctx->Texture.ProxyCubeMap->Image[i]) {
a1377 4
   ctx->Texture.ProxyRect->Image[0] = _mesa_alloc_texture_image();
   if (!ctx->Texture.ProxyRect->Image[0])
      out_of_memory = GL_TRUE;

d1392 3
a1394 3
      }
      if (ctx->Texture.ProxyRect->Image[0]) {
         _mesa_free_texture_image(ctx->Texture.ProxyRect->Image[0]);
d1412 1
a1412 1
   if (_mesa_strstr(debug, "varray")) 
d1415 1
a1415 1
   if (_mesa_strstr(debug, "tex")) 
d1418 1
a1418 1
   if (_mesa_strstr(debug, "imm")) 
d1421 1
a1421 1
   if (_mesa_strstr(debug, "pipe")) 
d1424 1
a1424 1
   if (_mesa_strstr(debug, "driver")) 
d1427 1
a1427 1
   if (_mesa_strstr(debug, "state")) 
d1430 1
a1430 1
   if (_mesa_strstr(debug, "api")) 
d1433 1
a1433 1
   if (_mesa_strstr(debug, "list")) 
d1436 1
a1436 1
   if (_mesa_strstr(debug, "lighting")) 
d1441 1
a1441 1
   if (_mesa_strstr(debug, "flush")) 
a1458 1
   const char *c;
d1460 1
a1460 1
   ASSERT(driver_ctx);
d1462 2
a1463 4
   /* If the driver wants core Mesa to use special imports, it'll have to
    * override these defaults.
    */
   _mesa_init_default_imports( &(ctx->imports), driver_ctx );
d1465 7
a1471 5
   /* initialize the exports (Mesa functions called by the window system) */
   _mesa_init_default_exports( &(ctx->exports) );

   /* misc one-time initializations */
   one_time_init(ctx);
d1504 2
a1505 1
      ctx->Color._DrawDestMask = BACK_LEFT_BIT;
d1507 1
a1507 1
      ctx->Pixel._ReadSrcMask = BACK_LEFT_BIT;
d1511 2
a1512 1
      ctx->Color._DrawDestMask = FRONT_LEFT_BIT;
d1514 1
a1514 1
      ctx->Pixel._ReadSrcMask = FRONT_LEFT_BIT;
d1522 9
a1530 100
   /*
    * For XFree86/DRI: tell libGL to add these functions to the dispatcher.
    * Basically, we should add all extension functions above offset 577.
    * This enables older libGL libraries to work with newer drivers that
    * have newer extensions.
    */
   /* GL_ARB_window_pos aliases with GL_MESA_window_pos */
   _glapi_add_entrypoint("glWindowPos2dARB", 513);
   _glapi_add_entrypoint("glWindowPos2dvARB", 514);
   _glapi_add_entrypoint("glWindowPos2fARB", 515);
   _glapi_add_entrypoint("glWindowPos2fvARB", 516);
   _glapi_add_entrypoint("glWindowPos2iARB", 517);
   _glapi_add_entrypoint("glWindowPos2ivARB", 518);
   _glapi_add_entrypoint("glWindowPos2sARB", 519);
   _glapi_add_entrypoint("glWindowPos2svARB", 520);
   _glapi_add_entrypoint("glWindowPos3dARB", 521);
   _glapi_add_entrypoint("glWindowPos3dvARB", 522);
   _glapi_add_entrypoint("glWindowPos3fARB", 523);
   _glapi_add_entrypoint("glWindowPos3fvARB", 524);
   _glapi_add_entrypoint("glWindowPos3iARB", 525);
   _glapi_add_entrypoint("glWindowPos3ivARB", 526);
   _glapi_add_entrypoint("glWindowPos3sARB", 527);
   _glapi_add_entrypoint("glWindowPos3svARB", 528);
   /* new extension functions */
   _glapi_add_entrypoint("glAreProgramsResidentNV", 578);
   _glapi_add_entrypoint("glBindProgramNV", 579);
   _glapi_add_entrypoint("glDeleteProgramsNV", 580);
   _glapi_add_entrypoint("glExecuteProgramNV", 581);
   _glapi_add_entrypoint("glGenProgramsNV", 582);
   _glapi_add_entrypoint("glGetProgramParameterdvNV", 583);
   _glapi_add_entrypoint("glGetProgramParameterfvNV", 584);
   _glapi_add_entrypoint("glGetProgramivNV", 585);
   _glapi_add_entrypoint("glGetProgramStringNV", 586);
   _glapi_add_entrypoint("glGetTrackMatrixivNV", 587);
   _glapi_add_entrypoint("glGetVertexAttribdvNV", 588);
   _glapi_add_entrypoint("glGetVertexAttribfvNV", 589);
   _glapi_add_entrypoint("glGetVertexAttribivNV", 590);
   _glapi_add_entrypoint("glGetVertexAttribPointervNV", 591);
   _glapi_add_entrypoint("glIsProgramNV", 592);
   _glapi_add_entrypoint("glLoadProgramNV", 593);
   _glapi_add_entrypoint("glProgramParameter4dNV", 594);
   _glapi_add_entrypoint("glProgramParameter4dvNV", 595);
   _glapi_add_entrypoint("glProgramParameter4fNV", 596);
   _glapi_add_entrypoint("glProgramParameter4fvNV", 597);
   _glapi_add_entrypoint("glProgramParameters4dvNV", 598);
   _glapi_add_entrypoint("glProgramParameters4fvNV", 599);
   _glapi_add_entrypoint("glRequestResidentProgramsNV", 600);
   _glapi_add_entrypoint("glTrackMatrixNV", 601);
   _glapi_add_entrypoint("glVertexAttribPointerNV", 602);
   _glapi_add_entrypoint("glVertexAttrib1dNV", 603);
   _glapi_add_entrypoint("glVertexAttrib1dvNV", 604);
   _glapi_add_entrypoint("glVertexAttrib1fNV", 605);
   _glapi_add_entrypoint("glVertexAttrib1fvNV", 606);
   _glapi_add_entrypoint("glVertexAttrib1sNV", 607);
   _glapi_add_entrypoint("glVertexAttrib1svNV", 608);
   _glapi_add_entrypoint("glVertexAttrib2dNV", 609);
   _glapi_add_entrypoint("glVertexAttrib2dvNV", 610);
   _glapi_add_entrypoint("glVertexAttrib2fNV", 611);
   _glapi_add_entrypoint("glVertexAttrib2fvNV", 612);
   _glapi_add_entrypoint("glVertexAttrib2sNV", 613);
   _glapi_add_entrypoint("glVertexAttrib2svNV", 614);
   _glapi_add_entrypoint("glVertexAttrib3dNV", 615);
   _glapi_add_entrypoint("glVertexAttrib3dvNV", 616);
   _glapi_add_entrypoint("glVertexAttrib3fNV", 617);
   _glapi_add_entrypoint("glVertexAttrib3fvNV", 618);
   _glapi_add_entrypoint("glVertexAttrib3sNV", 619);
   _glapi_add_entrypoint("glVertexAttrib3svNV", 620);
   _glapi_add_entrypoint("glVertexAttrib4dNV", 621);
   _glapi_add_entrypoint("glVertexAttrib4dvNV", 622);
   _glapi_add_entrypoint("glVertexAttrib4fNV", 623);
   _glapi_add_entrypoint("glVertexAttrib4fvNV", 624);
   _glapi_add_entrypoint("glVertexAttrib4sNV", 625);
   _glapi_add_entrypoint("glVertexAttrib4svNV", 626);
   _glapi_add_entrypoint("glVertexAttrib4ubNV", 627);
   _glapi_add_entrypoint("glVertexAttrib4ubvNV", 628);
   _glapi_add_entrypoint("glVertexAttribs1dvNV", 629);
   _glapi_add_entrypoint("glVertexAttribs1fvNV", 630);
   _glapi_add_entrypoint("glVertexAttribs1svNV", 631);
   _glapi_add_entrypoint("glVertexAttribs2dvNV", 632);
   _glapi_add_entrypoint("glVertexAttribs2fvNV", 633);
   _glapi_add_entrypoint("glVertexAttribs2svNV", 634);
   _glapi_add_entrypoint("glVertexAttribs3dvNV", 635);
   _glapi_add_entrypoint("glVertexAttribs3fvNV", 636);
   _glapi_add_entrypoint("glVertexAttribs3svNV", 637);
   _glapi_add_entrypoint("glVertexAttribs4dvNV", 638);
   _glapi_add_entrypoint("glVertexAttribs4fvNV", 639);
   _glapi_add_entrypoint("glVertexAttribs4svNV", 640);
   _glapi_add_entrypoint("glVertexAttribs4ubvNV", 641);
   _glapi_add_entrypoint("glPointParameteriNV", 642);
   _glapi_add_entrypoint("glPointParameterivNV", 643);
   _glapi_add_entrypoint("glMultiDrawArraysEXT", 644);
   _glapi_add_entrypoint("glMultiDrawElementsEXT", 645);
   _glapi_add_entrypoint("glActiveStencilFaceEXT", 646);
   _glapi_add_entrypoint("glDeleteFencesNV", 647);
   _glapi_add_entrypoint("glGenFencesNV", 648);
   _glapi_add_entrypoint("glIsFenceNV", 649);
   _glapi_add_entrypoint("glTestFenceNV", 650);
   _glapi_add_entrypoint("glGetFenceivNV", 651);
   _glapi_add_entrypoint("glFinishFenceNV", 652);
   _glapi_add_entrypoint("glSetFenceNV", 653);
d1582 5
a1586 7
   c = _mesa_getenv("MESA_DEBUG");
   if (c)
      add_debug_flags(c);

   c = _mesa_getenv("MESA_VERBOSE");
   if (c)
      add_debug_flags(c);
a1597 1
 *         direct - direct rendering?
a1604 1

d1606 2
a1607 7
   GLcontext *ctx;

   ASSERT(visual);
   ASSERT(driver_ctx);

   ctx = (GLcontext *) _mesa_calloc(sizeof(GLcontext));
   if (!ctx)
d1609 2
a1610 1

d1615 1
a1615 1
      _mesa_free(ctx);
d1630 1
a1630 1
   GLuint i;
d1637 15
a1651 11
   /*
    * Free transformation matrix stacks
    */
   free_matrix_stack(&ctx->ModelviewMatrixStack);
   free_matrix_stack(&ctx->ProjectionMatrixStack);
   free_matrix_stack(&ctx->ColorMatrixStack);
   for (i = 0; i < MAX_TEXTURE_UNITS; i++)
      free_matrix_stack(&ctx->TextureMatrixStack[i]);
   for (i = 0; i < MAX_PROGRAM_MATRICES; i++)
      free_matrix_stack(&ctx->ProgramMatrixStack[i]);
   /* combined Modelview*Projection matrix */
d1654 3
a1656 6

#if FEATURE_NV_vertex_program
   if (ctx->VertexProgram.Current) {
      ctx->VertexProgram.Current->RefCount--;
      if (ctx->VertexProgram.Current->RefCount <= 0)
         _mesa_delete_program(ctx, ctx->VertexProgram.CurrentID);
a1657 1
#endif
a1658 1
   /* Shared context state (display lists, textures, etc) */
a1667 1
   /* Free lighting shininess exponentiation table */
a1698 2
   for (i = 0; i < 16; i++)
      FREE((ctx->EvalMap.Map1Attrib[i].Points));
a1717 2
   for (i = 0; i < 16; i++)
      FREE((ctx->EvalMap.Map2Attrib[i].Points));
d1862 9
d1874 1
a1874 1
   _mesa_debug(NULL, "Mesa GL_VERSION = %s\n",
d1876 1
a1876 1
   _mesa_debug(NULL, "Mesa GL_RENDERER = %s\n",
d1878 1
a1878 1
   _mesa_debug(NULL, "Mesa GL_VENDOR = %s\n",
d1880 1
a1880 1
   _mesa_debug(NULL, "Mesa GL_EXTENSIONS = %s\n",
d1883 1
a1883 1
   _mesa_debug(NULL, "Mesa thread-safe: YES\n");
d1885 1
a1885 1
   _mesa_debug(NULL, "Mesa thread-safe: NO\n");
d1888 1
a1888 1
   _mesa_debug(NULL, "Mesa x86-optimized: YES\n");
d1890 1
a1890 1
   _mesa_debug(NULL, "Mesa x86-optimized: NO\n");
d1893 1
a1893 1
   _mesa_debug(NULL, "Mesa sparc-optimized: YES\n");
d1895 1
a1895 1
   _mesa_debug(NULL, "Mesa sparc-optimized: NO\n");
a1900 10
 * Set the current context, binding the given frame buffer to the context.
 */
void
_mesa_make_current( GLcontext *newCtx, GLframebuffer *buffer )
{
   _mesa_make_current2( newCtx, buffer, buffer );
}


/*
d1909 1
a1909 1
      _mesa_debug(newCtx, "_mesa_make_current2()\n");
a1979 1
      /* This is only for T&L - a bit out of place, or misnamed (BP) */
d1989 1
a1989 1
	 if (_mesa_getenv("MESA_INFO")) {
d2011 13
d2043 52
a2094 2
 * Record the given error code and call the driver's Error function if defined.
 * This is called via _mesa_error().
d2097 1
a2097 1
_mesa_record_error( GLcontext *ctx, GLenum error )
d2099 49
d2160 1
@


