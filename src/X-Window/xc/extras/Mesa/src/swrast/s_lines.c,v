head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.2
	cvs-200410241530:1.1.1.2
	cvs-200410012000:1.1.1.2
	cvs-200407141120:1.1.1.2
	cvs-200406231010:1.1.1.2
	MIRBSD_7quater:1.1.1.1
	cvs-200405271510:1.1.1.2
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.2
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.4
	MIRBSD_7:1.1.1.1.0.2
	MIRBSD_7ter:1.1.1.1
	cvs-20011091815:1.1.1.1
	cvs-200309162130:1.1.1.1
	cvs-200308302005:1.1.1.1
	ctmx-0387:1.1.1.1
	ctmx-0384:1.1.1.1
	MIRBSD_5:1.1.1.1
	ctmx-0375:1.1.1.1
	ctmx-0373:1.1.1.1
	ctm-0371:1.1.1.1
	ctm-0370:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-0363:1.1.1.1
	ctm-0359:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.28.44;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.04.08.18.20.15;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.04.08.18.20.15;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.03.02.17.30.02;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.05.10;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@
/*
 * Mesa 3-D graphics library
 * Version:  3.5
 *
 * Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


#include "glheader.h"
#include "colormac.h"
#include "macros.h"
#include "mmath.h"
#include "s_aaline.h"
#include "s_pb.h"
#include "s_context.h"
#include "s_depth.h"
#include "s_lines.h"
#include "s_feedback.h"



/**********************************************************************/
/*****                    Rasterization                           *****/
/**********************************************************************/


/*
 * There are 4 pairs (RGBA, CI) of line drawing functions:
 *   1. simple:  width=1 and no special rasterization functions (fastest)
 *   2. flat:  width=1, non-stippled, flat-shaded, any raster operations
 *   3. smooth:  width=1, non-stippled, smooth-shaded, any raster operations
 *   4. general:  any other kind of line (slowest)
 */


/* Flat, color index line */
static void flat_ci_line( GLcontext *ctx,
                          const SWvertex *vert0,
			  const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;

   PB_SET_INDEX( PB, vert0->index );

#define INTERP_XY 1
#define PLOT(X,Y)  PB_WRITE_PIXEL(PB, X, Y, 0, 0);

#include "s_linetemp.h"

   _mesa_flush_pb(ctx);
}



/* Flat, color index line with Z interpolation/testing */
static void flat_ci_z_line( GLcontext *ctx,
                            const SWvertex *vert0,
			    const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   PB_SET_INDEX( PB, vert0->index );

#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define PLOT(X,Y)  PB_WRITE_PIXEL(PB, X, Y, Z, fog0);

#include "s_linetemp.h"

   _mesa_flush_pb(ctx);
}



/* Flat-shaded, RGBA line */
static void flat_rgba_line( GLcontext *ctx,
                            const SWvertex *vert0,
			    const SWvertex *vert1 )
{
   const GLchan *color = vert1->color;
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   PB_SET_COLOR( PB, color[0], color[1], color[2], color[3] );

#define INTERP_XY 1
#define PLOT(X,Y)   PB_WRITE_PIXEL(PB, X, Y, 0, 0);

#include "s_linetemp.h"

   _mesa_flush_pb(ctx);
}



/* Flat-shaded, RGBA line with Z interpolation/testing */
static void flat_rgba_z_line( GLcontext *ctx,
                              const SWvertex *vert0,
			      const SWvertex *vert1 )
{
   const GLchan *color = vert1->color;
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   PB_SET_COLOR( PB, color[0], color[1], color[2], color[3] );

#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define PLOT(X,Y)   PB_WRITE_PIXEL(PB, X, Y, Z, fog0);

#include "s_linetemp.h"

   _mesa_flush_pb(ctx);
}



/* Smooth shaded, color index line */
static void smooth_ci_line( GLcontext *ctx,
                            const SWvertex *vert0,
			    const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   GLint count = PB->count;
   GLint *pbx = PB->x;
   GLint *pby = PB->y;
   GLuint *pbi = PB->index;

   PB->mono = GL_FALSE;

#define INTERP_XY 1
#define INTERP_INDEX 1

#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	pbi[count] = I;		\
	count++;

#include "s_linetemp.h"

   PB->count = count;
   _mesa_flush_pb(ctx);
}



/* Smooth shaded, color index line with Z interpolation/testing */
static void smooth_ci_z_line( GLcontext *ctx,
                              const SWvertex *vert0,
			      const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   GLint count = PB->count;
   GLint *pbx = PB->x;
   GLint *pby = PB->y;
   GLdepth *pbz = PB->z;
   GLuint *pbi = PB->index;

   PB->mono = GL_FALSE;

#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_INDEX 1

#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	pbz[count] = Z;		\
	pbi[count] = I;		\
	count++;

#include "s_linetemp.h"

   PB->count = count;
   _mesa_flush_pb(ctx);
}



/* Smooth-shaded, RGBA line */
static void smooth_rgba_line( GLcontext *ctx,
                       	      const SWvertex *vert0,
			      const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   GLint count = PB->count;
   GLint *pbx = PB->x;
   GLint *pby = PB->y;
   GLchan (*pbrgba)[4] = PB->rgba;

   PB->mono = GL_FALSE;

#define INTERP_XY 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1

#define PLOT(X,Y)			\
	pbx[count] = X;			\
	pby[count] = Y;			\
	pbrgba[count][RCOMP] = FixedToInt(r0);	\
	pbrgba[count][GCOMP] = FixedToInt(g0);	\
	pbrgba[count][BCOMP] = FixedToInt(b0);	\
	pbrgba[count][ACOMP] = FixedToInt(a0);	\
	count++;

#include "s_linetemp.h"

   PB->count = count;
   _mesa_flush_pb(ctx);
}



/* Smooth-shaded, RGBA line with Z interpolation/testing */
static void smooth_rgba_z_line( GLcontext *ctx,
                       	        const SWvertex *vert0,
				const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   GLint count = PB->count;
   GLint *pbx = PB->x;
   GLint *pby = PB->y;
   GLdepth *pbz = PB->z;
   GLfloat *pbfog = PB->fog;
   GLchan (*pbrgba)[4] = PB->rgba;


   PB->mono = GL_FALSE;

#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1

#define PLOT(X,Y)				\
	pbx[count] = X;				\
	pby[count] = Y;				\
	pbz[count] = Z;				\
	pbfog[count] = fog0;			\
	pbrgba[count][RCOMP] = FixedToInt(r0);	\
	pbrgba[count][GCOMP] = FixedToInt(g0);	\
	pbrgba[count][BCOMP] = FixedToInt(b0);	\
	pbrgba[count][ACOMP] = FixedToInt(a0);	\
	count++;

#include "s_linetemp.h"

   PB->count = count;
   _mesa_flush_pb(ctx);
}


#define CHECK_FULL(count)		\
   if (count >= PB_SIZE-MAX_WIDTH) {	\
      PB->count = count;		\
      _mesa_flush_pb(ctx);			\
      count = PB->count;		\
   }



/* Smooth shaded, color index, any width, maybe stippled */
static void general_smooth_ci_line( GLcontext *ctx,
                           	    const SWvertex *vert0,
				    const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   GLint count = PB->count;
   GLint *pbx = PB->x;
   GLint *pby = PB->y;
   GLdepth *pbz = PB->z;
   GLfloat *pbfog = PB->fog;
   GLuint *pbi = PB->index;

   PB->mono = GL_FALSE;

   if (ctx->Line.StippleFlag) {
      /* stippled */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_INDEX 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	pbz[count] = Z;		\
	pbfog[count] = fog0;	\
	pbi[count] = I;		\
	count++;		\
	CHECK_FULL(count);
#include "s_linetemp.h"
   }
   else {
      /* unstippled */
      if (ctx->Line.Width==2.0F) {
         /* special case: unstippled and width=2 */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_INDEX 1
#define XMAJOR_PLOT(X,Y)				\
	pbx[count] = X;  pbx[count+1] = X;		\
	pby[count] = Y;  pby[count+1] = Y+1;		\
	pbz[count] = Z;  pbz[count+1] = Z;		\
	pbfog[count] = fog0;  pbfog[count+1] = fog0;	\
	pbi[count] = I;  pbi[count+1] = I;		\
	count += 2;					\
	CHECK_FULL(count);
#define YMAJOR_PLOT(X,Y)				\
	pbx[count] = X;  pbx[count+1] = X+1;		\
	pby[count] = Y;  pby[count+1] = Y;		\
	pbz[count] = Z;  pbz[count+1] = Z;		\
	pbfog[count] = fog0;  pbfog[count+1] = fog0;	\
	pbi[count] = I;  pbi[count+1] = I;		\
	count += 2;					\
	CHECK_FULL(count);
#include "s_linetemp.h"
      }
      else {
         /* unstippled, any width */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_INDEX 1
#define WIDE 1
#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	pbz[count] = Z;		\
	pbi[count] = I;		\
	pbfog[count] = fog0;	\
	count++;		\
	CHECK_FULL(count);
#include "s_linetemp.h"
      }
   }

   PB->count = count;
   _mesa_flush_pb(ctx);
}


/* Flat shaded, color index, any width, maybe stippled */
static void general_flat_ci_line( GLcontext *ctx,
                                  const SWvertex *vert0,
				  const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   GLint count;
   GLint *pbx = PB->x;
   GLint *pby = PB->y;
   GLdepth *pbz = PB->z;
   GLfloat *pbfog = PB->fog;
   PB_SET_INDEX( PB, vert0->index );
   count = PB->count;

   if (ctx->Line.StippleFlag) {
      /* stippled, any width */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	pbz[count] = Z;		\
	pbfog[count] = fog0;	\
	count++;		\
	CHECK_FULL(count);
#include "s_linetemp.h"
   }
   else {
      /* unstippled */
      if (ctx->Line.Width==2.0F) {
         /* special case: unstippled and width=2 */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define XMAJOR_PLOT(X,Y)				\
	pbx[count] = X;  pbx[count+1] = X;		\
	pby[count] = Y;  pby[count+1] = Y+1;		\
	pbz[count] = Z;  pbz[count+1] = Z;		\
	pbfog[count] = fog0;  pbfog[count+1] = fog0;	\
	count += 2;					\
	CHECK_FULL(count);
#define YMAJOR_PLOT(X,Y)				\
	pbx[count] = X;  pbx[count+1] = X+1;		\
	pby[count] = Y;  pby[count+1] = Y;		\
	pbz[count] = Z;  pbz[count+1] = Z;		\
	pbfog[count] = fog0;  pbfog[count+1] = fog0;	\
	count += 2;					\
	CHECK_FULL(count);
#include "s_linetemp.h"
      }
      else {
         /* unstippled, any width */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define WIDE 1
#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	pbz[count] = Z;		\
	pbfog[count] = fog0;	\
	count++;		\
	CHECK_FULL(count);
#include "s_linetemp.h"
      }
   }

   PB->count = count;
   _mesa_flush_pb(ctx);
}



static void general_smooth_rgba_line( GLcontext *ctx,
                                      const SWvertex *vert0,
				      const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   GLint count = PB->count;
   GLint *pbx = PB->x;
   GLint *pby = PB->y;
   GLdepth *pbz = PB->z;
   GLfloat *pbfog = PB->fog;
   GLchan (*pbrgba)[4] = PB->rgba;

   PB->mono = GL_FALSE;

   if (ctx->Line.StippleFlag) {
      /* stippled */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)				\
	pbx[count] = X;				\
	pby[count] = Y;				\
	pbz[count] = Z;				\
	pbfog[count] = fog0;			\
	pbrgba[count][RCOMP] = FixedToInt(r0);	\
	pbrgba[count][GCOMP] = FixedToInt(g0);	\
	pbrgba[count][BCOMP] = FixedToInt(b0);	\
	pbrgba[count][ACOMP] = FixedToInt(a0);	\
	count++;				\
	CHECK_FULL(count);
#include "s_linetemp.h"
   }
   else {
      /* unstippled */
      if (ctx->Line.Width==2.0F) {
         /* special case: unstippled and width=2 */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define XMAJOR_PLOT(X,Y)				\
	pbx[count] = X;  pbx[count+1] = X;		\
	pby[count] = Y;  pby[count+1] = Y+1;		\
	pbz[count] = Z;  pbz[count+1] = Z;		\
	pbfog[count] = fog0;  pbfog[count+1] = fog0;	\
	pbrgba[count][RCOMP] = FixedToInt(r0);		\
	pbrgba[count][GCOMP] = FixedToInt(g0);		\
	pbrgba[count][BCOMP] = FixedToInt(b0);		\
	pbrgba[count][ACOMP] = FixedToInt(a0);		\
	pbrgba[count+1][RCOMP] = FixedToInt(r0);	\
	pbrgba[count+1][GCOMP] = FixedToInt(g0);	\
	pbrgba[count+1][BCOMP] = FixedToInt(b0);	\
	pbrgba[count+1][ACOMP] = FixedToInt(a0);	\
	count += 2;					\
	CHECK_FULL(count);
#define YMAJOR_PLOT(X,Y)				\
	pbx[count] = X;  pbx[count+1] = X+1;		\
	pby[count] = Y;  pby[count+1] = Y;		\
	pbz[count] = Z;  pbz[count+1] = Z;		\
	pbfog[count] = fog0;  pbfog[count+1] = fog0;	\
	pbrgba[count][RCOMP] = FixedToInt(r0);		\
	pbrgba[count][GCOMP] = FixedToInt(g0);		\
	pbrgba[count][BCOMP] = FixedToInt(b0);		\
	pbrgba[count][ACOMP] = FixedToInt(a0);		\
	pbrgba[count+1][RCOMP] = FixedToInt(r0);	\
	pbrgba[count+1][GCOMP] = FixedToInt(g0);	\
	pbrgba[count+1][BCOMP] = FixedToInt(b0);	\
	pbrgba[count+1][ACOMP] = FixedToInt(a0);	\
	count += 2;					\
	CHECK_FULL(count);
#include "s_linetemp.h"
      }
      else {
         /* unstippled, any width */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define WIDE 1
#define PLOT(X,Y)				\
	pbx[count] = X;				\
	pby[count] = Y;				\
	pbz[count] = Z;				\
	pbfog[count] = fog0;  			\
	pbrgba[count][RCOMP] = FixedToInt(r0);	\
	pbrgba[count][GCOMP] = FixedToInt(g0);	\
	pbrgba[count][BCOMP] = FixedToInt(b0);	\
	pbrgba[count][ACOMP] = FixedToInt(a0);	\
	count++;				\
	CHECK_FULL(count);
#include "s_linetemp.h"
      }
   }

   PB->count = count;
   _mesa_flush_pb(ctx);
}


static void general_flat_rgba_line( GLcontext *ctx,
                                    const SWvertex *vert0,
				    const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   const GLchan *color = vert1->color;
   GLuint count;
   PB_SET_COLOR( PB, color[0], color[1], color[2], color[3] );

   if (ctx->Line.StippleFlag) {
      /* stippled */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)                       \
    PB_WRITE_PIXEL(PB, X, Y, Z, fog0);  \
    count = PB->count;                  \
    CHECK_FULL(count);
#include "s_linetemp.h"
   }
   else {
      /* unstippled */
      if (ctx->Line.Width==2.0F) {
         /* special case: unstippled and width=2 */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define XMAJOR_PLOT(X,Y) PB_WRITE_PIXEL(PB, X, Y, Z, fog0); \
                         PB_WRITE_PIXEL(PB, X, Y+1, Z, fog0);
#define YMAJOR_PLOT(X,Y)  PB_WRITE_PIXEL(PB, X, Y, Z, fog0); \
                          PB_WRITE_PIXEL(PB, X+1, Y, Z, fog0);
#include "s_linetemp.h"
      }
      else {
         /* unstippled, any width */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define WIDE 1
#define PLOT(X,Y)                       \
    PB_WRITE_PIXEL(PB, X, Y, Z, fog0);  \
    count = PB->count;                  \
    CHECK_FULL(count);
#include "s_linetemp.h"
      }
   }

   _mesa_flush_pb(ctx);
}


/* Flat-shaded, textured, any width, maybe stippled */
static void flat_textured_line( GLcontext *ctx,
                                const SWvertex *vert0,
				const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   GLint count;
   GLint *pbx = PB->x;
   GLint *pby = PB->y;
   GLdepth *pbz = PB->z;
   GLfloat *pbfog = PB->fog;
   GLfloat *pbs = PB->s[0];
   GLfloat *pbt = PB->t[0];
   GLfloat *pbu = PB->u[0];
   GLchan *color = (GLchan*) vert1->color;
   PB_SET_COLOR( PB, color[0], color[1], color[2], color[3] );
   count = PB->count;

   if (ctx->Line.StippleFlag) {
      /* stippled */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_TEX 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)			\
	{				\
	   pbx[count] = X;		\
	   pby[count] = Y;		\
	   pbz[count] = Z;		\
 	   pbfog[count] = fog0;		\
	   pbs[count] = fragTexcoord[0];\
	   pbt[count] = fragTexcoord[1];\
	   pbu[count] = fragTexcoord[2];\
	   count++;			\
	   CHECK_FULL(count);		\
	}
#include "s_linetemp.h"
   }
   else {
      /* unstippled */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_TEX 1
#define WIDE 1
#define PLOT(X,Y)			\
	{				\
	   pbx[count] = X;		\
	   pby[count] = Y;		\
	   pbz[count] = Z;		\
 	   pbfog[count] = fog0;		\
	   pbs[count] = fragTexcoord[0];\
	   pbt[count] = fragTexcoord[1];\
	   pbu[count] = fragTexcoord[2];\
	   count++;			\
	   CHECK_FULL(count);		\
	}
#include "s_linetemp.h"
   }

   PB->count = count;
   _mesa_flush_pb(ctx);
}



/* Smooth-shaded, textured, any width, maybe stippled */
static void smooth_textured_line( GLcontext *ctx,
                                  const SWvertex *vert0,
				  const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   GLint count = PB->count;
   GLint *pbx = PB->x;
   GLint *pby = PB->y;
   GLdepth *pbz = PB->z;
   GLfloat *pbfog = PB->fog;
   GLfloat *pbs = PB->s[0];
   GLfloat *pbt = PB->t[0];
   GLfloat *pbu = PB->u[0];
   GLchan (*pbrgba)[4] = PB->rgba;

   PB->mono = GL_FALSE;

   if (ctx->Line.StippleFlag) {
      /* stippled */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define INTERP_TEX 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)					\
	{						\
	   pbx[count] = X;				\
	   pby[count] = Y;				\
	   pbz[count] = Z;				\
 	   pbfog[count] = fog0;				\
	   pbs[count] = fragTexcoord[0];		\
	   pbt[count] = fragTexcoord[1];		\
	   pbu[count] = fragTexcoord[2];		\
	   pbrgba[count][RCOMP] = FixedToInt(r0);	\
	   pbrgba[count][GCOMP] = FixedToInt(g0);	\
	   pbrgba[count][BCOMP] = FixedToInt(b0);	\
	   pbrgba[count][ACOMP] = FixedToInt(a0);	\
	   count++;					\
	   CHECK_FULL(count);				\
	}
#include "s_linetemp.h"
   }
   else {
      /* unstippled */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define INTERP_TEX 1
#define WIDE 1
#define PLOT(X,Y)					\
	{						\
	   pbx[count] = X;				\
	   pby[count] = Y;				\
	   pbz[count] = Z;				\
 	   pbfog[count] = fog0;				\
	   pbs[count] = fragTexcoord[0];		\
	   pbt[count] = fragTexcoord[1];		\
	   pbu[count] = fragTexcoord[2];		\
	   pbrgba[count][RCOMP] = FixedToInt(r0);	\
	   pbrgba[count][GCOMP] = FixedToInt(g0);	\
	   pbrgba[count][BCOMP] = FixedToInt(b0);	\
	   pbrgba[count][ACOMP] = FixedToInt(a0);	\
	   count++;					\
	   CHECK_FULL(count);				\
	}
#include "s_linetemp.h"
   }

   PB->count = count;
   _mesa_flush_pb(ctx);
}


/* Smooth-shaded, multitextured, any width, maybe stippled, separate specular
 * color interpolation.
 */
static void smooth_multitextured_line( GLcontext *ctx,
				       const SWvertex *vert0,
				       const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   GLint count = PB->count;
   GLint *pbx = PB->x;
   GLint *pby = PB->y;
   GLdepth *pbz = PB->z;
   GLfloat *pbfog = PB->fog;
   GLchan (*pbrgba)[4] = PB->rgba;
   GLchan (*pbspec)[3] = PB->spec;

   PB->mono = GL_FALSE;
   PB->haveSpec = GL_TRUE;

   if (ctx->Line.StippleFlag) {
      /* stippled */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_RGB 1
#define INTERP_SPEC 1
#define INTERP_ALPHA 1
#define INTERP_MULTITEX 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)						\
	{							\
	   GLuint u;						\
	   pbx[count] = X;					\
	   pby[count] = Y;					\
	   pbz[count] = Z;					\
 	   pbfog[count] = fog0;					\
	   pbrgba[count][RCOMP] = FixedToInt(r0);		\
	   pbrgba[count][GCOMP] = FixedToInt(g0);		\
	   pbrgba[count][BCOMP] = FixedToInt(b0);		\
	   pbrgba[count][ACOMP] = FixedToInt(a0);		\
	   pbspec[count][RCOMP] = FixedToInt(sr0);		\
	   pbspec[count][GCOMP] = FixedToInt(sg0);		\
	   pbspec[count][BCOMP] = FixedToInt(sb0);		\
	   for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {	\
	      if (ctx->Texture.Unit[u]._ReallyEnabled) {	\
	         PB->s[u][count] = fragTexcoord[u][0];		\
	         PB->t[u][count] = fragTexcoord[u][1];		\
	         PB->u[u][count] = fragTexcoord[u][2];		\
	      }							\
	   }							\
	   count++;						\
	   CHECK_FULL(count);					\
	}
#include "s_linetemp.h"
   }
   else {
      /* unstippled */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_RGB 1
#define INTERP_SPEC 1
#define INTERP_ALPHA 1
#define INTERP_MULTITEX 1
#define WIDE 1
#define PLOT(X,Y)						\
	{							\
	   GLuint u;						\
	   pbx[count] = X;					\
	   pby[count] = Y;					\
	   pbz[count] = Z;					\
 	   pbfog[count] = fog0;					\
	   pbrgba[count][RCOMP] = FixedToInt(r0);		\
	   pbrgba[count][GCOMP] = FixedToInt(g0);		\
	   pbrgba[count][BCOMP] = FixedToInt(b0);		\
	   pbrgba[count][ACOMP] = FixedToInt(a0);		\
	   pbspec[count][RCOMP] = FixedToInt(sr0);		\
	   pbspec[count][GCOMP] = FixedToInt(sg0);		\
	   pbspec[count][BCOMP] = FixedToInt(sb0);		\
	   for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {	\
	      if (ctx->Texture.Unit[u]._ReallyEnabled) {	\
	         PB->s[u][count] = fragTexcoord[u][0];		\
	         PB->t[u][count] = fragTexcoord[u][1];		\
	         PB->u[u][count] = fragTexcoord[u][2];		\
	      }							\
	   }							\
	   count++;						\
	   CHECK_FULL(count);					\
	}
#include "s_linetemp.h"
   }

   PB->count = count;
   _mesa_flush_pb(ctx);
}


/* Flat-shaded, multitextured, any width, maybe stippled, separate specular
 * color interpolation.
 */
static void flat_multitextured_line( GLcontext *ctx,
                                     const SWvertex *vert0,
				     const SWvertex *vert1 )
{
   struct pixel_buffer *PB = SWRAST_CONTEXT(ctx)->PB;
   GLint count = PB->count;
   GLint *pbx = PB->x;
   GLint *pby = PB->y;
   GLdepth *pbz = PB->z;
   GLfloat *pbfog = PB->fog;
   GLchan (*pbrgba)[4] = PB->rgba;
   GLchan (*pbspec)[3] = PB->spec;
   GLchan *color = (GLchan*) vert1->color;
   GLchan sRed   = vert1->specular[0];
   GLchan sGreen = vert1->specular[1];
   GLchan sBlue  = vert1->specular[2];

   PB->mono = GL_FALSE;
   PB->haveSpec = GL_TRUE;

   if (ctx->Line.StippleFlag) {
      /* stippled */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_ALPHA 1
#define INTERP_MULTITEX 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)						\
	{							\
	   GLuint u;						\
	   pbx[count] = X;					\
	   pby[count] = Y;					\
	   pbz[count] = Z;					\
 	   pbfog[count] = fog0;					\
	   pbrgba[count][RCOMP] = color[0];			\
	   pbrgba[count][GCOMP] = color[1];			\
	   pbrgba[count][BCOMP] = color[2];			\
	   pbrgba[count][ACOMP] = color[3];			\
	   pbspec[count][RCOMP] = sRed;				\
	   pbspec[count][GCOMP] = sGreen;			\
	   pbspec[count][BCOMP] = sBlue;			\
	   for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {	\
	      if (ctx->Texture.Unit[u]._ReallyEnabled) {	\
	         PB->s[u][count] = fragTexcoord[u][0];		\
	         PB->t[u][count] = fragTexcoord[u][1];		\
	         PB->u[u][count] = fragTexcoord[u][2];		\
	      }							\
	   }							\
	   count++;						\
	   CHECK_FULL(count);					\
	}
#include "s_linetemp.h"
   }
   else {
      /* unstippled */
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_FOG 1
#define INTERP_ALPHA 1
#define INTERP_MULTITEX 1
#define WIDE 1
#define PLOT(X,Y)						\
	{							\
	   GLuint u;						\
	   pbx[count] = X;					\
	   pby[count] = Y;					\
	   pbz[count] = Z;					\
 	   pbfog[count] = fog0;					\
	   pbrgba[count][RCOMP] = color[0];			\
	   pbrgba[count][GCOMP] = color[1];			\
	   pbrgba[count][BCOMP] = color[2];			\
	   pbrgba[count][ACOMP] = color[3];			\
	   pbspec[count][RCOMP] = sRed;				\
	   pbspec[count][GCOMP] = sGreen;			\
	   pbspec[count][BCOMP] = sBlue;			\
	   for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {	\
	      if (ctx->Texture.Unit[u]._ReallyEnabled) {	\
	         PB->s[u][count] = fragTexcoord[u][0];		\
	         PB->t[u][count] = fragTexcoord[u][1];		\
	         PB->u[u][count] = fragTexcoord[u][2];		\
	      }							\
	   }							\
	   count++;						\
	   CHECK_FULL(count);					\
	}
#include "s_linetemp.h"
   }

   PB->count = count;
   _mesa_flush_pb(ctx);
}


void _swrast_add_spec_terms_line( GLcontext *ctx,
				  const SWvertex *v0,
				  const SWvertex *v1 )
{
   SWvertex *ncv0 = (SWvertex *)v0;
   SWvertex *ncv1 = (SWvertex *)v1;
   GLchan c[2][4];
   COPY_CHAN4( c[0], ncv0->color );
   COPY_CHAN4( c[1], ncv1->color );
   ACC_3V( ncv0->color, ncv0->specular );
   ACC_3V( ncv1->color, ncv1->specular );
   SWRAST_CONTEXT(ctx)->SpecLine( ctx, ncv0, ncv1 );
   COPY_CHAN4( ncv0->color, c[0] );
   COPY_CHAN4( ncv1->color, c[1] );
}


#ifdef DEBUG
extern void
_mesa_print_line_function(GLcontext *ctx);  /* silence compiler warning */
void
_mesa_print_line_function(GLcontext *ctx)
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   printf("Line Func == ");
   if (swrast->Line == flat_ci_line)
      printf("flat_ci_line\n");
   else if (swrast->Line == flat_ci_z_line)
      printf("flat_ci_z_line\n");
   else if (swrast->Line == flat_rgba_line)
      printf("flat_rgba_line\n");
   else if (swrast->Line == flat_rgba_z_line)
      printf("flat_rgba_z_line\n");
   else if (swrast->Line == smooth_ci_line)
      printf("smooth_ci_line\n");
   else if (swrast->Line == smooth_ci_z_line)
      printf("smooth_ci_z_line\n");
   else if (swrast->Line == smooth_rgba_line)
      printf("smooth_rgba_line\n");
   else if (swrast->Line == smooth_rgba_z_line)
      printf("smooth_rgba_z_line\n");
   else if (swrast->Line == general_smooth_ci_line)
      printf("general_smooth_ci_line\n");
   else if (swrast->Line == general_flat_ci_line)
      printf("general_flat_ci_line\n");
   else if (swrast->Line == general_smooth_rgba_line)
      printf("general_smooth_rgba_line\n");
   else if (swrast->Line == general_flat_rgba_line)
      printf("general_flat_rgba_line\n");
   else if (swrast->Line == flat_textured_line)
      printf("flat_textured_line\n");
   else if (swrast->Line == smooth_textured_line)
      printf("smooth_textured_line\n");
   else if (swrast->Line == smooth_multitextured_line)
      printf("smooth_multitextured_line\n");
   else if (swrast->Line == flat_multitextured_line)
      printf("flat_multitextured_line\n");
   else
      printf("Driver func %p\n", (void *) swrast->Line);
}
#endif



#ifdef DEBUG

/* record the current line function name */
static const char *lineFuncName = NULL;

#define USE(lineFunc)                   \
do {                                    \
    lineFuncName = #lineFunc;           \
    /*printf("%s\n", lineFuncName);*/   \
    swrast->Line = lineFunc;            \
} while (0)

#else

#define USE(lineFunc)  swrast->Line = lineFunc

#endif



/*
 * Determine which line drawing function to use given the current
 * rendering context.
 *
 * Please update the summary flag _SWRAST_NEW_LINE if you add or remove
 * tests to this code.
 */
void
_swrast_choose_line( GLcontext *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   const GLboolean rgbmode = ctx->Visual.rgbMode;

   if (ctx->RenderMode==GL_RENDER) {
      if (ctx->Line.SmoothFlag) {
         /* antialiased lines */
         _swrast_choose_aa_line_function(ctx);
         ASSERT(swrast->Triangle);
      }
      else if (ctx->Texture._ReallyEnabled) {
         if (ctx->Texture._ReallyEnabled > TEXTURE0_ANY ||	     
	     (ctx->_TriangleCaps & DD_SEPARATE_SPECULAR)) {
            /* multi-texture and/or separate specular color */
            if (ctx->Light.ShadeModel==GL_SMOOTH)
               USE(smooth_multitextured_line);
            else
               USE(flat_multitextured_line);
         }
         else {
            if (ctx->Light.ShadeModel==GL_SMOOTH) {
                USE(smooth_textured_line);
            }
            else {
                USE(flat_textured_line);
            }
         }
      }
      else if (ctx->Line.Width!=1.0 || ctx->Line.StippleFlag) {
         if (ctx->Light.ShadeModel==GL_SMOOTH) {
            if (rgbmode)
               USE(general_smooth_rgba_line);
            else
               USE(general_smooth_ci_line);
         }
         else {
            if (rgbmode)
               USE(general_flat_rgba_line);
            else
               USE(general_flat_ci_line);
         }
      }
      else {
	 if (ctx->Light.ShadeModel==GL_SMOOTH) {
	    /* Width==1, non-stippled, smooth-shaded */
            if (ctx->Depth.Test || ctx->Fog.Enabled) {
               if (rgbmode)
                  USE(smooth_rgba_z_line);
               else
                  USE(smooth_ci_z_line);
            }
            else {
               if (rgbmode)
                  USE(smooth_rgba_line);
               else
                  USE(smooth_ci_line);
            }
	 }
         else {
	    /* Width==1, non-stippled, flat-shaded */
            if (ctx->Depth.Test || ctx->Fog.Enabled) {
               if (rgbmode)
                  USE(flat_rgba_z_line);
               else
                  USE(flat_ci_z_line);
            }
            else {
               if (rgbmode)
                  USE(flat_rgba_line);
               else
                  USE(flat_ci_line);
            }
         }
      }
   }
   else if (ctx->RenderMode==GL_FEEDBACK) {
      USE(_mesa_feedback_line);
   }
   else {
      /* GL_SELECT mode */
      USE(_mesa_select_line);
   }

   /*_mesa_print_line_function(ctx);*/
}
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
d4 1
a4 1
 * Version:  5.0.2
d6 1
a6 1
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
d32 1
d35 1
a36 2
#include "s_lines.h"
#include "s_span.h"
a38 8
/*
 * Init the mask[] array to implement a line stipple.
 */
static void
compute_stipple_mask( GLcontext *ctx, GLuint len, GLubyte mask[] )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLuint i;
d40 3
a42 11
   for (i = 0; i < len; i++) {
      GLuint bit = (swrast->StippleCounter / ctx->Line.StippleFactor) & 0xf;
      if ((1 << bit) & ctx->Line.StipplePattern) {
         mask[i] = GL_TRUE;
      }
      else {
         mask[i] = GL_FALSE;
      }
      swrast->StippleCounter++;
   }
}
d46 5
a50 1
 * To draw a wide line we can simply redraw the span N times, side by side.
d52 6
a57 2
static void
draw_wide_line( GLcontext *ctx, struct sw_span *span, GLboolean xMajor )
d59 1
a59 6
   GLchan colors[MAX_WIDTH][4];
   GLint width, start;
   GLboolean mutable = (ctx->Color.BlendEnabled ||
                        ctx->Texture._EnabledUnits ||
                        ctx->Fog.Enabled ||
                        *((GLuint *) ctx->Color.ColorMask) != 0xffffffff);
d61 1
a61 1
   ASSERT(span->end < MAX_WIDTH);
d63 2
a64 1
   width = (GLint) CLAMP( ctx->Line.Width, MIN_LINE_WIDTH, MAX_LINE_WIDTH );
d66 1
a66 4
   if (width & 1)
      start = width / 2;
   else
      start = width / 2 - 1;
d68 1
a68 60
   if (mutable) {
      /* Backup colors because they'll get modified during span write.
       * This is a bit of hack.  The problem is properly fixed in Mesa 5.1.
       */
      _mesa_memcpy(colors, span->array->rgba, span->end * 4 * sizeof(GLchan));
   }

   if (xMajor) {
      GLint *y = span->array->y;
      GLuint i;
      GLint w;
      for (w = 0; w < width; w++) {
         if (w == 0) {
            for (i = 0; i < span->end; i++)
               y[i] -= start;
         }
         else {
            for (i = 0; i < span->end; i++)
               y[i]++;
         }
         if ((span->interpMask | span->arrayMask) & SPAN_TEXTURE)
            _mesa_write_texture_span(ctx, span);
         else if ((span->interpMask | span->arrayMask) & SPAN_RGBA)
            _mesa_write_rgba_span(ctx, span);
         else
            _mesa_write_index_span(ctx, span);

         if (w + 1 < width && mutable) {
            /* restore original colors */
            _mesa_memcpy(span->array->rgba, colors,
                         span->end * 4 * sizeof(GLchan));
         }
      }
   }
   else {
      GLint *x = span->array->x;
      GLuint i;
      GLint w;
      for (w = 0; w < width; w++) {
         if (w == 0) {
            for (i = 0; i < span->end; i++)
               x[i] -= start;
         }
         else {
            for (i = 0; i < span->end; i++)
               x[i]++;
         }
         if ((span->interpMask | span->arrayMask) & SPAN_TEXTURE)
            _mesa_write_texture_span(ctx, span);
         else if ((span->interpMask | span->arrayMask) & SPAN_RGBA)
            _mesa_write_rgba_span(ctx, span);
         else
            _mesa_write_index_span(ctx, span);
         if (w + 1 < width && mutable) {
            /* restore original colors */
            _mesa_memcpy(span->array->rgba, colors,
                         span->end * 4 * sizeof(GLchan));
         }
      }
   }
d73 4
a76 9
/**********************************************************************/
/*****                    Rasterization                           *****/
/**********************************************************************/


/* Flat, color index line */
static void flat_ci_line( GLcontext *ctx,
                          const SWvertex *vert0,
			  const SWvertex *vert1 )
d78 2
a79 12
   GLint *x, *y;
   struct sw_span span;

   ASSERT(ctx->Light.ShadeModel == GL_FLAT);
   ASSERT(!ctx->Line.StippleFlag);
   ASSERT(ctx->Line.Width == 1.0F);

   INIT_SPAN(span, GL_LINE, 0, SPAN_INDEX, SPAN_XY);
   span.index = IntToFixed(vert1->index);
   span.indexStep = 0;
   x = span.array->x;
   y = span.array->y;
d82 3
a84 6
#define PLOT(X,Y)		\
   {				\
      x[span.end] = X;		\
      y[span.end] = Y;		\
      span.end++;		\
   }
d88 1
a88 1
   _mesa_write_index_span(ctx, &span);
d92 1
d98 11
a108 2
   struct sw_span span;
   GLint *x, *y;
d110 10
a119 15
   ASSERT(ctx->Light.ShadeModel == GL_FLAT);
   ASSERT(!ctx->Line.StippleFlag);
   ASSERT(ctx->Line.Width == 1.0F);

   INIT_SPAN(span, GL_LINE, 0, SPAN_RGBA, SPAN_XY);
   span.red = ChanToFixed(vert1->color[0]);
   span.green = ChanToFixed(vert1->color[1]);
   span.blue = ChanToFixed(vert1->color[2]);
   span.alpha = ChanToFixed(vert1->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;
   x = span.array->x;
   y = span.array->y;
d122 3
a124 6
#define PLOT(X,Y)		\
   {				\
      x[span.end] = X;		\
      y[span.end] = Y;		\
      span.end++;		\
   }
d128 1
a128 1
   _mesa_write_rgba_span(ctx, &span);
d132 1
d138 38
a175 12
   struct sw_span span;
   GLint *x, *y;
   GLuint *index;

   ASSERT(ctx->Light.ShadeModel == GL_SMOOTH);
   ASSERT(!ctx->Line.StippleFlag);
   ASSERT(ctx->Line.Width == 1.0F);

   INIT_SPAN(span, GL_LINE, 0, 0, SPAN_XY | SPAN_INDEX);
   x = span.array->x;
   y = span.array->y;
   index = span.array->index;
d178 2
d181 1
d183 5
a187 6
   {				\
      x[span.end] = X;		\
      y[span.end] = Y;		\
      index[span.end] = I;	\
      span.end++;		\
   }
d191 2
a192 1
   _mesa_write_index_span(ctx, &span);
d196 1
d202 44
a245 12
   struct sw_span span;
   GLint *x, *y;
   GLchan (*rgba)[4];

   ASSERT(ctx->Light.ShadeModel == GL_SMOOTH);
   ASSERT(!ctx->Line.StippleFlag);
   ASSERT(ctx->Line.Width == 1.0F);

   INIT_SPAN(span, GL_LINE, 0, 0, SPAN_XY | SPAN_RGBA);
   x = span.array->x;
   y = span.array->y;
   rgba = span.array->rgba;
d248 2
d252 1
d254 9
a262 9
   {						\
      x[span.end] = X;				\
      y[span.end] = Y;				\
      rgba[span.end][RCOMP] = FixedToInt(r0);	\
      rgba[span.end][GCOMP] = FixedToInt(g0);	\
      rgba[span.end][BCOMP] = FixedToInt(b0);	\
      rgba[span.end][ACOMP] = FixedToInt(a0);	\
      span.end++;				\
   }
d266 2
a267 1
   _mesa_write_rgba_span(ctx, &span);
d271 9
d285 7
a291 16
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
   GLint *x, *y;
   GLdepth *z;
   GLfloat *fog;
   GLuint *index;

   ASSERT(ctx->Light.ShadeModel == GL_SMOOTH);

   INIT_SPAN(span, GL_LINE, 0, 0,
	     SPAN_XY | SPAN_Z | SPAN_FOG | SPAN_INDEX);
   x = span.array->x;
   y = span.array->y;
   z = span.array->z;
   fog = span.array->fog;
   index = span.array->index;
d293 4
a296 1
#define SET_XMAJOR 1
d301 2
d304 8
a311 7
   {				\
      x[span.end] = X;		\
      y[span.end] = Y;		\
      z[span.end] = Z;		\
      fog[span.end] = fog0;	\
      index[span.end] = I;	\
      span.end++;		\
d313 24
d338 18
a355 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d358 2
a359 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_index_span(ctx, &span);
   }
d368 8
a375 16
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
   GLint *x, *y;
   GLdepth *z;
   GLfloat *fog;

   ASSERT(ctx->Light.ShadeModel == GL_FLAT);

   INIT_SPAN(span, GL_LINE, 0, SPAN_INDEX,
	     SPAN_XY | SPAN_Z | SPAN_FOG);
   span.index = IntToFixed(vert1->index);
   span.indexStep = 0;
   x = span.array->x;
   y = span.array->y;
   z = span.array->z;
   fog = span.array->fog;
d377 2
a378 1
#define SET_XMAJOR 1
d382 2
d385 7
a391 6
   {				\
      x[span.end] = X;		\
      y[span.end] = Y;		\
      z[span.end] = Z;		\
      fog[span.end] = fog0;	\
      span.end++;		\
d393 21
d415 16
a430 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d433 2
a434 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_index_span(ctx, &span);
   }
d443 7
a449 16
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
   GLint *x, *y;
   GLdepth *z;
   GLchan (*rgba)[4];
   GLfloat *fog;

   ASSERT(ctx->Light.ShadeModel == GL_SMOOTH);

   INIT_SPAN(span, GL_LINE, 0, 0,
	     SPAN_XY | SPAN_Z | SPAN_FOG | SPAN_RGBA);
   x = span.array->x;
   y = span.array->y;
   z = span.array->z;
   rgba = span.array->rgba;
   fog = span.array->fog;
d451 4
a454 1
#define SET_XMAJOR 1
d460 2
d463 11
a473 10
   {						\
      x[span.end] = X;				\
      y[span.end] = Y;				\
      z[span.end] = Z;				\
      rgba[span.end][RCOMP] = FixedToInt(r0);	\
      rgba[span.end][GCOMP] = FixedToInt(g0);	\
      rgba[span.end][BCOMP] = FixedToInt(b0);	\
      rgba[span.end][ACOMP] = FixedToInt(a0);	\
      fog[span.end] = fog0;			\
      span.end++;				\
d475 60
d536 1
a536 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d539 2
a540 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_rgba_span(ctx, &span);
   }
d548 4
a551 22
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
   GLint *x, *y;
   GLdepth *z;
   GLfloat *fog;

   ASSERT(ctx->Light.ShadeModel == GL_FLAT);

   INIT_SPAN(span, GL_LINE, 0, SPAN_RGBA,
	     SPAN_XY | SPAN_Z | SPAN_FOG);
   span.red = ChanToFixed(vert1->color[0]);
   span.green = ChanToFixed(vert1->color[1]);
   span.blue = ChanToFixed(vert1->color[2]);
   span.alpha = ChanToFixed(vert1->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;
   x = span.array->x;
   y = span.array->y;
   z = span.array->z;
   fog = span.array->fog;
d553 2
a554 1
#define SET_XMAJOR 1
d558 7
a564 7
#define PLOT(X,Y)		\
   {				\
      x[span.end] = X;		\
      y[span.end] = Y;		\
      z[span.end] = Z;		\
      fog[span.end] = fog0;	\
      span.end++;		\
d566 11
d578 13
a590 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d593 1
a593 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_rgba_span(ctx, &span);
   }
d602 12
a613 2
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
d615 2
a616 20
   ASSERT(ctx->Light.ShadeModel == GL_FLAT);

   INIT_SPAN(span, GL_LINE, 0, SPAN_RGBA | SPAN_SPEC,
	     SPAN_XY | SPAN_Z | SPAN_FOG | SPAN_TEXTURE | SPAN_LAMBDA);
   span.red = ChanToFixed(vert1->color[0]);
   span.green = ChanToFixed(vert1->color[1]);
   span.blue = ChanToFixed(vert1->color[2]);
   span.alpha = ChanToFixed(vert1->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;
   span.specRed = ChanToFixed(vert1->specular[0]);
   span.specGreen = ChanToFixed(vert1->specular[1]);
   span.specBlue = ChanToFixed(vert1->specular[2]);
   span.specRedStep = 0;
   span.specGreenStep = 0;
   span.specBlueStep = 0;

#define SET_XMAJOR 1
d621 15
a635 11
#define PLOT(X,Y)						\
   {								\
      span.array->x[span.end] = X;				\
      span.array->y[span.end] = Y;				\
      span.array->z[span.end] = Z;				\
      span.array->fog[span.end] = fog0;				\
      span.array->texcoords[0][span.end][0] = fragTexcoord[0];	\
      span.array->texcoords[0][span.end][1] = fragTexcoord[1];	\
      span.array->texcoords[0][span.end][2] = fragTexcoord[2];	\
      span.array->lambda[0][span.end] = 0.0;			\
      span.end++;						\
d637 19
a656 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d659 2
a660 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_texture_span(ctx, &span);
   }
d670 10
a679 2
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
d681 1
a681 1
   ASSERT(ctx->Light.ShadeModel == GL_SMOOTH);
d683 2
a684 4
   INIT_SPAN(span, GL_LINE, 0, 0,
	     SPAN_XY | SPAN_Z | SPAN_FOG | SPAN_RGBA | SPAN_TEXTURE | SPAN_LAMBDA);

#define SET_XMAJOR 1
d691 19
a709 15
#define PLOT(X,Y)						\
   {								\
      span.array->x[span.end] = X;				\
      span.array->y[span.end] = Y;				\
      span.array->z[span.end] = Z;				\
      span.array->fog[span.end] = fog0;				\
      span.array->rgba[span.end][RCOMP] = FixedToInt(r0);	\
      span.array->rgba[span.end][GCOMP] = FixedToInt(g0);	\
      span.array->rgba[span.end][BCOMP] = FixedToInt(b0);	\
      span.array->rgba[span.end][ACOMP] = FixedToInt(a0);	\
      span.array->texcoords[0][span.end][0] = fragTexcoord[0];	\
      span.array->texcoords[0][span.end][1] = fragTexcoord[1];	\
      span.array->texcoords[0][span.end][2] = fragTexcoord[2];	\
      span.array->lambda[0][span.end] = 0.0;			\
      span.end++;						\
d711 25
a736 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d739 2
a740 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_texture_span(ctx, &span);
   }
d751 8
a758 3
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
   GLuint u;
d760 2
a761 1
   ASSERT(ctx->Light.ShadeModel == GL_SMOOTH);
d763 2
a764 4
   INIT_SPAN(span, GL_LINE, 0, 0,
	     SPAN_XY | SPAN_Z | SPAN_FOG | SPAN_RGBA | SPAN_SPEC | SPAN_TEXTURE | SPAN_LAMBDA);

#define SET_XMAJOR 1
d772 27
a798 22
#define PLOT(X,Y)							\
   {									\
      span.array->x[span.end] = X;					\
      span.array->y[span.end] = Y;					\
      span.array->z[span.end] = Z;					\
      span.array->fog[span.end] = fog0;					\
      span.array->rgba[span.end][RCOMP] = FixedToInt(r0);		\
      span.array->rgba[span.end][GCOMP] = FixedToInt(g0);		\
      span.array->rgba[span.end][BCOMP] = FixedToInt(b0);		\
      span.array->rgba[span.end][ACOMP] = FixedToInt(a0);		\
      span.array->spec[span.end][RCOMP] = FixedToInt(sr0);		\
      span.array->spec[span.end][GCOMP] = FixedToInt(sg0);		\
      span.array->spec[span.end][BCOMP] = FixedToInt(sb0);		\
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {		\
         if (ctx->Texture.Unit[u]._ReallyEnabled) {			\
            span.array->texcoords[u][span.end][0] = fragTexcoord[u][0];	\
            span.array->texcoords[u][span.end][1] = fragTexcoord[u][1];	\
            span.array->texcoords[u][span.end][2] = fragTexcoord[u][2];	\
            span.array->lambda[u][span.end] = 0.0;			\
         }								\
      }									\
      span.end++;							\
d800 34
a834 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d837 2
a838 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_texture_span(ctx, &span);
   }
d849 15
a863 22
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
   GLuint u;

   ASSERT(ctx->Light.ShadeModel == GL_FLAT);

   INIT_SPAN(span, GL_LINE, 0, SPAN_RGBA | SPAN_SPEC,
	     SPAN_XY | SPAN_Z | SPAN_FOG | SPAN_TEXTURE | SPAN_LAMBDA);
   span.red = ChanToFixed(vert1->color[0]);
   span.green = ChanToFixed(vert1->color[1]);
   span.blue = ChanToFixed(vert1->color[2]);
   span.alpha = ChanToFixed(vert1->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;
   span.specRed = ChanToFixed(vert1->specular[0]);
   span.specGreen = ChanToFixed(vert1->specular[1]);
   span.specBlue = ChanToFixed(vert1->specular[2]);
   span.specRedStep = 0;
   span.specGreenStep = 0;
   span.specBlueStep = 0;
d865 2
a866 1
#define SET_XMAJOR 1
d870 1
d872 27
a898 15
#define PLOT(X,Y)							\
   {									\
      span.array->x[span.end] = X;					\
      span.array->y[span.end] = Y;					\
      span.array->z[span.end] = Z;					\
      span.array->fog[span.end] = fog0;					\
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {		\
         if (ctx->Texture.Unit[u]._ReallyEnabled) {			\
            span.array->texcoords[u][span.end][0] = fragTexcoord[u][0];	\
            span.array->texcoords[u][span.end][1] = fragTexcoord[u][1];	\
            span.array->texcoords[u][span.end][2] = fragTexcoord[u][2];	\
            span.array->lambda[u][span.end] = 0.0;			\
         }								\
      }									\
      span.end++;							\
d900 32
a932 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d935 2
a936 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_texture_span(ctx, &span);
   }
d965 1
a965 1
   _mesa_printf("Line Func == ");
d967 3
a969 1
      _mesa_printf("flat_ci_line\n");
d971 3
a973 1
      _mesa_printf("flat_rgba_line\n");
d975 3
a977 1
      _mesa_printf("smooth_ci_line\n");
d979 3
a981 1
      _mesa_printf("smooth_rgba_line\n");
d983 1
a983 1
      _mesa_printf("general_smooth_ci_line\n");
d985 1
a985 1
      _mesa_printf("general_flat_ci_line\n");
d987 1
a987 1
      _mesa_printf("general_smooth_rgba_line\n");
d989 1
a989 1
      _mesa_printf("general_flat_rgba_line\n");
d991 1
a991 1
      _mesa_printf("flat_textured_line\n");
d993 1
a993 1
      _mesa_printf("smooth_textured_line\n");
d995 1
a995 1
      _mesa_printf("smooth_multitextured_line\n");
d997 1
a997 1
      _mesa_printf("flat_multitextured_line\n");
d999 1
a999 1
      _mesa_printf("Driver func %p\n", (void *) swrast->Line);
d1013 1
a1013 1
    /*_mesa_printf("%s\n", lineFuncName);*/   \
d1038 1
a1038 1
   if (ctx->RenderMode == GL_RENDER) {
d1044 2
a1045 2
      else if (ctx->Texture._EnabledUnits) {
         if (ctx->Texture._EnabledUnits > 1 ||	     
d1048 1
a1048 1
            if (ctx->Light.ShadeModel == GL_SMOOTH)
d1054 1
a1054 1
            if (ctx->Light.ShadeModel == GL_SMOOTH) {
d1062 14
d1077 3
a1079 3
	 if (ctx->Light.ShadeModel == GL_SMOOTH) {
            if (ctx->Depth.Test || ctx->Fog.Enabled || ctx->Line.Width != 1.0
                || ctx->Line.StippleFlag) {
d1081 1
a1081 1
                  USE(general_smooth_rgba_line);
d1083 1
a1083 1
                  USE(general_smooth_ci_line);
d1093 2
a1094 2
            if (ctx->Depth.Test || ctx->Fog.Enabled || ctx->Line.Width != 1.0
                || ctx->Line.StippleFlag) {
d1096 1
a1096 1
                  USE(general_flat_rgba_line);
d1098 1
a1098 1
                  USE(general_flat_ci_line);
d1109 1
a1109 1
   else if (ctx->RenderMode == GL_FEEDBACK) {
d1113 1
a1113 1
      ASSERT(ctx->RenderMode == GL_SELECT);
@


1.1.1.1
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@@


1.1.1.2
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
d4 1
a4 1
 * Version:  5.0.2
d6 1
a6 1
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
d32 1
d35 1
a36 2
#include "s_lines.h"
#include "s_span.h"
a38 8
/*
 * Init the mask[] array to implement a line stipple.
 */
static void
compute_stipple_mask( GLcontext *ctx, GLuint len, GLubyte mask[] )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   GLuint i;
d40 3
a42 11
   for (i = 0; i < len; i++) {
      GLuint bit = (swrast->StippleCounter / ctx->Line.StippleFactor) & 0xf;
      if ((1 << bit) & ctx->Line.StipplePattern) {
         mask[i] = GL_TRUE;
      }
      else {
         mask[i] = GL_FALSE;
      }
      swrast->StippleCounter++;
   }
}
d46 5
a50 1
 * To draw a wide line we can simply redraw the span N times, side by side.
d52 6
a57 2
static void
draw_wide_line( GLcontext *ctx, struct sw_span *span, GLboolean xMajor )
d59 1
a59 6
   GLchan colors[MAX_WIDTH][4];
   GLint width, start;
   GLboolean mutable = (ctx->Color.BlendEnabled ||
                        ctx->Texture._EnabledUnits ||
                        ctx->Fog.Enabled ||
                        *((GLuint *) ctx->Color.ColorMask) != 0xffffffff);
d61 1
a61 1
   ASSERT(span->end < MAX_WIDTH);
d63 2
a64 1
   width = (GLint) CLAMP( ctx->Line.Width, MIN_LINE_WIDTH, MAX_LINE_WIDTH );
d66 1
a66 4
   if (width & 1)
      start = width / 2;
   else
      start = width / 2 - 1;
d68 1
a68 60
   if (mutable) {
      /* Backup colors because they'll get modified during span write.
       * This is a bit of hack.  The problem is properly fixed in Mesa 5.1.
       */
      _mesa_memcpy(colors, span->array->rgba, span->end * 4 * sizeof(GLchan));
   }

   if (xMajor) {
      GLint *y = span->array->y;
      GLuint i;
      GLint w;
      for (w = 0; w < width; w++) {
         if (w == 0) {
            for (i = 0; i < span->end; i++)
               y[i] -= start;
         }
         else {
            for (i = 0; i < span->end; i++)
               y[i]++;
         }
         if ((span->interpMask | span->arrayMask) & SPAN_TEXTURE)
            _mesa_write_texture_span(ctx, span);
         else if ((span->interpMask | span->arrayMask) & SPAN_RGBA)
            _mesa_write_rgba_span(ctx, span);
         else
            _mesa_write_index_span(ctx, span);

         if (w + 1 < width && mutable) {
            /* restore original colors */
            _mesa_memcpy(span->array->rgba, colors,
                         span->end * 4 * sizeof(GLchan));
         }
      }
   }
   else {
      GLint *x = span->array->x;
      GLuint i;
      GLint w;
      for (w = 0; w < width; w++) {
         if (w == 0) {
            for (i = 0; i < span->end; i++)
               x[i] -= start;
         }
         else {
            for (i = 0; i < span->end; i++)
               x[i]++;
         }
         if ((span->interpMask | span->arrayMask) & SPAN_TEXTURE)
            _mesa_write_texture_span(ctx, span);
         else if ((span->interpMask | span->arrayMask) & SPAN_RGBA)
            _mesa_write_rgba_span(ctx, span);
         else
            _mesa_write_index_span(ctx, span);
         if (w + 1 < width && mutable) {
            /* restore original colors */
            _mesa_memcpy(span->array->rgba, colors,
                         span->end * 4 * sizeof(GLchan));
         }
      }
   }
d73 4
a76 9
/**********************************************************************/
/*****                    Rasterization                           *****/
/**********************************************************************/


/* Flat, color index line */
static void flat_ci_line( GLcontext *ctx,
                          const SWvertex *vert0,
			  const SWvertex *vert1 )
d78 2
a79 12
   GLint *x, *y;
   struct sw_span span;

   ASSERT(ctx->Light.ShadeModel == GL_FLAT);
   ASSERT(!ctx->Line.StippleFlag);
   ASSERT(ctx->Line.Width == 1.0F);

   INIT_SPAN(span, GL_LINE, 0, SPAN_INDEX, SPAN_XY);
   span.index = IntToFixed(vert1->index);
   span.indexStep = 0;
   x = span.array->x;
   y = span.array->y;
d82 3
a84 6
#define PLOT(X,Y)		\
   {				\
      x[span.end] = X;		\
      y[span.end] = Y;		\
      span.end++;		\
   }
d88 1
a88 1
   _mesa_write_index_span(ctx, &span);
d92 1
d98 11
a108 2
   struct sw_span span;
   GLint *x, *y;
d110 10
a119 15
   ASSERT(ctx->Light.ShadeModel == GL_FLAT);
   ASSERT(!ctx->Line.StippleFlag);
   ASSERT(ctx->Line.Width == 1.0F);

   INIT_SPAN(span, GL_LINE, 0, SPAN_RGBA, SPAN_XY);
   span.red = ChanToFixed(vert1->color[0]);
   span.green = ChanToFixed(vert1->color[1]);
   span.blue = ChanToFixed(vert1->color[2]);
   span.alpha = ChanToFixed(vert1->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;
   x = span.array->x;
   y = span.array->y;
d122 3
a124 6
#define PLOT(X,Y)		\
   {				\
      x[span.end] = X;		\
      y[span.end] = Y;		\
      span.end++;		\
   }
d128 1
a128 1
   _mesa_write_rgba_span(ctx, &span);
d132 1
d138 38
a175 12
   struct sw_span span;
   GLint *x, *y;
   GLuint *index;

   ASSERT(ctx->Light.ShadeModel == GL_SMOOTH);
   ASSERT(!ctx->Line.StippleFlag);
   ASSERT(ctx->Line.Width == 1.0F);

   INIT_SPAN(span, GL_LINE, 0, 0, SPAN_XY | SPAN_INDEX);
   x = span.array->x;
   y = span.array->y;
   index = span.array->index;
d178 2
d181 1
d183 5
a187 6
   {				\
      x[span.end] = X;		\
      y[span.end] = Y;		\
      index[span.end] = I;	\
      span.end++;		\
   }
d191 2
a192 1
   _mesa_write_index_span(ctx, &span);
d196 1
d202 44
a245 12
   struct sw_span span;
   GLint *x, *y;
   GLchan (*rgba)[4];

   ASSERT(ctx->Light.ShadeModel == GL_SMOOTH);
   ASSERT(!ctx->Line.StippleFlag);
   ASSERT(ctx->Line.Width == 1.0F);

   INIT_SPAN(span, GL_LINE, 0, 0, SPAN_XY | SPAN_RGBA);
   x = span.array->x;
   y = span.array->y;
   rgba = span.array->rgba;
d248 2
d252 1
d254 9
a262 9
   {						\
      x[span.end] = X;				\
      y[span.end] = Y;				\
      rgba[span.end][RCOMP] = FixedToInt(r0);	\
      rgba[span.end][GCOMP] = FixedToInt(g0);	\
      rgba[span.end][BCOMP] = FixedToInt(b0);	\
      rgba[span.end][ACOMP] = FixedToInt(a0);	\
      span.end++;				\
   }
d266 2
a267 1
   _mesa_write_rgba_span(ctx, &span);
d271 9
d285 7
a291 16
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
   GLint *x, *y;
   GLdepth *z;
   GLfloat *fog;
   GLuint *index;

   ASSERT(ctx->Light.ShadeModel == GL_SMOOTH);

   INIT_SPAN(span, GL_LINE, 0, 0,
	     SPAN_XY | SPAN_Z | SPAN_FOG | SPAN_INDEX);
   x = span.array->x;
   y = span.array->y;
   z = span.array->z;
   fog = span.array->fog;
   index = span.array->index;
d293 4
a296 1
#define SET_XMAJOR 1
d301 2
d304 8
a311 7
   {				\
      x[span.end] = X;		\
      y[span.end] = Y;		\
      z[span.end] = Z;		\
      fog[span.end] = fog0;	\
      index[span.end] = I;	\
      span.end++;		\
d313 24
d338 18
a355 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d358 2
a359 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_index_span(ctx, &span);
   }
d368 8
a375 16
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
   GLint *x, *y;
   GLdepth *z;
   GLfloat *fog;

   ASSERT(ctx->Light.ShadeModel == GL_FLAT);

   INIT_SPAN(span, GL_LINE, 0, SPAN_INDEX,
	     SPAN_XY | SPAN_Z | SPAN_FOG);
   span.index = IntToFixed(vert1->index);
   span.indexStep = 0;
   x = span.array->x;
   y = span.array->y;
   z = span.array->z;
   fog = span.array->fog;
d377 2
a378 1
#define SET_XMAJOR 1
d382 2
d385 7
a391 6
   {				\
      x[span.end] = X;		\
      y[span.end] = Y;		\
      z[span.end] = Z;		\
      fog[span.end] = fog0;	\
      span.end++;		\
d393 21
d415 16
a430 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d433 2
a434 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_index_span(ctx, &span);
   }
d443 7
a449 16
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
   GLint *x, *y;
   GLdepth *z;
   GLchan (*rgba)[4];
   GLfloat *fog;

   ASSERT(ctx->Light.ShadeModel == GL_SMOOTH);

   INIT_SPAN(span, GL_LINE, 0, 0,
	     SPAN_XY | SPAN_Z | SPAN_FOG | SPAN_RGBA);
   x = span.array->x;
   y = span.array->y;
   z = span.array->z;
   rgba = span.array->rgba;
   fog = span.array->fog;
d451 4
a454 1
#define SET_XMAJOR 1
d460 2
d463 11
a473 10
   {						\
      x[span.end] = X;				\
      y[span.end] = Y;				\
      z[span.end] = Z;				\
      rgba[span.end][RCOMP] = FixedToInt(r0);	\
      rgba[span.end][GCOMP] = FixedToInt(g0);	\
      rgba[span.end][BCOMP] = FixedToInt(b0);	\
      rgba[span.end][ACOMP] = FixedToInt(a0);	\
      fog[span.end] = fog0;			\
      span.end++;				\
d475 60
d536 1
a536 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d539 2
a540 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_rgba_span(ctx, &span);
   }
d548 4
a551 22
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
   GLint *x, *y;
   GLdepth *z;
   GLfloat *fog;

   ASSERT(ctx->Light.ShadeModel == GL_FLAT);

   INIT_SPAN(span, GL_LINE, 0, SPAN_RGBA,
	     SPAN_XY | SPAN_Z | SPAN_FOG);
   span.red = ChanToFixed(vert1->color[0]);
   span.green = ChanToFixed(vert1->color[1]);
   span.blue = ChanToFixed(vert1->color[2]);
   span.alpha = ChanToFixed(vert1->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;
   x = span.array->x;
   y = span.array->y;
   z = span.array->z;
   fog = span.array->fog;
d553 2
a554 1
#define SET_XMAJOR 1
d558 7
a564 7
#define PLOT(X,Y)		\
   {				\
      x[span.end] = X;		\
      y[span.end] = Y;		\
      z[span.end] = Z;		\
      fog[span.end] = fog0;	\
      span.end++;		\
d566 11
d578 13
a590 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d593 1
a593 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_rgba_span(ctx, &span);
   }
d602 12
a613 2
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
d615 2
a616 20
   ASSERT(ctx->Light.ShadeModel == GL_FLAT);

   INIT_SPAN(span, GL_LINE, 0, SPAN_RGBA | SPAN_SPEC,
	     SPAN_XY | SPAN_Z | SPAN_FOG | SPAN_TEXTURE | SPAN_LAMBDA);
   span.red = ChanToFixed(vert1->color[0]);
   span.green = ChanToFixed(vert1->color[1]);
   span.blue = ChanToFixed(vert1->color[2]);
   span.alpha = ChanToFixed(vert1->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;
   span.specRed = ChanToFixed(vert1->specular[0]);
   span.specGreen = ChanToFixed(vert1->specular[1]);
   span.specBlue = ChanToFixed(vert1->specular[2]);
   span.specRedStep = 0;
   span.specGreenStep = 0;
   span.specBlueStep = 0;

#define SET_XMAJOR 1
d621 15
a635 11
#define PLOT(X,Y)						\
   {								\
      span.array->x[span.end] = X;				\
      span.array->y[span.end] = Y;				\
      span.array->z[span.end] = Z;				\
      span.array->fog[span.end] = fog0;				\
      span.array->texcoords[0][span.end][0] = fragTexcoord[0];	\
      span.array->texcoords[0][span.end][1] = fragTexcoord[1];	\
      span.array->texcoords[0][span.end][2] = fragTexcoord[2];	\
      span.array->lambda[0][span.end] = 0.0;			\
      span.end++;						\
d637 19
a656 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d659 2
a660 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_texture_span(ctx, &span);
   }
d670 10
a679 2
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
d681 1
a681 1
   ASSERT(ctx->Light.ShadeModel == GL_SMOOTH);
d683 2
a684 4
   INIT_SPAN(span, GL_LINE, 0, 0,
	     SPAN_XY | SPAN_Z | SPAN_FOG | SPAN_RGBA | SPAN_TEXTURE | SPAN_LAMBDA);

#define SET_XMAJOR 1
d691 19
a709 15
#define PLOT(X,Y)						\
   {								\
      span.array->x[span.end] = X;				\
      span.array->y[span.end] = Y;				\
      span.array->z[span.end] = Z;				\
      span.array->fog[span.end] = fog0;				\
      span.array->rgba[span.end][RCOMP] = FixedToInt(r0);	\
      span.array->rgba[span.end][GCOMP] = FixedToInt(g0);	\
      span.array->rgba[span.end][BCOMP] = FixedToInt(b0);	\
      span.array->rgba[span.end][ACOMP] = FixedToInt(a0);	\
      span.array->texcoords[0][span.end][0] = fragTexcoord[0];	\
      span.array->texcoords[0][span.end][1] = fragTexcoord[1];	\
      span.array->texcoords[0][span.end][2] = fragTexcoord[2];	\
      span.array->lambda[0][span.end] = 0.0;			\
      span.end++;						\
d711 25
a736 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d739 2
a740 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_texture_span(ctx, &span);
   }
d751 8
a758 3
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
   GLuint u;
d760 2
a761 1
   ASSERT(ctx->Light.ShadeModel == GL_SMOOTH);
d763 2
a764 4
   INIT_SPAN(span, GL_LINE, 0, 0,
	     SPAN_XY | SPAN_Z | SPAN_FOG | SPAN_RGBA | SPAN_SPEC | SPAN_TEXTURE | SPAN_LAMBDA);

#define SET_XMAJOR 1
d772 27
a798 22
#define PLOT(X,Y)							\
   {									\
      span.array->x[span.end] = X;					\
      span.array->y[span.end] = Y;					\
      span.array->z[span.end] = Z;					\
      span.array->fog[span.end] = fog0;					\
      span.array->rgba[span.end][RCOMP] = FixedToInt(r0);		\
      span.array->rgba[span.end][GCOMP] = FixedToInt(g0);		\
      span.array->rgba[span.end][BCOMP] = FixedToInt(b0);		\
      span.array->rgba[span.end][ACOMP] = FixedToInt(a0);		\
      span.array->spec[span.end][RCOMP] = FixedToInt(sr0);		\
      span.array->spec[span.end][GCOMP] = FixedToInt(sg0);		\
      span.array->spec[span.end][BCOMP] = FixedToInt(sb0);		\
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {		\
         if (ctx->Texture.Unit[u]._ReallyEnabled) {			\
            span.array->texcoords[u][span.end][0] = fragTexcoord[u][0];	\
            span.array->texcoords[u][span.end][1] = fragTexcoord[u][1];	\
            span.array->texcoords[u][span.end][2] = fragTexcoord[u][2];	\
            span.array->lambda[u][span.end] = 0.0;			\
         }								\
      }									\
      span.end++;							\
d800 34
a834 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d837 2
a838 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_texture_span(ctx, &span);
   }
d849 15
a863 22
   GLboolean xMajor = GL_FALSE;
   struct sw_span span;
   GLuint u;

   ASSERT(ctx->Light.ShadeModel == GL_FLAT);

   INIT_SPAN(span, GL_LINE, 0, SPAN_RGBA | SPAN_SPEC,
	     SPAN_XY | SPAN_Z | SPAN_FOG | SPAN_TEXTURE | SPAN_LAMBDA);
   span.red = ChanToFixed(vert1->color[0]);
   span.green = ChanToFixed(vert1->color[1]);
   span.blue = ChanToFixed(vert1->color[2]);
   span.alpha = ChanToFixed(vert1->color[3]);
   span.redStep = 0;
   span.greenStep = 0;
   span.blueStep = 0;
   span.alphaStep = 0;
   span.specRed = ChanToFixed(vert1->specular[0]);
   span.specGreen = ChanToFixed(vert1->specular[1]);
   span.specBlue = ChanToFixed(vert1->specular[2]);
   span.specRedStep = 0;
   span.specGreenStep = 0;
   span.specBlueStep = 0;
d865 2
a866 1
#define SET_XMAJOR 1
d870 1
d872 27
a898 15
#define PLOT(X,Y)							\
   {									\
      span.array->x[span.end] = X;					\
      span.array->y[span.end] = Y;					\
      span.array->z[span.end] = Z;					\
      span.array->fog[span.end] = fog0;					\
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {		\
         if (ctx->Texture.Unit[u]._ReallyEnabled) {			\
            span.array->texcoords[u][span.end][0] = fragTexcoord[u][0];	\
            span.array->texcoords[u][span.end][1] = fragTexcoord[u][1];	\
            span.array->texcoords[u][span.end][2] = fragTexcoord[u][2];	\
            span.array->lambda[u][span.end] = 0.0;			\
         }								\
      }									\
      span.end++;							\
d900 32
a932 4

   if (ctx->Line.StippleFlag) {
      span.arrayMask |= SPAN_MASK;
      compute_stipple_mask(ctx, span.end, span.array->mask);
d935 2
a936 6
   if (ctx->Line.Width > 1.0) {
      draw_wide_line(ctx, &span, xMajor);
   }
   else {
      _mesa_write_texture_span(ctx, &span);
   }
d965 1
a965 1
   _mesa_printf("Line Func == ");
d967 3
a969 1
      _mesa_printf("flat_ci_line\n");
d971 3
a973 1
      _mesa_printf("flat_rgba_line\n");
d975 3
a977 1
      _mesa_printf("smooth_ci_line\n");
d979 3
a981 1
      _mesa_printf("smooth_rgba_line\n");
d983 1
a983 1
      _mesa_printf("general_smooth_ci_line\n");
d985 1
a985 1
      _mesa_printf("general_flat_ci_line\n");
d987 1
a987 1
      _mesa_printf("general_smooth_rgba_line\n");
d989 1
a989 1
      _mesa_printf("general_flat_rgba_line\n");
d991 1
a991 1
      _mesa_printf("flat_textured_line\n");
d993 1
a993 1
      _mesa_printf("smooth_textured_line\n");
d995 1
a995 1
      _mesa_printf("smooth_multitextured_line\n");
d997 1
a997 1
      _mesa_printf("flat_multitextured_line\n");
d999 1
a999 1
      _mesa_printf("Driver func %p\n", (void *) swrast->Line);
d1013 1
a1013 1
    /*_mesa_printf("%s\n", lineFuncName);*/   \
d1038 1
a1038 1
   if (ctx->RenderMode == GL_RENDER) {
d1044 2
a1045 2
      else if (ctx->Texture._EnabledUnits) {
         if (ctx->Texture._EnabledUnits > 1 ||	     
d1048 1
a1048 1
            if (ctx->Light.ShadeModel == GL_SMOOTH)
d1054 1
a1054 1
            if (ctx->Light.ShadeModel == GL_SMOOTH) {
d1062 14
d1077 3
a1079 3
	 if (ctx->Light.ShadeModel == GL_SMOOTH) {
            if (ctx->Depth.Test || ctx->Fog.Enabled || ctx->Line.Width != 1.0
                || ctx->Line.StippleFlag) {
d1081 1
a1081 1
                  USE(general_smooth_rgba_line);
d1083 1
a1083 1
                  USE(general_smooth_ci_line);
d1093 2
a1094 2
            if (ctx->Depth.Test || ctx->Fog.Enabled || ctx->Line.Width != 1.0
                || ctx->Line.StippleFlag) {
d1096 1
a1096 1
                  USE(general_flat_rgba_line);
d1098 1
a1098 1
                  USE(general_flat_ci_line);
d1109 1
a1109 1
   else if (ctx->RenderMode == GL_FEEDBACK) {
d1113 1
a1113 1
      ASSERT(ctx->RenderMode == GL_SELECT);
@

