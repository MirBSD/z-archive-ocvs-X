head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.4
	cvs-200410241530:1.1.1.4
	cvs-200410012000:1.1.1.4
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.28.18;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.00.59;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.00.59;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.20.03;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.28.56;	author tg;	state Stab;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.10.01.21.02.44;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.04.45;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@/* $XFree86: xc/extras/Mesa/src/mmath.h,v 1.15 2002/01/07 17:26:06 alanh Exp $ */
/*
 * Mesa 3-D graphics library
 * Version:  3.4
 * 
 * Copyright (C) 1999-2000  Brian Paul   All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * Faster arithmetic functions.  If the FAST_MATH preprocessor symbol is
 * defined on the command line (-DFAST_MATH) then we'll use some (hopefully)
 * faster functions for sqrt(), etc.
 */


#ifndef MMATH_H
#define MMATH_H


#include "glheader.h"


/*
 * Set the x86 FPU control word to guarentee only 32 bits of presision
 * are stored in registers.  Allowing the FPU to store more introduces
 * differences between situations where numbers are pulled out of memory
 * vs. situations where the compiler is able to optimize register usage.
 * 
 * In the worst case, we force the compiler to use a memory access to
 * truncate the float, by specifying the 'volatile' keyword.
 */
#if defined(__linux__) && defined(__i386__)
#include <fpu_control.h>

#if !defined(_FPU_SETCW)
#define _FPU_SETCW __setfpucw
typedef unsigned short fpu_control_t;
#endif

#if !defined(_FPU_GETCW)
#define _FPU_GETCW(a) (a) = __fpu_control;
#endif

/* Set it up how we want it.
 */
#if !defined(NO_FAST_MATH) 
#define START_FAST_MATH(x)                  \
   {								\
      static fpu_control_t mask = _FPU_SINGLE | _FPU_MASK_IM	\
            | _FPU_MASK_DM | _FPU_MASK_ZM | _FPU_MASK_OM	\
            | _FPU_MASK_UM | _FPU_MASK_PM;			\
      _FPU_GETCW( x );						\
      _FPU_SETCW( mask );					\
   }
#else
#define START_FAST_MATH(x)			\
   {						\
      static fpu_control_t mask = _FPU_DEFAULT;	\
      _FPU_GETCW( x );				\
      _FPU_SETCW( mask );			\
   }
#endif


/* Put it back how the application had it.
 */
#define END_FAST_MATH(x)			\
   {						\
      _FPU_SETCW( x );				\
   }


#define HAVE_FAST_MATH

#elif defined(__WATCOMC__) && !defined(NO_FAST_MATH) 

/* This is the watcom specific inline assembly version of setcw and getcw */

void START_FAST_MATH2(unsigned short *x);
#pragma aux START_FAST_MATH2 =          \
    "fstcw   word ptr [esi]"            \
    "or      word ptr [esi], 0x3f"      \
    "fldcw   word ptr [esi]"            \
    parm [esi]                          \
    modify exact [];

void END_FAST_MATH2(unsigned short *x);
#pragma aux END_FAST_MATH2 =            \
    "fldcw   word ptr [esi]"            \
    parm [esi]                          \
    modify exact [];

#define START_FAST_MATH(x)  START_FAST_MATH2(& x)          
#define END_FAST_MATH(x)  END_FAST_MATH2(& x)

/*
__inline START_FAST_MATH(unsigned short x)
    {                               
    _asm {                          
        fstcw   ax                  
        mov     x , ax              
        or      ax, 0x3f            
        fldcw   ax                  
        }                           
    }

__inline END_FAST_MATH(unsigned short x)    
    {                               
    _asm {                          
        fldcw   x                   
        }                           
    }
*/
#define HAVE_FAST_MATH

#else
#define START_FAST_MATH(x) (void)(x)
#define END_FAST_MATH(x)   (void)(x)

/* The mac float really is a float, with the same precision as a
 * single precision 387 float.
 */
#if defined(macintosh)
#define HAVE_FAST_MATH
#endif

#endif



/*
 * Float -> Int conversion
 */

#if defined(USE_X86_ASM)
#if defined(__GNUC__) && defined(__i386__)
static __inline__ int FloatToInt(float f)
{
   int r;
   __asm__ ("fistpl %0" : "=m" (r) : "t" (f) : "st");
   return r;
}
#elif  defined(__MSC__) && defined(__WIN32__) && !defined(__CYGWIN__)
static __inline int FloatToInt(float f)
{
   int r;
   _asm {
	 fld f
	 fistp r
	}
   return r;
}
#elif defined(__WATCOMC__)
long FloatToInt(float f);
#pragma aux FloatToInt =                \
	"push   eax"                        \
	"fistp  dword ptr [esp]"            \
	"pop    eax"                        \
	parm [8087]                         \
	value [eax]                         \
	modify exact [eax];
float asm_sqrt (float x);
#pragma aux asm_sqrt =                  \
	"fsqrt"                             \
	parm [8087]                         \
	value [8087]                        \
	modify exact [];
#else
#define FloatToInt(F) ((int) (F))
#endif
#else
#define FloatToInt(F) ((int) (F))
#endif


/*
 * Square root
 */

extern float gl_sqrt(float x);
    
#ifdef FAST_MATH
#if defined (__WATCOMC__) && defined(USE_X86_ASM)
#  define GL_SQRT(X)  asm_sqrt(X)
#else
#  define GL_SQRT(X)  gl_sqrt(X)
#endif
#else
#  define GL_SQRT(X)  sqrt(X)
#endif


/*
 * Normalize a 3-element vector to unit length.
 */
#define NORMALIZE_3FV( V )			\
do {						\
   GLdouble len = LEN_SQUARED_3FV(V);		\
   if (len > 1e-50) {				\
      len = 1.0 / GL_SQRT(len);			\
      V[0] = (GLfloat) (V[0] * len);		\
      V[1] = (GLfloat) (V[1] * len);		\
      V[2] = (GLfloat) (V[2] * len);		\
   }						\
} while(0)

#define LEN_3FV( V ) (GL_SQRT(V[0]*V[0]+V[1]*V[1]+V[2]*V[2]))

#define LEN_SQUARED_3FV( V ) (V[0]*V[0]+V[1]*V[1]+V[2]*V[2])

/*
 * Optimization for:
 * GLfloat f;
 * GLubyte b = FloatToInt(CLAMP(f, 0, 1) * 255)
 */

#if defined(__i386__) || defined(__sparc__) || defined(__s390x__) || \
    defined(__ppc__) || defined(__powerpc__) || \
    ( defined(__alpha__) && ( defined( __IEEE_FLOAT ) || !defined( VMS ) ) )
#define USE_IEEE
#define IEEE_ONE 0x3f7f0000
#endif

#if defined(USE_IEEE) && !defined(DEBUG)

#define CLAMP_FLOAT_COLOR(f)			\
	do {					\
	   if (*(GLuint *)&f >= IEEE_ONE)	\
	      f = (*(GLint *)&f < 0) ? 0 : 1;	\
	} while(0)

#define CLAMP_FLOAT_COLOR_VALUE(f)		\
    ( (*(GLuint *)&f >= IEEE_ONE)		\
      ? ((*(GLint *)&f < 0) ? 0 : 1)		\
      : f )

/* 
 * This function/macro is sensitive to precision.  Test carefully
 * if you change it.
 */
#define FLOAT_COLOR_TO_UBYTE_COLOR(b, f)                        \
        do {                                                    \
           union { GLfloat r; GLuint i; } tmp;                  \
           tmp.r = f;                                           \
           b = ((tmp.i >= IEEE_ONE)                             \
               ? ((GLint)tmp.i < 0) ? (GLubyte)0 : (GLubyte)255 \
               : (tmp.r = tmp.r*(255.0F/256.0F) + 32768.0F,     \
                  (GLubyte)tmp.i));                             \
        } while (0)


#define CLAMPED_FLOAT_COLOR_TO_UBYTE_COLOR(b,f) \
         FLOAT_COLOR_TO_UBYTE_COLOR(b, f)

#else

#define CLAMP_FLOAT_COLOR(f) \
        (void) CLAMP_SELF(f,0,1)

#define CLAMP_FLOAT_COLOR_VALUE(f) \
        CLAMP(f,0,1)
       
#define FLOAT_COLOR_TO_UBYTE_COLOR(b, f)			\
	b = ((GLubyte) FloatToInt(CLAMP(f, 0.0F, 1.0F) * 255.0F))

#define CLAMPED_FLOAT_COLOR_TO_UBYTE_COLOR(b,f) \
	b = ((GLubyte) FloatToInt(f * 255.0F))

#endif

#ifdef USE_IEEE
/* Returns TRUE for x == Inf or x == NaN. */
static INLINE int IS_INF_OR_NAN( float x )
{
   union {float f; int i;} tmp;
   tmp.f = x;
   return !(int)((unsigned int)((tmp.i & 0x7fffffff)-0x7f800000) >> 31);
}
#else
#define IS_INF_OR_NAN(x)        (!finite(x)) 
#endif

extern float gl_ubyte_to_float_color_tab[256];
extern float gl_ubyte_to_float_255_color_tab[256];
#define UBYTE_COLOR_TO_FLOAT_COLOR(c) gl_ubyte_to_float_color_tab[c]

#define UBYTE_COLOR_TO_FLOAT_255_COLOR(c) gl_ubyte_to_float_255_color_tab[c]

#define UBYTE_COLOR_TO_FLOAT_255_COLOR2(f,c) \
    (*(int *)&(f)) = ((int *)gl_ubyte_to_float_255_color_tab)[c]


#define UBYTE_RGBA_TO_FLOAT_RGBA(f,b) 		\
do {						\
   f[0] = UBYTE_COLOR_TO_FLOAT_COLOR(b[0]);	\
   f[1] = UBYTE_COLOR_TO_FLOAT_COLOR(b[1]);	\
   f[2] = UBYTE_COLOR_TO_FLOAT_COLOR(b[2]);	\
   f[3] = UBYTE_COLOR_TO_FLOAT_COLOR(b[3]);	\
} while(0)


#define UBYTE_RGBA_TO_FLOAT_255_RGBA(f,b) 		\
do {						\
   f[0] = UBYTE_COLOR_TO_FLOAT_255_COLOR(b[0]);	\
   f[1] = UBYTE_COLOR_TO_FLOAT_255_COLOR(b[1]);	\
   f[2] = UBYTE_COLOR_TO_FLOAT_255_COLOR(b[2]);	\
   f[3] = UBYTE_COLOR_TO_FLOAT_255_COLOR(b[3]);	\
} while(0)

#define FLOAT_RGBA_TO_UBYTE_RGBA(b,f) 		\
do {						\
   FLOAT_COLOR_TO_UBYTE_COLOR((b[0]),(f[0]));	\
   FLOAT_COLOR_TO_UBYTE_COLOR((b[1]),(f[1]));	\
   FLOAT_COLOR_TO_UBYTE_COLOR((b[2]),(f[2]));	\
   FLOAT_COLOR_TO_UBYTE_COLOR((b[3]),(f[3]));	\
} while(0)

#define FLOAT_RGB_TO_UBYTE_RGB(b,f) 		\
do {						\
   FLOAT_COLOR_TO_UBYTE_COLOR(b[0],f[0]);	\
   FLOAT_COLOR_TO_UBYTE_COLOR(b[1],f[1]);	\
   FLOAT_COLOR_TO_UBYTE_COLOR(b[2],f[2]);	\
} while(0)



extern void
_mesa_init_math(void);


extern GLuint
_mesa_bitcount(GLuint n);


#endif
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
d4 4
a7 4
 * Version:  5.0.2
 *
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
 *
d14 1
a14 1
 *
d17 1
a17 1
 *
a24 1
/* $XFree86: xc/extras/Mesa/src/mmath.h,v 1.22 2003/10/22 15:44:41 tsi Exp $ */
d39 1
a39 3
#include "imports.h"
/* Do not reference mtypes.h from this file.
 */
d46 1
a46 1
 *
d50 7
a56 1
#if defined(__GNUC__) && defined(__i386__)
d58 3
a60 4
/* Hardware default: All exceptions masked, extended double precision,
 * round to nearest.  IEEE compliant.
 */
#define DEFAULT_X86_FPU		0x037f
d62 1
a62 1
/* All exceptions masked, single precision, round to nearest.
d64 9
a72 14
#define FAST_X86_FPU		0x003f

/* Set it up how we want it.  The fldcw instruction will cause any
 * pending FP exceptions to be raised prior to entering the block, and
 * we clear any pending exceptions before exiting the block.  Hence, asm
 * code has free reign over the FPU while in the fast math block.
 */
#if defined(NO_FAST_MATH)
#define START_FAST_MATH(x)						\
do {									\
   static GLuint mask = DEFAULT_X86_FPU;				\
   __asm__ ( "fnstcw %0" : "=m" (*&(x)) );				\
   __asm__ ( "fldcw %0" : : "m" (mask) );				\
} while (0)
d74 6
a79 6
#define START_FAST_MATH(x)						\
do {									\
   static GLuint mask = FAST_X86_FPU;					\
   __asm__ ( "fnstcw %0" : "=m" (*&(x)) );				\
   __asm__ ( "fldcw %0" : : "m" (mask) );				\
} while (0)
d82 8
a89 7
/* Put it back how the application had it, and clear any exceptions that
 * may have occurred in the FAST_MATH block.
 */
#define END_FAST_MATH(x)						\
do {									\
   __asm__ ( "fnclex ; fldcw %0" : : "m" (*&(x)) );			\
} while (0)
d93 1
a93 1
#elif defined(__WATCOMC__) && !defined(NO_FAST_MATH)
d111 1
a111 1
#define START_FAST_MATH(x)  START_FAST_MATH2(& x)
d116 7
a122 7
    {
    _asm {
        fstcw   ax
        mov     x , ax
        or      ax, 0x3f
        fldcw   ax
        }
d125 5
a129 5
__inline END_FAST_MATH(unsigned short x)
    {
    _asm {
        fldcw   x
        }
d135 1
a135 1
#define START_FAST_MATH(x) x = 0
d141 1
a141 1
#if defined(macintosh) || defined(__powerpc__)
d150 1
a150 1
 * Square root
d153 3
a155 82
extern float gl_sqrt(float x);

#ifdef FAST_MATH
#if defined(__WATCOMC__) && defined(USE_X86_ASM)
#  define GL_SQRT(X)  asm_sqrt(X)
#else
#  define GL_SQRT(X)  gl_sqrt(X)
#endif
#else
#  define GL_SQRT(X)  sqrt(X)
#endif


/*
 * Normalize a 3-element vector to unit length.
 */
#define NORMALIZE_3FV( V )			\
do {						\
   GLfloat len = (GLfloat) LEN_SQUARED_3FV(V);	\
   if (len) {					\
      len = (GLfloat) (1.0 / GL_SQRT(len));	\
      (V)[0] = (GLfloat) ((V)[0] * len);	\
      (V)[1] = (GLfloat) ((V)[1] * len);	\
      (V)[2] = (GLfloat) ((V)[2] * len);	\
   }						\
} while(0)

#define LEN_3FV( V ) (GL_SQRT((V)[0]*(V)[0]+(V)[1]*(V)[1]+(V)[2]*(V)[2]))
#define LEN_2FV( V ) (GL_SQRT((V)[0]*(V)[0]+(V)[1]*(V)[1]))

#define LEN_SQUARED_3FV( V ) ((V)[0]*(V)[0]+(V)[1]*(V)[1]+(V)[2]*(V)[2])
#define LEN_SQUARED_2FV( V ) ((V)[0]*(V)[0]+(V)[1]*(V)[1])


/*
 * Single precision ceiling, floor, and absolute value functions
 */
#if defined(XFree86LOADER) && defined(IN_MODULE)
#define CEILF(x)   ((GLfloat) xf86ceil(x))
#define FLOORF(x)  ((GLfloat) xf86floor(x))
#define FABSF(x)   ((GLfloat) xf86fabs(x))
#elif defined(__gnu_linux__)
/* C99 functions */
#define CEILF(x)   ceilf(x)
#define FLOORF(x)  floorf(x)
#define FABSF(x)   fabsf(x)
#else
#define CEILF(x)   ((GLfloat) ceil(x))
#define FLOORF(x)  ((GLfloat) floor(x))
#define FABSF(x)   ((GLfloat) fabs(x))
#endif


#if defined(__i386__) || defined(__sparc__) || defined(__s390x__) || \
    defined(__powerpc__) || defined(__AMD64__) || \
    ( defined(__alpha__) && ( defined(__IEEE_FLOAT) || !defined(VMS) ) )
#define USE_IEEE
#endif



#define GET_FLOAT_BITS(x) ((fi_type *) &(x))->i

/*
 * Float -> Int conversions (rounding, floor, ceiling)
 */

#if defined(USE_SPARC_ASM) && defined(__GNUC__) && defined(__sparc__)

static INLINE int iround(float f)
{
       int r;
       __asm__ ("fstoi %1, %0" : "=f" (r) : "f" (f));
       return r;
}

#define IROUND(x)  iround(x)

#elif defined(USE_X86_ASM) && defined(__GNUC__) && defined(__i386__)


static INLINE int iround(float f)
d161 2
a162 50

#define IROUND(x)  iround(x)

/*
 * IEEE floor for computers that round to nearest or even.
 * 'f' must be between -4194304 and 4194303.
 * This floor operation is done by "(iround(f + .5) + iround(f - .5)) >> 1",
 * but uses some IEEE specific tricks for better speed.
 * Contributed by Josh Vanderhoof
 */
static INLINE int ifloor(float f)
{
   int ai, bi;
   double af, bf;
   af = (3 << 22) + 0.5 + (double)f;
   bf = (3 << 22) + 0.5 - (double)f;
   /* GCC generates an extra fstp/fld without this. */
   __asm__ ("fstps %0" : "=m" (ai) : "t" (af) : "st");
   __asm__ ("fstps %0" : "=m" (bi) : "t" (bf) : "st");
   return (ai - bi) >> 1;
}

#define IFLOOR(x)  ifloor(x)

/*
 * IEEE ceil for computers that round to nearest or even.
 * 'f' must be between -4194304 and 4194303.
 * This ceil operation is done by "(iround(f + .5) + iround(f - .5) + 1) >> 1",
 * but uses some IEEE specific tricks for better speed.
 * Contributed by Josh Vanderhoof
 */
static INLINE int iceil(float f)
{
   int ai, bi;
   double af, bf;
   af = (3 << 22) + 0.5 + (double)f;
   bf = (3 << 22) + 0.5 - (double)f;
   /* GCC generates an extra fstp/fld without this. */
   __asm__ ("fstps %0" : "=m" (ai) : "t" (af) : "st");
   __asm__ ("fstps %0" : "=m" (bi) : "t" (bf) : "st");
   return (ai - bi + 1) >> 1;
}

#define ICEIL(x)  iceil(x)


#elif defined(USE_X86_ASM) && defined(__MSC__) && defined(__WIN32__)


static INLINE int iround(float f)
d171 3
a173 9

#define IROUND(x)  iround(x)


#elif defined(USE_X86_ASM) && defined(__WATCOMC__)


long iround(float f);
#pragma aux iround =                        \
a179 3

#define IROUND(x)  iround(x)

d181 1
a181 1
#pragma aux asm_sqrt =                      \
d186 2
a187 8


#endif /* assembly/optimized IROUND, IROUND_POS, IFLOOR, ICEIL macros */


/* default IROUND macro */
#ifndef IROUND
#define IROUND(f)  ((int) (((f) >= 0.0F) ? ((f) + 0.5F) : ((f) - 0.5F)))
a188 6


/* default IROUND_POS macro */
#ifndef IROUND_POS
#ifdef DEBUG
#define IROUND_POS(f) (ASSERT((f) >= 0.0F), IROUND(f))
d190 1
a190 1
#define IROUND_POS(f) (IROUND(f))
a191 1
#endif /* IROUND_POS */
d194 9
a202 14
/* default IFLOOR macro */
#ifndef IFLOOR
static INLINE int ifloor(float f)
{
#ifdef USE_IEEE
   int ai, bi;
   double af, bf;
   union { int i; float f; } u;

   af = (3 << 22) + 0.5 + (double)f;
   bf = (3 << 22) + 0.5 - (double)f;
   u.f = af; ai = u.i;
   u.f = bf; bi = u.i;
   return (ai - bi) >> 1;
d204 1
a204 2
   int i = IROUND(f);
   return (i > f) ? i - 1 : i;
a205 18
}
#define IFLOOR(x)  ifloor(x)
#endif /* IFLOOR */


/* default ICEIL macro */
#ifndef ICEIL
static INLINE int iceil(float f)
{
#ifdef USE_IEEE
   int ai, bi;
   double af, bf;
   union { int i; float f; } u;
   af = (3 << 22) + 0.5 + (double)f;
   bf = (3 << 22) + 0.5 - (double)f;
   u.f = af; ai = u.i;
   u.f = bf; bi = u.i;
   return (ai - bi + 1) >> 1;
d207 1
a207 2
   int i = IROUND(f);
   return (i < f) ? i + 1 : i;
a208 4
}
#define ICEIL(x)  iceil(x)
#endif /* ICEIL */

d212 1
a212 2
 * Convert unclamped or clamped ([0,1]) floats to ubytes for color
 * conversion only.  These functions round to the nearest int.
d214 10
a223 37
#define IEEE_ONE 0x3f800000
#define IEEE_0996 0x3f7f0000	/* 0.996 or something??? used in macro
                                   below only */

#if defined(USE_IEEE) && !defined(DEBUG)

/*
 * This function/macro is sensitive to precision.  Test carefully
 * if you change it.
 */
#define UNCLAMPED_FLOAT_TO_UBYTE(ub, f)					\
        do {								\
           union { GLfloat r; GLuint i; } __tmp;			\
           __tmp.r = (f);						\
           ub = ((__tmp.i >= IEEE_0996)					\
               ? ((GLint)__tmp.i < 0) ? (GLubyte)0 : (GLubyte)255	\
               : (__tmp.r = __tmp.r*(255.0F/256.0F) + 32768.0F,		\
                  (GLubyte)__tmp.i));					\
        } while (0)

#define CLAMPED_FLOAT_TO_UBYTE(ub, f) \
        UNCLAMPED_FLOAT_TO_UBYTE(ub, f)

#define COPY_FLOAT( dst, src )					\
	((fi_type *) &(dst))->i = ((fi_type *) &(src))->i

#else /* USE_IEEE */

#define UNCLAMPED_FLOAT_TO_UBYTE(ub, f) \
	ub = ((GLubyte) IROUND(CLAMP((f), 0.0F, 1.0F) * 255.0F))

#define CLAMPED_FLOAT_TO_UBYTE(ub, f) \
	ub = ((GLubyte) IROUND((f) * 255.0F))

#define COPY_FLOAT( dst, src )		(dst) = (src)

#endif /* USE_IEEE */
d225 1
d227 1
d230 3
a232 1
 * Integer / float conversion for colors, normals, etc.
d235 6
a240 3
/* Convert GLubyte in [0,255] to GLfloat in [0.0,1.0] */
extern float _mesa_ubyte_to_float_color_tab[256];
#define UBYTE_TO_FLOAT(u) _mesa_ubyte_to_float_color_tab[(unsigned int)(u)]
d242 1
a242 2
/* Convert GLfloat in [0.0,1.0] to GLubyte in [0,255] */
#define FLOAT_TO_UBYTE(X)	((GLubyte) (GLint) ((X) * 255.0F))
d244 10
d255 3
a257 62
/* Convert GLbyte in [-128,127] to GLfloat in [-1.0,1.0] */
#define BYTE_TO_FLOAT(B)	((2.0F * (B) + 1.0F) * (1.0F/255.0F))

/* Convert GLfloat in [-1.0,1.0] to GLbyte in [-128,127] */
#define FLOAT_TO_BYTE(X)	( (((GLint) (255.0F * (X))) - 1) / 2 )


/* Convert GLushort in [0,65536] to GLfloat in [0.0,1.0] */
#define USHORT_TO_FLOAT(S)	((GLfloat) (S) * (1.0F / 65535.0F))

/* Convert GLfloat in [0.0,1.0] to GLushort in [0,65536] */
#define FLOAT_TO_USHORT(X)	((GLushort) (GLint) ((X) * 65535.0F))


/* Convert GLshort in [-32768,32767] to GLfloat in [-1.0,1.0] */
#define SHORT_TO_FLOAT(S)	((2.0F * (S) + 1.0F) * (1.0F/65535.0F))

/* Convert GLfloat in [0.0,1.0] to GLshort in [-32768,32767] */
#define FLOAT_TO_SHORT(X)	( (((GLint) (65535.0F * (X))) - 1) / 2 )


/* Convert GLuint in [0,4294967295] to GLfloat in [0.0,1.0] */
#define UINT_TO_FLOAT(U)	((GLfloat) (U) * (1.0F / 4294967295.0F))

/* Convert GLfloat in [0.0,1.0] to GLuint in [0,4294967295] */
#define FLOAT_TO_UINT(X)	((GLuint) ((X) * 4294967295.0))


/* Convert GLint in [-2147483648,2147483647] to GLfloat in [-1.0,1.0] */
#define INT_TO_FLOAT(I)		((2.0F * (I) + 1.0F) * (1.0F/4294967294.0F))

/* Convert GLfloat in [-1.0,1.0] to GLint in [-2147483648,2147483647] */
/* causes overflow:
#define FLOAT_TO_INT(X)		( (((GLint) (4294967294.0F * (X))) - 1) / 2 )
*/
/* a close approximation: */
#define FLOAT_TO_INT(X)		( (GLint) (2147483647.0 * (X)) )


#define BYTE_TO_UBYTE(b)   ((GLubyte) ((b) < 0 ? 0 : (GLubyte) (b)))
#define SHORT_TO_UBYTE(s)  ((GLubyte) ((s) < 0 ? 0 : (GLubyte) ((s) >> 7)))
#define USHORT_TO_UBYTE(s) ((GLubyte) ((s) >> 8))
#define INT_TO_UBYTE(i)    ((GLubyte) ((i) < 0 ? 0 : (GLubyte) ((i) >> 23)))
#define UINT_TO_UBYTE(i)   ((GLubyte) ((i) >> 24))


#define BYTE_TO_USHORT(b)  ((b) < 0 ? 0 : ((GLushort) (((b) * 65535) / 255)))
#define UBYTE_TO_USHORT(b) (((GLushort) (b) << 8) | (GLushort) (b))
#define SHORT_TO_USHORT(s) ((s) < 0 ? 0 : ((GLushort) (((s) * 65535 / 32767))))
#define INT_TO_USHORT(i)   ((i) < 0 ? 0 : ((GLushort) ((i) >> 15)))
#define UINT_TO_USHORT(i)  ((i) < 0 ? 0 : ((GLushort) ((i) >> 16)))
#define UNCLAMPED_FLOAT_TO_USHORT(us, f)  \
        us = ( (GLushort) IROUND( CLAMP((f), 0.0, 1.0) * 65535.0F) )
#define CLAMPED_FLOAT_TO_USHORT(us, f)  \
        us = ( (GLushort) IROUND( (f) * 65535.0F) )



/*
 * Linear interpolation
 * NOTE:  OUT argument is evaluated twice!
 * NOTE:  Be wary of using *coord++ as an argument to any of these macros!
d259 9
a267 11
#define LINTERP(T, OUT, IN)	((OUT) + (T) * ((IN) - (OUT)))

/* Can do better with integer math:
 */
#define INTERP_UB( t, dstub, outub, inub )	\
do {						\
   GLfloat inf = UBYTE_TO_FLOAT( inub );	\
   GLfloat outf = UBYTE_TO_FLOAT( outub );	\
   GLfloat dstf = LINTERP( t, outf, inf );	\
   UNCLAMPED_FLOAT_TO_UBYTE( dstub, dstf );	\
} while (0)
a268 7
#define INTERP_CHAN( t, dstc, outc, inc )	\
do {						\
   GLfloat inf = CHAN_TO_FLOAT( inc );		\
   GLfloat outf = CHAN_TO_FLOAT( outc );	\
   GLfloat dstf = LINTERP( t, outf, inf );	\
   UNCLAMPED_FLOAT_TO_CHAN( dstc, dstf );	\
} while (0)
d270 2
a271 2
#define INTERP_UI( t, dstui, outui, inui )	\
   dstui = (GLuint) (GLint) LINTERP( (t), (GLfloat) (outui), (GLfloat) (inui) )
d273 1
a273 2
#define INTERP_F( t, dstf, outf, inf )		\
   dstf = LINTERP( t, outf, inf )
d275 2
a276 7
#define INTERP_4F( t, dst, out, in )		\
do {						\
   dst[0] = LINTERP( (t), (out)[0], (in)[0] );	\
   dst[1] = LINTERP( (t), (out)[1], (in)[1] );	\
   dst[2] = LINTERP( (t), (out)[2], (in)[2] );	\
   dst[3] = LINTERP( (t), (out)[3], (in)[3] );	\
} while (0)
d278 5
a282 31
#define INTERP_3F( t, dst, out, in )		\
do {						\
   dst[0] = LINTERP( (t), (out)[0], (in)[0] );	\
   dst[1] = LINTERP( (t), (out)[1], (in)[1] );	\
   dst[2] = LINTERP( (t), (out)[2], (in)[2] );	\
} while (0)

#define INTERP_4CHAN( t, dst, out, in )			\
do {							\
   INTERP_CHAN( (t), (dst)[0], (out)[0], (in)[0] );	\
   INTERP_CHAN( (t), (dst)[1], (out)[1], (in)[1] );	\
   INTERP_CHAN( (t), (dst)[2], (out)[2], (in)[2] );	\
   INTERP_CHAN( (t), (dst)[3], (out)[3], (in)[3] );	\
} while (0)

#define INTERP_3CHAN( t, dst, out, in )			\
do {							\
   INTERP_CHAN( (t), (dst)[0], (out)[0], (in)[0] );	\
   INTERP_CHAN( (t), (dst)[1], (out)[1], (in)[1] );	\
   INTERP_CHAN( (t), (dst)[2], (out)[2], (in)[2] );	\
} while (0)

#define INTERP_SZ( t, vec, to, out, in, sz )				\
do {									\
   switch (sz) {							\
   case 4: vec[to][3] = LINTERP( (t), (vec)[out][3], (vec)[in][3] );	\
   case 3: vec[to][2] = LINTERP( (t), (vec)[out][2], (vec)[in][2] );	\
   case 2: vec[to][1] = LINTERP( (t), (vec)[out][1], (vec)[in][1] );	\
   case 1: vec[to][0] = LINTERP( (t), (vec)[out][0], (vec)[in][0] );	\
   }									\
} while(0)
d284 2
d287 1
a287 27
/*
 * Fixed point arithmetic macros
 */
#ifdef FIXED_14
#define FIXED_ONE       0x00004000
#define FIXED_HALF      0x00002000
#define FIXED_FRAC_MASK 0x00003FFF
#define FIXED_SCALE     16384.0f
#define FIXED_SHIFT     14
#else
#define FIXED_ONE       0x00000800
#define FIXED_HALF      0x00000400
#define FIXED_FRAC_MASK 0x000007FF
#define FIXED_SCALE     2048.0f
#define FIXED_SHIFT     11
#endif
#define FIXED_INT_MASK  (~FIXED_FRAC_MASK)
#define FIXED_EPSILON   1
#define FloatToFixed(X) (IROUND((X) * FIXED_SCALE))
#define IntToFixed(I)   ((I) << FIXED_SHIFT)
#define FixedToInt(X)   ((X) >> FIXED_SHIFT)
#define FixedToUns(X)   (((unsigned int)(X)) >> FIXED_SHIFT)
#define FixedCeil(X)    (((X) + FIXED_ONE - FIXED_EPSILON) & FIXED_INT_MASK)
#define FixedFloor(X)   ((X) & FIXED_INT_MASK)
#define FixedToFloat(X) ((X) * (1.0F / FIXED_SCALE))
#define PosFloatToFixed(X)      FloatToFixed(X)
#define SignedFloatToFixed(X)   FloatToFixed(X)
d289 1
a290 1
#ifdef USE_IEEE
a296 8
#elif defined(isfinite)
#define IS_INF_OR_NAN(x)        (!isfinite(x))
#elif defined(finite)
#define IS_INF_OR_NAN(x)        (!finite(x))
#elif __VMS
#define IS_INF_OR_NAN(x)        (!finite(x))
#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
#define IS_INF_OR_NAN(x)        (!isfinite(x))
d298 6
a303 2
#define IS_INF_OR_NAN(x)        (!finite(x))
#endif 
d305 1
d307 11
a317 4
/*
 * Return log_base_2(x).
 */
#ifdef USE_IEEE
a318 13
#if 0
/* This is pretty fast, but not accurate enough (only 2 fractional bits).
 * Based on code from http://www.stereopsis.com/log2.html
 */
static INLINE GLfloat LOG2(GLfloat x)
{
   const GLfloat y = x * x * x * x;
   const GLuint ix = *((GLuint *) &y);
   const GLuint exp = (ix >> 23) & 0xFF;
   const GLint log2 = ((GLint) exp) - 127;
   return (GLfloat) log2 * (1.0 / 4.0);  /* 4, because of x^4 above */
}
#endif
d320 7
a326 14
/* Pretty fast, and accurate.
 * Based on code from http://www.flipcode.com/totd/
 */
static INLINE GLfloat LOG2(GLfloat val)
{
   GLint *exp_ptr = (GLint *) &val;
   GLint x = *exp_ptr;
   const GLint log_2 = ((x >> 23) & 255) - 128;
   x &= ~(255 << 23);
   x += 127 << 23;
   *exp_ptr = x;
   val = ((-1.0f/3) * val + 2) * val - 2.0f/3;
   return val + log_2;
}
d328 7
a334 1
#else /* USE_IEEE */
d336 6
a341 5
/* Slow, portable solution.
 * NOTE: log_base_2(x) = log(x) / log(2)
 * NOTE: 1.442695 = 1/log(2).
 */
#define LOG2(x)  ((GLfloat) (log(x) * 1.442695F))
a342 1
#endif /* USE_IEEE */
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1

d4 4
a7 4
 * Version:  4.0.3
 *
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
 *
d14 1
a14 1
 *
d17 1
a17 1
 *
d39 1
a39 2
/* Do not reference mtypes.h from this file.
 */
d46 1
a46 1
 *
d50 7
a56 1
#if defined(__GNUC__) && defined(__i386__)
d58 3
a60 4
/* Hardware default: All exceptions masked, extended double precision,
 * round to nearest.  IEEE compliant.
 */
#define DEFAULT_X86_FPU		0x037f
d62 1
a62 1
/* All exceptions masked, single precision, round to nearest.
d64 9
a72 14
#define FAST_X86_FPU		0x003f

/* Set it up how we want it.  The fldcw instruction will cause any
 * pending FP exceptions to be raised prior to entering the block, and
 * we clear any pending exceptions before exiting the block.  Hence, asm
 * code has free reign over the FPU while in the fast math block.
 */
#if defined(NO_FAST_MATH)
#define START_FAST_MATH(x)						\
do {									\
   static GLuint mask = DEFAULT_X86_FPU;				\
   __asm__ ( "fnstcw %0" : "=m" (*&(x)) );				\
   __asm__ ( "fldcw %0" : : "m" (mask) );				\
} while (0)
d74 6
a79 6
#define START_FAST_MATH(x)						\
do {									\
   static GLuint mask = FAST_X86_FPU;					\
   __asm__ ( "fnstcw %0" : "=m" (*&(x)) );				\
   __asm__ ( "fldcw %0" : : "m" (mask) );				\
} while (0)
d82 8
a89 7
/* Put it back how the application had it, and clear any exceptions that
 * may have occurred in the FAST_MATH block.
 */
#define END_FAST_MATH(x)						\
do {									\
   __asm__ ( "fnclex ; fldcw %0" : : "m" (*&(x)) );			\
} while (0)
d93 1
a93 1
#elif defined(__WATCOMC__) && !defined(NO_FAST_MATH)
d111 1
a111 1
#define START_FAST_MATH(x)  START_FAST_MATH2(& x)
d116 7
a122 7
    {
    _asm {
        fstcw   ax
        mov     x , ax
        or      ax, 0x3f
        fldcw   ax
        }
d125 5
a129 5
__inline END_FAST_MATH(unsigned short x)
    {
    _asm {
        fldcw   x
        }
d141 1
a141 1
#if defined(macintosh) || defined(__powerpc__)
d150 1
a150 1
 * Square root
d153 3
a155 77
extern float gl_sqrt(float x);

#ifdef FAST_MATH
#if defined(__WATCOMC__) && defined(USE_X86_ASM)
#  define GL_SQRT(X)  asm_sqrt(X)
#else
#  define GL_SQRT(X)  gl_sqrt(X)
#endif
#else
#  define GL_SQRT(X)  sqrt(X)
#endif


/*
 * Normalize a 3-element vector to unit length.
 */
#define NORMALIZE_3FV( V )			\
do {						\
   GLfloat len = LEN_SQUARED_3FV(V);		\
   if (len) {					\
      len = (GLfloat) (1.0 / GL_SQRT(len));	\
      (V)[0] = (GLfloat) ((V)[0] * len);		\
      (V)[1] = (GLfloat) ((V)[1] * len);		\
      (V)[2] = (GLfloat) ((V)[2] * len);		\
   }						\
} while(0)

#define LEN_3FV( V ) (GL_SQRT((V)[0]*(V)[0]+(V)[1]*(V)[1]+(V)[2]*(V)[2]))
#define LEN_2FV( V ) (GL_SQRT((V)[0]*(V)[0]+(V)[1]*(V)[1]))

#define LEN_SQUARED_3FV( V ) ((V)[0]*(V)[0]+(V)[1]*(V)[1]+(V)[2]*(V)[2])
#define LEN_SQUARED_2FV( V ) ((V)[0]*(V)[0]+(V)[1]*(V)[1])


/*
 * Single precision ceiling, floor, and absolute value functions
 */
#if defined(__sparc__) /* XXX this probably isn't the ideal test */
#define CEILF(x)   ceil(x)
#define FLOORF(x)  floor(x)
#define FABSF(x)   fabs(x)
#else
#define CEILF(x)   ceilf(x)
#define FLOORF(x)  floorf(x)
#define FABSF(x)   fabsf(x)
#endif


#if defined(__i386__) || defined(__sparc__) || defined(__s390x__) || \
    defined(__powerpc__) || defined(__x86_64__) || \
    ( defined(__alpha__) && ( defined(__IEEE_FLOAT) || !defined(VMS) ) )
#define USE_IEEE
#endif



#define GET_FLOAT_BITS(x) ((fi_type *) &(x))->i

/*
 * Float -> Int conversions (rounding, floor, ceiling)
 */

#if defined(USE_SPARC_ASM) && defined(__GNUC__) && defined(__sparc__)

static INLINE int iround(float f)
{
       int r;
       __asm__ ("fstoi %1, %0" : "=f" (r) : "f" (f));
       return r;
}

#define IROUND(x)  iround(x)

#elif defined(USE_X86_ASM) && defined(__GNUC__) && defined(__i386__)


static INLINE int iround(float f)
d161 2
a162 50

#define IROUND(x)  iround(x)

/*
 * IEEE floor for computers that round to nearest or even.
 * 'f' must be between -4194304 and 4194303.
 * This floor operation is done by "(iround(f + .5) + iround(f - .5)) >> 1",
 * but uses some IEEE specific tricks for better speed.
 * Contributed by Josh Vanderhoof
 */
static INLINE int ifloor(float f)
{
   int ai, bi;
   double af, bf;
   af = (3 << 22) + 0.5 + (double)f;
   bf = (3 << 22) + 0.5 - (double)f;
   /* GCC generates an extra fstp/fld without this. */
   __asm__ ("fstps %0" : "=m" (ai) : "t" (af) : "st");
   __asm__ ("fstps %0" : "=m" (bi) : "t" (bf) : "st");
   return (ai - bi) >> 1;
}

#define IFLOOR(x)  ifloor(x)

/*
 * IEEE ceil for computers that round to nearest or even.
 * 'f' must be between -4194304 and 4194303.
 * This ceil operation is done by "(iround(f + .5) + iround(f - .5) + 1) >> 1",
 * but uses some IEEE specific tricks for better speed.
 * Contributed by Josh Vanderhoof
 */
static INLINE int iceil(float f)
{
   int ai, bi;
   double af, bf;
   af = (3 << 22) + 0.5 + (double)f;
   bf = (3 << 22) + 0.5 - (double)f;
   /* GCC generates an extra fstp/fld without this. */
   __asm__ ("fstps %0" : "=m" (ai) : "t" (af) : "st");
   __asm__ ("fstps %0" : "=m" (bi) : "t" (bf) : "st");
   return (ai - bi + 1) >> 1;
}

#define ICEIL(x)  iceil(x)


#elif defined(USE_X86_ASM) && defined(__MSC__) && defined(__WIN32__)


static INLINE int iround(float f)
d171 3
a173 9

#define IROUND(x)  iround(x)


#elif defined(USE_X86_ASM) && defined(__WATCOMC__)


long iround(float f);
#pragma aux iround =                        \
a179 3

#define IROUND(x)  iround(x)

d181 1
a181 1
#pragma aux asm_sqrt =                      \
d186 2
a187 8


#endif /* assembly/optimized IROUND, IROUND_POS, IFLOOR, ICEIL macros */


/* default IROUND macro */
#ifndef IROUND
#define IROUND(f)  ((int) (((f) >= 0.0F) ? ((f) + 0.5F) : ((f) - 0.5F)))
a188 6


/* default IROUND_POS macro */
#ifndef IROUND_POS
#ifdef DEBUG
#define IROUND_POS(f) (ASSERT((f) >= 0.0F), IROUND(f))
d190 1
a190 1
#define IROUND_POS(f) (IROUND(f))
a191 1
#endif /* IROUND_POS */
d194 9
a202 14
/* default IFLOOR macro */
#ifndef IFLOOR
static INLINE int ifloor(float f)
{
#ifdef USE_IEEE
   int ai, bi;
   double af, bf;
   union { int i; float f; } u;

   af = (3 << 22) + 0.5 + (double)f;
   bf = (3 << 22) + 0.5 - (double)f;
   u.f = af; ai = u.i;
   u.f = bf; bi = u.i;
   return (ai - bi) >> 1;
d204 1
a204 2
   int i = IROUND(f);
   return (i > f) ? i - 1 : i;
a205 18
}
#define IFLOOR(x)  ifloor(x)
#endif /* IFLOOR */


/* default ICEIL macro */
#ifndef ICEIL
static INLINE int iceil(float f)
{
#ifdef USE_IEEE
   int ai, bi;
   double af, bf;
   union { int i; float f; } u;
   af = (3 << 22) + 0.5 + (double)f;
   bf = (3 << 22) + 0.5 - (double)f;
   u.f = af; ai = u.i;
   u.f = bf; bi = u.i;
   return (ai - bi + 1) >> 1;
d207 1
a207 2
   int i = IROUND(f);
   return (i < f) ? i + 1 : i;
a208 4
}
#define ICEIL(x)  iceil(x)
#endif /* ICEIL */

d212 1
a212 2
 * Convert unclamped or clamped ([0,1]) floats to ubytes for color
 * conversion only.  These functions round to the nearest int.
d214 12
a225 3
#define IEEE_ONE 0x3f800000
#define IEEE_0996 0x3f7f0000	/* 0.996 or something??? used in macro
                                   below only */
d227 1
a227 1
#if defined(USE_IEEE) && !defined(DEBUG)
d230 3
a232 2
 * This function/macro is sensitive to precision.  Test carefully
 * if you change it.
a233 9
#define UNCLAMPED_FLOAT_TO_UBYTE(b, f)					\
        do {								\
           union { GLfloat r; GLuint i; } __tmp;			\
           __tmp.r = (f);						\
           b = ((__tmp.i >= IEEE_0996)				\
               ? ((GLint)__tmp.i < 0) ? (GLubyte)0 : (GLubyte)255	\
               : (__tmp.r = __tmp.r*(255.0F/256.0F) + 32768.0F,		\
                  (GLubyte)__tmp.i));					\
        } while (0)
d235 6
a240 2
#define CLAMPED_FLOAT_TO_UBYTE(b, f) \
        UNCLAMPED_FLOAT_TO_UBYTE(b, f)
d242 1
a242 2
#define COPY_FLOAT( dst, src )					\
	((fi_type *) &(dst))->i = ((fi_type *) &(src))->i
d244 10
a253 1
#else /* USE_IEEE */
d255 3
a257 14
#define UNCLAMPED_FLOAT_TO_UBYTE(b, f) \
	b = ((GLubyte) IROUND(CLAMP(f, 0.0F, 1.0F) * 255.0F))

#define CLAMPED_FLOAT_TO_UBYTE(b, f) \
	b = ((GLubyte) IROUND((f) * 255.0F))

#define COPY_FLOAT( dst, src )		(dst) = (src)

#endif /* USE_IEEE */



/*
 * Integer / float conversion for colors, normals, etc.
d259 9
a268 3
/* Convert GLubyte in [0,255] to GLfloat in [0.0,1.0] */
extern float _mesa_ubyte_to_float_color_tab[256];
#define UBYTE_TO_FLOAT(u) _mesa_ubyte_to_float_color_tab[(unsigned int)(u)]
d270 2
a271 2
/* Convert GLfloat in [0.0,1.0] to GLubyte in [0,255] */
#define FLOAT_TO_UBYTE(X)	((GLubyte) (GLint) ((X) * 255.0F))
d273 1
d275 2
a276 2
/* Convert GLbyte in [-128,127] to GLfloat in [-1.0,1.0] */
#define BYTE_TO_FLOAT(B)	((2.0F * (B) + 1.0F) * (1.0F/255.0F))
d278 5
a282 2
/* Convert GLfloat in [-1.0,1.0] to GLbyte in [-128,127] */
#define FLOAT_TO_BYTE(X)	( (((GLint) (255.0F * (X))) - 1) / 2 )
d284 2
d287 1
a287 2
/* Convert GLushort in [0,65536] to GLfloat in [0.0,1.0] */
#define USHORT_TO_FLOAT(S)	((GLfloat) (S) * (1.0F / 65535.0F))
d289 11
a299 2
/* Convert GLfloat in [0.0,1.0] to GLushort in [0,65536] */
#define FLOAT_TO_USHORT(X)	((GLushort) (GLint) ((X) * 65535.0F))
d301 3
d305 1
a305 2
/* Convert GLshort in [-32768,32767] to GLfloat in [-1.0,1.0] */
#define SHORT_TO_FLOAT(S)	((2.0F * (S) + 1.0F) * (1.0F/65535.0F))
d307 2
a308 2
/* Convert GLfloat in [0.0,1.0] to GLshort in [-32768,32767] */
#define FLOAT_TO_SHORT(X)	( (((GLint) (65535.0F * (X))) - 1) / 2 )
d311 7
a317 2
/* Convert GLuint in [0,4294967295] to GLfloat in [0.0,1.0] */
#define UINT_TO_FLOAT(U)	((GLfloat) (U) * (1.0F / 4294967295.0F))
a318 13
/* Convert GLfloat in [0.0,1.0] to GLuint in [0,4294967295] */
#define FLOAT_TO_UINT(X)	((GLuint) ((X) * 4294967295.0))


/* Convert GLint in [-2147483648,2147483647] to GLfloat in [-1.0,1.0] */
#define INT_TO_FLOAT(I)		((2.0F * (I) + 1.0F) * (1.0F/4294967294.0F))

/* Convert GLfloat in [-1.0,1.0] to GLint in [-2147483648,2147483647] */
/* causes overflow:
#define FLOAT_TO_INT(X)		( (((GLint) (4294967294.0F * (X))) - 1) / 2 )
*/
/* a close approximation: */
#define FLOAT_TO_INT(X)		( (GLint) (2147483647.0 * (X)) )
d320 7
d328 1
a328 26
#define BYTE_TO_UBYTE(b)   ((GLubyte) ((b) < 0 ? 0 : (GLubyte) (b)))
#define SHORT_TO_UBYTE(s)  ((GLubyte) ((s) < 0 ? 0 : (GLubyte) ((s) >> 7)))
#define USHORT_TO_UBYTE(s) ((GLubyte) ((s) >> 8))
#define INT_TO_UBYTE(i)    ((GLubyte) ((i) < 0 ? 0 : (GLubyte) ((i) >> 23)))
#define UINT_TO_UBYTE(i)   ((GLubyte) ((i) >> 24))


#define BYTE_TO_USHORT(b)  ((b) < 0 ? 0 : ((GLushort) (((b) * 65535) / 255)))
#define UBYTE_TO_USHORT(b) (((GLushort) (b) << 8) | (GLushort) (b))
#define SHORT_TO_USHORT(s) ((s) < 0 ? 0 : ((GLushort) (((s) * 65535 / 32767))))
#define INT_TO_USHORT(i)   ((i) < 0 ? 0 : ((GLushort) ((i) >> 15)))
#define UINT_TO_USHORT(i)  ((i) < 0 ? 0 : ((GLushort) ((i) >> 16)))
#define UNCLAMPED_FLOAT_TO_USHORT(us, f)   us = (GLushort) ((f) * 65535.0F)



/*
 * Linear interpolation
 * NOTE:  OUT argument is evaluated twice!
 * NOTE:  Be wary of using *coord++ as an argument to any of these macros!
 */
#define LINTERP(T, OUT, IN)	((OUT) + (T) * ((IN) - (OUT)))

/* Can do better with integer math:
 */
#define INTERP_UB( t, dstub, outub, inub )	\
d330 5
a334 5
   GLfloat inf = UBYTE_TO_FLOAT( inub );	\
   GLfloat outf = UBYTE_TO_FLOAT( outub );	\
   GLfloat dstf = LINTERP( t, outf, inf );	\
   UNCLAMPED_FLOAT_TO_UBYTE( dstub, dstf );	\
} while (0)
d336 1
a336 1
#define INTERP_CHAN( t, dstc, outc, inc )	\
d338 3
a340 50
   GLfloat inf = CHAN_TO_FLOAT( inc );		\
   GLfloat outf = CHAN_TO_FLOAT( outc );	\
   GLfloat dstf = LINTERP( t, outf, inf );	\
   UNCLAMPED_FLOAT_TO_CHAN( dstc, dstf );	\
} while (0)

#define INTERP_UI( t, dstui, outui, inui )	\
   dstui = (GLuint) (GLint) LINTERP( t, (GLfloat) (outui), (GLfloat) (inui) )

#define INTERP_F( t, dstf, outf, inf )		\
   dstf = LINTERP( t, outf, inf )

#define INTERP_4F( t, dst, out, in )			\
do {							\
   (dst)[0] = LINTERP( (t), (out)[0], (in)[0] );	\
   (dst)[1] = LINTERP( (t), (out)[1], (in)[1] );	\
   (dst)[2] = LINTERP( (t), (out)[2], (in)[2] );	\
   (dst)[3] = LINTERP( (t), (out)[3], (in)[3] );	\
} while (0)

#define INTERP_3F( t, dst, out, in )			\
do {							\
   (dst)[0] = LINTERP( (t), (out)[0], (in)[0] );	\
   (dst)[1] = LINTERP( (t), (out)[1], (in)[1] );	\
   (dst)[2] = LINTERP( (t), (out)[2], (in)[2] );	\
} while (0)

#define INTERP_4CHAN( t, dst, out, in )			\
do {							\
   INTERP_CHAN( (t), (dst)[0], (out)[0], (in)[0] );	\
   INTERP_CHAN( (t), (dst)[1], (out)[1], (in)[1] );	\
   INTERP_CHAN( (t), (dst)[2], (out)[2], (in)[2] );	\
   INTERP_CHAN( (t), (dst)[3], (out)[3], (in)[3] );	\
} while (0)

#define INTERP_3CHAN( t, dst, out, in )			\
do {							\
   INTERP_CHAN( (t), (dst)[0], (out)[0], (in)[0] );	\
   INTERP_CHAN( (t), (dst)[1], (out)[1], (in)[1] );	\
   INTERP_CHAN( (t), (dst)[2], (out)[2], (in)[2] );	\
} while (0)

#define INTERP_SZ( t, vec, to, out, in, sz )				\
do {							       		\
   switch (sz) {							\
   case 4: (vec)[to][3] = LINTERP( (t), (vec)[out][3], (vec)[in][3] );	\
   case 3: (vec)[to][2] = LINTERP( (t), (vec)[out][2], (vec)[in][2] );	\
   case 2: (vec)[to][1] = LINTERP( (t), (vec)[out][1], (vec)[in][1] );	\
   case 1: (vec)[to][0] = LINTERP( (t), (vec)[out][0], (vec)[in][0] );	\
   }									\
a343 31
/*
 * Fixed point arithmetic macros
 */
#define FIXED_ONE       0x00000800
#define FIXED_HALF      0x00000400
#define FIXED_FRAC_MASK 0x000007FF
#define FIXED_INT_MASK  (~FIXED_FRAC_MASK)
#define FIXED_EPSILON   1
#define FIXED_SCALE     2048.0f
#define FIXED_SHIFT     11
#define FloatToFixed(X) (IROUND((X) * FIXED_SCALE))
#define IntToFixed(I)   ((I) << FIXED_SHIFT)
#define FixedToInt(X)   ((X) >> FIXED_SHIFT)
#define FixedToUns(X)   (((unsigned int)(X)) >> FIXED_SHIFT)
#define FixedCeil(X)    (((X) + FIXED_ONE - FIXED_EPSILON) & FIXED_INT_MASK)
#define FixedFloor(X)   ((X) & FIXED_INT_MASK)
#define FixedToFloat(X) ((X) * (1.0F / FIXED_SCALE))
#define PosFloatToFixed(X)      FloatToFixed(X)
#define SignedFloatToFixed(X)   FloatToFixed(X)

#ifdef USE_IEEE
/* Returns TRUE for x == Inf or x == NaN. */
static INLINE int IS_INF_OR_NAN( float x )
{
   union {float f; int i;} tmp;
   tmp.f = x;
   return !(int)((unsigned int)((tmp.i & 0x7fffffff)-0x7f800000) >> 31);
}
#else
#define IS_INF_OR_NAN(x)        (!finite(x)) 
#endif
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
d4 1
a4 1
 * Version:  5.0.2
d6 1
a6 1
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
a24 1
/* $XFree86: xc/extras/Mesa/src/mmath.h,v 1.22 2003/10/22 15:44:41 tsi Exp $ */
a38 1
#include "imports.h"
d135 1
a135 1
#define START_FAST_MATH(x) x = 0
d171 1
a171 1
   GLfloat len = (GLfloat) LEN_SQUARED_3FV(V);	\
d174 3
a176 3
      (V)[0] = (GLfloat) ((V)[0] * len);	\
      (V)[1] = (GLfloat) ((V)[1] * len);	\
      (V)[2] = (GLfloat) ((V)[2] * len);	\
d190 5
a194 6
#if defined(XFree86LOADER) && defined(IN_MODULE)
#define CEILF(x)   ((GLfloat) xf86ceil(x))
#define FLOORF(x)  ((GLfloat) xf86floor(x))
#define FABSF(x)   ((GLfloat) xf86fabs(x))
#elif defined(__gnu_linux__)
/* C99 functions */
a197 4
#else
#define CEILF(x)   ((GLfloat) ceil(x))
#define FLOORF(x)  ((GLfloat) floor(x))
#define FABSF(x)   ((GLfloat) fabs(x))
d202 1
a202 1
    defined(__powerpc__) || defined(__AMD64__) || defined(__amd64__) || \
d398 1
a398 1
#define UNCLAMPED_FLOAT_TO_UBYTE(ub, f)					\
d402 1
a402 1
           ub = ((__tmp.i >= IEEE_0996)					\
d408 2
a409 2
#define CLAMPED_FLOAT_TO_UBYTE(ub, f) \
        UNCLAMPED_FLOAT_TO_UBYTE(ub, f)
d416 2
a417 2
#define UNCLAMPED_FLOAT_TO_UBYTE(ub, f) \
	ub = ((GLubyte) IROUND(CLAMP((f), 0.0F, 1.0F) * 255.0F))
d419 2
a420 2
#define CLAMPED_FLOAT_TO_UBYTE(ub, f) \
	ub = ((GLubyte) IROUND((f) * 255.0F))
d491 1
a491 4
#define UNCLAMPED_FLOAT_TO_USHORT(us, f)  \
        us = ( (GLushort) IROUND( CLAMP((f), 0.0, 1.0) * 65535.0F) )
#define CLAMPED_FLOAT_TO_USHORT(us, f)  \
        us = ( (GLushort) IROUND( (f) * 65535.0F) )
d521 1
a521 1
   dstui = (GLuint) (GLint) LINTERP( (t), (GLfloat) (outui), (GLfloat) (inui) )
d526 6
a531 6
#define INTERP_4F( t, dst, out, in )		\
do {						\
   dst[0] = LINTERP( (t), (out)[0], (in)[0] );	\
   dst[1] = LINTERP( (t), (out)[1], (in)[1] );	\
   dst[2] = LINTERP( (t), (out)[2], (in)[2] );	\
   dst[3] = LINTERP( (t), (out)[3], (in)[3] );	\
d534 5
a538 5
#define INTERP_3F( t, dst, out, in )		\
do {						\
   dst[0] = LINTERP( (t), (out)[0], (in)[0] );	\
   dst[1] = LINTERP( (t), (out)[1], (in)[1] );	\
   dst[2] = LINTERP( (t), (out)[2], (in)[2] );	\
d557 1
a557 1
do {									\
d559 4
a562 4
   case 4: vec[to][3] = LINTERP( (t), (vec)[out][3], (vec)[in][3] );	\
   case 3: vec[to][2] = LINTERP( (t), (vec)[out][2], (vec)[in][2] );	\
   case 2: vec[to][1] = LINTERP( (t), (vec)[out][1], (vec)[in][1] );	\
   case 1: vec[to][0] = LINTERP( (t), (vec)[out][0], (vec)[in][0] );	\
a569 7
#ifdef FIXED_14
#define FIXED_ONE       0x00004000
#define FIXED_HALF      0x00002000
#define FIXED_FRAC_MASK 0x00003FFF
#define FIXED_SCALE     16384.0f
#define FIXED_SHIFT     14
#else
d573 2
a576 3
#endif
#define FIXED_INT_MASK  (~FIXED_FRAC_MASK)
#define FIXED_EPSILON   1
d587 1
a588 1
#ifdef USE_IEEE
a594 8
#elif defined(isfinite)
#define IS_INF_OR_NAN(x)        (!isfinite(x))
#elif defined(finite)
#define IS_INF_OR_NAN(x)        (!finite(x))
#elif __VMS
#define IS_INF_OR_NAN(x)        (!finite(x))
#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
#define IS_INF_OR_NAN(x)        (!isfinite(x))
d596 1
a596 21
#define IS_INF_OR_NAN(x)        (!finite(x))
#endif 


/*
 * Return log_base_2(x).
 */
#ifdef USE_IEEE

#if 0
/* This is pretty fast, but not accurate enough (only 2 fractional bits).
 * Based on code from http://www.stereopsis.com/log2.html
 */
static INLINE GLfloat LOG2(GLfloat x)
{
   const GLfloat y = x * x * x * x;
   const GLuint ix = *((GLuint *) &y);
   const GLuint exp = (ix >> 23) & 0xFF;
   const GLint log2 = ((GLint) exp) - 127;
   return (GLfloat) log2 * (1.0 / 4.0);  /* 4, because of x^4 above */
}
a597 26

/* Pretty fast, and accurate.
 * Based on code from http://www.flipcode.com/totd/
 */
static INLINE GLfloat LOG2(GLfloat val)
{
   GLint *exp_ptr = (GLint *) &val;
   GLint x = *exp_ptr;
   const GLint log_2 = ((x >> 23) & 255) - 128;
   x &= ~(255 << 23);
   x += 127 << 23;
   *exp_ptr = x;
   val = ((-1.0f/3) * val + 2) * val - 2.0f/3;
   return val + log_2;
}

#else /* USE_IEEE */

/* Slow, portable solution.
 * NOTE: log_base_2(x) = log(x) / log(2)
 * NOTE: 1.442695 = 1/log(2).
 */
#define LOG2(x)  ((GLfloat) (log(x) * 1.442695F))

#endif /* USE_IEEE */

@


1.1.1.4
log
@OpenBSD's XFree86 based module, latest fixes etc.
@
text
@d616 1
a616 1
#elif defined(__VMS)
@


