head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.28.18;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.00.59;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.00.59;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.20.03;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.28.58;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.04.46;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@
/*
 * Mesa 3-D graphics library
 * Version:  3.3
 * 
 * Copyright (C) 1999-2000  Brian Paul   All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


#ifdef PC_HEADER
#include "all.h"
#else
#include "glheader.h"
#include "context.h"
#include "macros.h"
#include "mem.h"
#include "pixel.h"
#include "types.h"
#endif



/**********************************************************************/
/*****                    glPixelZoom                             *****/
/**********************************************************************/



void
_mesa_PixelZoom( GLfloat xfactor, GLfloat yfactor )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glPixelZoom");

   ctx->Pixel.ZoomX = xfactor;
   ctx->Pixel.ZoomY = yfactor;
}



/**********************************************************************/
/*****                    glPixelStore                            *****/
/**********************************************************************/


void
_mesa_PixelStorei( GLenum pname, GLint param )
{
   /* NOTE: this call can't be compiled into the display list */
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glPixelStore");

   switch (pname) {
      case GL_PACK_SWAP_BYTES:
         ctx->Pack.SwapBytes = param ? GL_TRUE : GL_FALSE;
	 break;
      case GL_PACK_LSB_FIRST:
         ctx->Pack.LsbFirst = param ? GL_TRUE : GL_FALSE;
	 break;
      case GL_PACK_ROW_LENGTH:
	 if (param<0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Pack.RowLength = param;
	 }
	 break;
      case GL_PACK_IMAGE_HEIGHT:
         if (param<0)
            gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
         else
            ctx->Pack.ImageHeight = param;
         break;
      case GL_PACK_SKIP_PIXELS:
	 if (param<0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Pack.SkipPixels = param;
	 }
	 break;
      case GL_PACK_SKIP_ROWS:
	 if (param<0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Pack.SkipRows = param;
	 }
	 break;
      case GL_PACK_SKIP_IMAGES:
	 if (param<0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Pack.SkipImages = param;
	 }
	 break;
      case GL_PACK_ALIGNMENT:
         if (param==1 || param==2 || param==4 || param==8) {
	    ctx->Pack.Alignment = param;
	 }
	 else {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 break;
      case GL_UNPACK_SWAP_BYTES:
	 ctx->Unpack.SwapBytes = param ? GL_TRUE : GL_FALSE;
         break;
      case GL_UNPACK_LSB_FIRST:
	 ctx->Unpack.LsbFirst = param ? GL_TRUE : GL_FALSE;
	 break;
      case GL_UNPACK_ROW_LENGTH:
	 if (param<0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Unpack.RowLength = param;
	 }
	 break;
      case GL_UNPACK_IMAGE_HEIGHT:
         if (param<0)
            gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
         else
            ctx->Unpack.ImageHeight = param;
         break;
      case GL_UNPACK_SKIP_PIXELS:
	 if (param<0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Unpack.SkipPixels = param;
	 }
	 break;
      case GL_UNPACK_SKIP_ROWS:
	 if (param<0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Unpack.SkipRows = param;
	 }
	 break;
      case GL_UNPACK_SKIP_IMAGES:
	 if (param < 0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Unpack.SkipImages = param;
	 }
	 break;
      case GL_UNPACK_ALIGNMENT:
         if (param==1 || param==2 || param==4 || param==8) {
	    ctx->Unpack.Alignment = param;
	 }
	 else {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore" );
	 }
	 break;
      default:
	 gl_error( ctx, GL_INVALID_ENUM, "glPixelStore" );
   }
}


void
_mesa_PixelStoref( GLenum pname, GLfloat param )
{
   _mesa_PixelStorei( pname, (GLint) param );
}



/**********************************************************************/
/*****                         glPixelMap                         *****/
/**********************************************************************/



void
_mesa_PixelMapfv( GLenum map, GLint mapsize, const GLfloat *values )
{
   GLint i;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glPixelMapfv");


   if (mapsize<0 || mapsize>MAX_PIXEL_MAP_TABLE) {
      gl_error( ctx, GL_INVALID_VALUE, "glPixelMapfv(mapsize)" );
      return;
   }

   if (map>=GL_PIXEL_MAP_S_TO_S && map<=GL_PIXEL_MAP_I_TO_A) {
      /* test that mapsize is a power of two */
      GLuint p;
      GLboolean ok = GL_FALSE;
      for (p=1; p<=MAX_PIXEL_MAP_TABLE; p=p<<1) {
	 if ( (p&mapsize) == p ) {
	    ok = GL_TRUE;
	    break;
	 }
      }
      if (!ok) {
	 gl_error( ctx, GL_INVALID_VALUE, "glPixelMapfv(mapsize)" );
         return;
      }
   }

   switch (map) {
      case GL_PIXEL_MAP_S_TO_S:
         ctx->Pixel.MapStoSsize = mapsize;
         for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapStoS[i] = (GLint) values[i];
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_I:
         ctx->Pixel.MapItoIsize = mapsize;
         for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapItoI[i] = (GLint) values[i];
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_R:
         ctx->Pixel.MapItoRsize = mapsize;
         for (i=0;i<mapsize;i++) {
            GLfloat val = CLAMP( values[i], 0.0, 1.0 );
	    ctx->Pixel.MapItoR[i] = val;
	    ctx->Pixel.MapItoR8[i] = (GLint) (val * 255.0F);
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_G:
         ctx->Pixel.MapItoGsize = mapsize;
         for (i=0;i<mapsize;i++) {
            GLfloat val = CLAMP( values[i], 0.0, 1.0 );
	    ctx->Pixel.MapItoG[i] = val;
	    ctx->Pixel.MapItoG8[i] = (GLint) (val * 255.0F);
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_B:
         ctx->Pixel.MapItoBsize = mapsize;
         for (i=0;i<mapsize;i++) {
            GLfloat val = CLAMP( values[i], 0.0, 1.0 );
	    ctx->Pixel.MapItoB[i] = val;
	    ctx->Pixel.MapItoB8[i] = (GLint) (val * 255.0F);
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_A:
         ctx->Pixel.MapItoAsize = mapsize;
         for (i=0;i<mapsize;i++) {
            GLfloat val = CLAMP( values[i], 0.0, 1.0 );
	    ctx->Pixel.MapItoA[i] = val;
	    ctx->Pixel.MapItoA8[i] = (GLint) (val * 255.0F);
	 }
	 break;
      case GL_PIXEL_MAP_R_TO_R:
         ctx->Pixel.MapRtoRsize = mapsize;
         for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapRtoR[i] = CLAMP( values[i], 0.0, 1.0 );
	 }
	 break;
      case GL_PIXEL_MAP_G_TO_G:
         ctx->Pixel.MapGtoGsize = mapsize;
         for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapGtoG[i] = CLAMP( values[i], 0.0, 1.0 );
	 }
	 break;
      case GL_PIXEL_MAP_B_TO_B:
         ctx->Pixel.MapBtoBsize = mapsize;
         for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapBtoB[i] = CLAMP( values[i], 0.0, 1.0 );
	 }
	 break;
      case GL_PIXEL_MAP_A_TO_A:
         ctx->Pixel.MapAtoAsize = mapsize;
         for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapAtoA[i] = CLAMP( values[i], 0.0, 1.0 );
	 }
	 break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glPixelMapfv(map)" );
   }
}



void
_mesa_PixelMapuiv(GLenum map, GLint mapsize, const GLuint *values )
{
   GLfloat fvalues[MAX_PIXEL_MAP_TABLE];
   GLint i;
   if (map==GL_PIXEL_MAP_I_TO_I || map==GL_PIXEL_MAP_S_TO_S) {
      for (i=0;i<mapsize;i++) {
         fvalues[i] = (GLfloat) values[i];
      }
   }
   else {
      for (i=0;i<mapsize;i++) {
         fvalues[i] = UINT_TO_FLOAT( values[i] );
      }
   }
   _mesa_PixelMapfv(map, mapsize, fvalues);
}



void
_mesa_PixelMapusv(GLenum map, GLint mapsize, const GLushort *values )
{
   GLfloat fvalues[MAX_PIXEL_MAP_TABLE];
   GLint i;
   if (map==GL_PIXEL_MAP_I_TO_I || map==GL_PIXEL_MAP_S_TO_S) {
      for (i=0;i<mapsize;i++) {
         fvalues[i] = (GLfloat) values[i];
      }
   }
   else {
      for (i=0;i<mapsize;i++) {
         fvalues[i] = USHORT_TO_FLOAT( values[i] );
      }
   }
   _mesa_PixelMapfv(map, mapsize, fvalues);
}



void
_mesa_GetPixelMapfv( GLenum map, GLfloat *values )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   ASSERT_OUTSIDE_BEGIN_END(ctx, "glGetPixelMapfv");

   switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
         for (i=0;i<ctx->Pixel.MapItoIsize;i++) {
	    values[i] = (GLfloat) ctx->Pixel.MapItoI[i];
	 }
	 break;
      case GL_PIXEL_MAP_S_TO_S:
         for (i=0;i<ctx->Pixel.MapStoSsize;i++) {
	    values[i] = (GLfloat) ctx->Pixel.MapStoS[i];
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_R:
         MEMCPY(values,ctx->Pixel.MapItoR,ctx->Pixel.MapItoRsize*sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_I_TO_G:
         MEMCPY(values,ctx->Pixel.MapItoG,ctx->Pixel.MapItoGsize*sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_I_TO_B:
         MEMCPY(values,ctx->Pixel.MapItoB,ctx->Pixel.MapItoBsize*sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_I_TO_A:
         MEMCPY(values,ctx->Pixel.MapItoA,ctx->Pixel.MapItoAsize*sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_R_TO_R:
         MEMCPY(values,ctx->Pixel.MapRtoR,ctx->Pixel.MapRtoRsize*sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_G_TO_G:
         MEMCPY(values,ctx->Pixel.MapGtoG,ctx->Pixel.MapGtoGsize*sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_B_TO_B:
         MEMCPY(values,ctx->Pixel.MapBtoB,ctx->Pixel.MapBtoBsize*sizeof(GLfloat));
	 break;
      case GL_PIXEL_MAP_A_TO_A:
         MEMCPY(values,ctx->Pixel.MapAtoA,ctx->Pixel.MapAtoAsize*sizeof(GLfloat));
	 break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
   }
}


void
_mesa_GetPixelMapuiv( GLenum map, GLuint *values )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   ASSERT_OUTSIDE_BEGIN_END(ctx, "glGetPixelMapfv");

   switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
         MEMCPY(values, ctx->Pixel.MapItoI, ctx->Pixel.MapItoIsize*sizeof(GLint));
	 break;
      case GL_PIXEL_MAP_S_TO_S:
         MEMCPY(values, ctx->Pixel.MapStoS, ctx->Pixel.MapStoSsize*sizeof(GLint));
	 break;
      case GL_PIXEL_MAP_I_TO_R:
	 for (i=0;i<ctx->Pixel.MapItoRsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapItoR[i] );
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_G:
	 for (i=0;i<ctx->Pixel.MapItoGsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapItoG[i] );
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_B:
	 for (i=0;i<ctx->Pixel.MapItoBsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapItoB[i] );
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_A:
	 for (i=0;i<ctx->Pixel.MapItoAsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapItoA[i] );
	 }
	 break;
      case GL_PIXEL_MAP_R_TO_R:
	 for (i=0;i<ctx->Pixel.MapRtoRsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapRtoR[i] );
	 }
	 break;
      case GL_PIXEL_MAP_G_TO_G:
	 for (i=0;i<ctx->Pixel.MapGtoGsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapGtoG[i] );
	 }
	 break;
      case GL_PIXEL_MAP_B_TO_B:
	 for (i=0;i<ctx->Pixel.MapBtoBsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapBtoB[i] );
	 }
	 break;
      case GL_PIXEL_MAP_A_TO_A:
	 for (i=0;i<ctx->Pixel.MapAtoAsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapAtoA[i] );
	 }
	 break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
   }
}


void
_mesa_GetPixelMapusv( GLenum map, GLushort *values )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint i;

   ASSERT_OUTSIDE_BEGIN_END(ctx, "glGetPixelMapfv");

   switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
	 for (i=0;i<ctx->Pixel.MapItoIsize;i++) {
	    values[i] = (GLushort) ctx->Pixel.MapItoI[i];
	 }
	 break;
      case GL_PIXEL_MAP_S_TO_S:
	 for (i=0;i<ctx->Pixel.MapStoSsize;i++) {
	    values[i] = (GLushort) ctx->Pixel.MapStoS[i];
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_R:
	 for (i=0;i<ctx->Pixel.MapItoRsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapItoR[i] );
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_G:
	 for (i=0;i<ctx->Pixel.MapItoGsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapItoG[i] );
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_B:
	 for (i=0;i<ctx->Pixel.MapItoBsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapItoB[i] );
	 }
	 break;
      case GL_PIXEL_MAP_I_TO_A:
	 for (i=0;i<ctx->Pixel.MapItoAsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapItoA[i] );
	 }
	 break;
      case GL_PIXEL_MAP_R_TO_R:
	 for (i=0;i<ctx->Pixel.MapRtoRsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapRtoR[i] );
	 }
	 break;
      case GL_PIXEL_MAP_G_TO_G:
	 for (i=0;i<ctx->Pixel.MapGtoGsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapGtoG[i] );
	 }
	 break;
      case GL_PIXEL_MAP_B_TO_B:
	 for (i=0;i<ctx->Pixel.MapBtoBsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapBtoB[i] );
	 }
	 break;
      case GL_PIXEL_MAP_A_TO_A:
	 for (i=0;i<ctx->Pixel.MapAtoAsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapAtoA[i] );
	 }
	 break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
   }
}



/**********************************************************************/
/*****                       glPixelTransfer                      *****/
/**********************************************************************/


/*
 * Implements glPixelTransfer[fi] whether called immediately or from a
 * display list.
 */
void
_mesa_PixelTransferf( GLenum pname, GLfloat param )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glPixelTransfer");


   switch (pname) {
      case GL_MAP_COLOR:
         ctx->Pixel.MapColorFlag = param ? GL_TRUE : GL_FALSE;
	 break;
      case GL_MAP_STENCIL:
         ctx->Pixel.MapStencilFlag = param ? GL_TRUE : GL_FALSE;
	 break;
      case GL_INDEX_SHIFT:
         ctx->Pixel.IndexShift = (GLint) param;
	 break;
      case GL_INDEX_OFFSET:
         ctx->Pixel.IndexOffset = (GLint) param;
	 break;
      case GL_RED_SCALE:
         ctx->Pixel.RedScale = param;
	 break;
      case GL_RED_BIAS:
         ctx->Pixel.RedBias = param;
	 break;
      case GL_GREEN_SCALE:
         ctx->Pixel.GreenScale = param;
	 break;
      case GL_GREEN_BIAS:
         ctx->Pixel.GreenBias = param;
	 break;
      case GL_BLUE_SCALE:
         ctx->Pixel.BlueScale = param;
	 break;
      case GL_BLUE_BIAS:
         ctx->Pixel.BlueBias = param;
	 break;
      case GL_ALPHA_SCALE:
         ctx->Pixel.AlphaScale = param;
	 break;
      case GL_ALPHA_BIAS:
         ctx->Pixel.AlphaBias = param;
	 break;
      case GL_DEPTH_SCALE:
         ctx->Pixel.DepthScale = param;
	 break;
      case GL_DEPTH_BIAS:
         ctx->Pixel.DepthBias = param;
	 break;
      case GL_POST_COLOR_MATRIX_RED_SCALE:
         ctx->Pixel.PostColorMatrixScale[0] = param;
	 break;
      case GL_POST_COLOR_MATRIX_RED_BIAS:
         ctx->Pixel.PostColorMatrixBias[0] = param;
	 break;
      case GL_POST_COLOR_MATRIX_GREEN_SCALE:
         ctx->Pixel.PostColorMatrixScale[1] = param;
	 break;
      case GL_POST_COLOR_MATRIX_GREEN_BIAS:
         ctx->Pixel.PostColorMatrixBias[1] = param;
	 break;
      case GL_POST_COLOR_MATRIX_BLUE_SCALE:
         ctx->Pixel.PostColorMatrixScale[2] = param;
	 break;
      case GL_POST_COLOR_MATRIX_BLUE_BIAS:
         ctx->Pixel.PostColorMatrixBias[2] = param;
	 break;
      case GL_POST_COLOR_MATRIX_ALPHA_SCALE:
         ctx->Pixel.PostColorMatrixScale[3] = param;
	 break;
      case GL_POST_COLOR_MATRIX_ALPHA_BIAS:
         ctx->Pixel.PostColorMatrixBias[3] = param;
	 break;
      case GL_POST_CONVOLUTION_RED_SCALE:
         ctx->Pixel.PostConvolutionScale[0] = param;
	 break;
      case GL_POST_CONVOLUTION_RED_BIAS:
         ctx->Pixel.PostConvolutionBias[0] = param;
	 break;
      case GL_POST_CONVOLUTION_GREEN_SCALE:
         ctx->Pixel.PostConvolutionScale[1] = param;
	 break;
      case GL_POST_CONVOLUTION_GREEN_BIAS:
         ctx->Pixel.PostConvolutionBias[1] = param;
	 break;
      case GL_POST_CONVOLUTION_BLUE_SCALE:
         ctx->Pixel.PostConvolutionScale[2] = param;
	 break;
      case GL_POST_CONVOLUTION_BLUE_BIAS:
         ctx->Pixel.PostConvolutionBias[2] = param;
	 break;
      case GL_POST_CONVOLUTION_ALPHA_SCALE:
         ctx->Pixel.PostConvolutionScale[2] = param;
	 break;
      case GL_POST_CONVOLUTION_ALPHA_BIAS:
         ctx->Pixel.PostConvolutionBias[2] = param;
	 break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glPixelTransfer(pname)" );
         return;
   }

   if (ctx->Pixel.RedScale!=1.0F   || ctx->Pixel.RedBias!=0.0F ||
       ctx->Pixel.GreenScale!=1.0F || ctx->Pixel.GreenBias!=0.0F ||
       ctx->Pixel.BlueScale!=1.0F  || ctx->Pixel.BlueBias!=0.0F ||
       ctx->Pixel.AlphaScale!=1.0F || ctx->Pixel.AlphaBias!=0.0F) {
      ctx->Pixel.ScaleOrBiasRGBA = GL_TRUE;
   }
   else {
      ctx->Pixel.ScaleOrBiasRGBA = GL_FALSE;
   }

   if (ctx->Pixel.PostColorMatrixScale[0] != 1.0F ||
       ctx->Pixel.PostColorMatrixBias[0]  != 0.0F ||
       ctx->Pixel.PostColorMatrixScale[1] != 1.0F ||
       ctx->Pixel.PostColorMatrixBias[1]  != 0.0F ||
       ctx->Pixel.PostColorMatrixScale[2] != 1.0F ||
       ctx->Pixel.PostColorMatrixBias[2]  != 0.0F ||
       ctx->Pixel.PostColorMatrixScale[3] != 1.0F ||
       ctx->Pixel.PostColorMatrixBias[3]  != 0.0F) {
      ctx->Pixel.ScaleOrBiasRGBApcm = GL_TRUE;
   }
   else {
      ctx->Pixel.ScaleOrBiasRGBApcm = GL_FALSE;
   }
}


void
_mesa_PixelTransferi( GLenum pname, GLint param )
{
   _mesa_PixelTransferf( pname, (GLfloat) param );
}



/**********************************************************************/
/*****                  Pixel processing functions               ******/
/**********************************************************************/


/*
 * Apply scale and bias factors to an array of RGBA pixels.
 */
void
_mesa_scale_and_bias_rgba(const GLcontext *ctx, GLuint n, GLfloat rgba[][4])
{
   if (ctx->Pixel.RedScale != 1.0 || ctx->Pixel.RedBias != 0.0) {
      const GLfloat scale = ctx->Pixel.RedScale;
      const GLfloat bias = ctx->Pixel.RedBias;
      GLuint i;
      for (i = 0; i < n; i++) {
         rgba[i][RCOMP] = rgba[i][RCOMP] * scale + bias;
      }
   }
   if (ctx->Pixel.GreenScale != 1.0 || ctx->Pixel.GreenBias != 0.0) {
      const GLfloat scale = ctx->Pixel.GreenScale;
      const GLfloat bias = ctx->Pixel.GreenBias;
      GLuint i;
      for (i = 0; i < n; i++) {
         rgba[i][GCOMP] = rgba[i][GCOMP] * scale + bias;
      }
   }
   if (ctx->Pixel.BlueScale != 1.0 || ctx->Pixel.BlueBias != 0.0) {
      const GLfloat scale = ctx->Pixel.BlueScale;
      const GLfloat bias = ctx->Pixel.BlueBias;
      GLuint i;
      for (i = 0; i < n; i++) {
         rgba[i][BCOMP] = rgba[i][BCOMP] * scale + bias;
      }
   }
   if (ctx->Pixel.AlphaScale != 1.0 || ctx->Pixel.AlphaBias != 0.0) {
      const GLfloat scale = ctx->Pixel.AlphaScale;
      const GLfloat bias = ctx->Pixel.AlphaBias;
      GLuint i;
      for (i = 0; i < n; i++) {
         rgba[i][ACOMP] = rgba[i][ACOMP] * scale + bias;
      }
   }
}


/*
 * Apply pixel mapping to an array of floating point RGBA pixels.
 */
void
_mesa_map_rgba( const GLcontext *ctx, GLuint n, GLfloat rgba[][4] )
{
   const GLfloat rscale = ctx->Pixel.MapRtoRsize - 1;
   const GLfloat gscale = ctx->Pixel.MapGtoGsize - 1;
   const GLfloat bscale = ctx->Pixel.MapBtoBsize - 1;
   const GLfloat ascale = ctx->Pixel.MapAtoAsize - 1;
   const GLfloat *rMap = ctx->Pixel.MapRtoR;
   const GLfloat *gMap = ctx->Pixel.MapGtoG;
   const GLfloat *bMap = ctx->Pixel.MapBtoB;
   const GLfloat *aMap = ctx->Pixel.MapAtoA;
   GLuint i;
   for (i=0;i<n;i++) {
      GLfloat r = CLAMP(rgba[i][RCOMP], 0.0F, 1.0F);
      GLfloat g = CLAMP(rgba[i][GCOMP], 0.0F, 1.0F);
      GLfloat b = CLAMP(rgba[i][BCOMP], 0.0F, 1.0F);
      GLfloat a = CLAMP(rgba[i][ACOMP], 0.0F, 1.0F);
      rgba[i][RCOMP] = rMap[(GLint) (r * rscale + 0.5F)];
      rgba[i][GCOMP] = gMap[(GLint) (g * gscale + 0.5F)];
      rgba[i][BCOMP] = bMap[(GLint) (b * bscale + 0.5F)];
      rgba[i][ACOMP] = aMap[(GLint) (a * ascale + 0.5F)];
   }
}


/*
 * Apply the color matrix and post color matrix scaling and biasing.
 */
void
_mesa_transform_rgba(const GLcontext *ctx, GLuint n, GLfloat rgba[][4])
{
   const GLfloat rs = ctx->Pixel.PostColorMatrixScale[0];
   const GLfloat rb = ctx->Pixel.PostColorMatrixBias[0];
   const GLfloat gs = ctx->Pixel.PostColorMatrixScale[1];
   const GLfloat gb = ctx->Pixel.PostColorMatrixBias[1];
   const GLfloat bs = ctx->Pixel.PostColorMatrixScale[2];
   const GLfloat bb = ctx->Pixel.PostColorMatrixBias[2];
   const GLfloat as = ctx->Pixel.PostColorMatrixScale[3];
   const GLfloat ab = ctx->Pixel.PostColorMatrixBias[3];
   const GLfloat *m = ctx->ColorMatrix.m;
   GLuint i;
   for (i = 0; i < n; i++) {
      const GLfloat r = rgba[i][RCOMP];
      const GLfloat g = rgba[i][GCOMP];
      const GLfloat b = rgba[i][BCOMP];
      const GLfloat a = rgba[i][ACOMP];
      rgba[i][RCOMP] = (m[0] * r + m[4] * g + m[ 8] * b + m[12] * a) * rs + rb;
      rgba[i][GCOMP] = (m[1] * r + m[5] * g + m[ 9] * b + m[13] * a) * gs + gb;
      rgba[i][BCOMP] = (m[2] * r + m[6] * g + m[10] * b + m[14] * a) * bs + bb;
      rgba[i][ACOMP] = (m[3] * r + m[7] * g + m[11] * b + m[15] * a) * as + ab;
   }
}


/*
 * Apply a color table lookup to an array of colors.
 */
void
_mesa_lookup_rgba(const struct gl_color_table *table,
                  GLuint n, GLfloat rgba[][4])
{
   ASSERT(table->TableType == GL_FLOAT);
   if (!table->Table)
      return;

   switch (table->Format) {
      case GL_INTENSITY:
         /* replace RGBA with I */
         if (table->TableType == GL_UNSIGNED_BYTE) {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLubyte *lut = (const GLubyte *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = (GLint) (rgba[i][RCOMP] * scale + 0.5F);
               GLfloat c = lut[CLAMP(j, 0, max)] * (1.0F / 255.0F);
               rgba[i][RCOMP] = rgba[i][GCOMP] =
                  rgba[i][BCOMP] = rgba[i][ACOMP] = c;
            }

         }
         else {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = (GLint) (rgba[i][RCOMP] * scale + 0.5F);
               GLfloat c = lut[CLAMP(j, 0, max)];
               rgba[i][RCOMP] = rgba[i][GCOMP] =
                  rgba[i][BCOMP] = rgba[i][ACOMP] = c;
            }
         }
         break;
      case GL_LUMINANCE:
         /* replace RGB with L */
         if (table->TableType == GL_UNSIGNED_BYTE) {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLubyte *lut = (const GLubyte *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = (GLint) (rgba[i][RCOMP] * scale + 0.5F);
               GLfloat c = lut[CLAMP(j, 0, max)] * (1.0F / 255.0F);
               rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = c;
            }
         }
         else {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = (GLint) (rgba[i][RCOMP] * scale + 0.5F);
               GLfloat c = lut[CLAMP(j, 0, max)];
               rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = c;
            }
         }
         break;
      case GL_ALPHA:
         /* replace A with A */
         if (table->TableType == GL_UNSIGNED_BYTE) {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLubyte *lut = (const GLubyte *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = (GLint) (rgba[i][ACOMP] * scale + 0.5F);
               rgba[i][ACOMP] = lut[CLAMP(j, 0, max)] * (1.0F / 255.0F);
            }
         }
         else  {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint j = (GLint) (rgba[i][ACOMP] * scale + 0.5F);
               rgba[i][ACOMP] = lut[CLAMP(j, 0, max)];
            }
         }
         break;
      case GL_LUMINANCE_ALPHA:
         /* replace RGBA with LLLA */
         if (table->TableType == GL_UNSIGNED_BYTE) {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLubyte *lut = (const GLubyte *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jL = (GLint) (rgba[i][RCOMP] * scale + 0.5F);
               GLint jA = (GLint) (rgba[i][ACOMP] * scale + 0.5F);
               GLfloat luminance, alpha;
               jL = CLAMP(jL, 0, max);
               jA = CLAMP(jA, 0, max);
               luminance = lut[jL * 2 + 0] * (1.0F / 255.0F);
               alpha     = lut[jA * 2 + 1] * (1.0F / 255.0F);
               rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = luminance;
               rgba[i][ACOMP] = alpha;;
            }
         }
         else {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jL = (GLint) (rgba[i][RCOMP] * scale + 0.5F);
               GLint jA = (GLint) (rgba[i][ACOMP] * scale + 0.5F);
               GLfloat luminance, alpha;
               jL = CLAMP(jL, 0, max);
               jA = CLAMP(jA, 0, max);
               luminance = lut[jL * 2 + 0];
               alpha     = lut[jA * 2 + 1];
               rgba[i][RCOMP] = rgba[i][GCOMP] = rgba[i][BCOMP] = luminance;
               rgba[i][ACOMP] = alpha;;
            }
         }
         break;
      case GL_RGB:
         /* replace RGB with RGB */
         if (table->TableType == GL_UNSIGNED_BYTE) {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLubyte *lut = (const GLubyte *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jR = (GLint) (rgba[i][RCOMP] * scale + 0.5F);
               GLint jG = (GLint) (rgba[i][GCOMP] * scale + 0.5F);
               GLint jB = (GLint) (rgba[i][BCOMP] * scale + 0.5F);
               jR = CLAMP(jR, 0, max);
               jG = CLAMP(jG, 0, max);
               jB = CLAMP(jB, 0, max);
               rgba[i][RCOMP] = lut[jR * 3 + 0] * (1.0F / 255.0F);
               rgba[i][GCOMP] = lut[jG * 3 + 1] * (1.0F / 255.0F);
               rgba[i][BCOMP] = lut[jB * 3 + 2] * (1.0F / 255.0F);
            }
         }
         else {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jR = (GLint) (rgba[i][RCOMP] * scale + 0.5F);
               GLint jG = (GLint) (rgba[i][GCOMP] * scale + 0.5F);
               GLint jB = (GLint) (rgba[i][BCOMP] * scale + 0.5F);
               jR = CLAMP(jR, 0, max);
               jG = CLAMP(jG, 0, max);
               jB = CLAMP(jB, 0, max);
               rgba[i][RCOMP] = lut[jR * 3 + 0];
               rgba[i][GCOMP] = lut[jG * 3 + 1];
               rgba[i][BCOMP] = lut[jB * 3 + 2];
            }
         }
         break;
      case GL_RGBA:
         /* replace RGBA with RGBA */
         if (table->TableType == GL_UNSIGNED_BYTE) {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLubyte *lut = (const GLubyte *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jR = (GLint) (rgba[i][RCOMP] * scale + 0.5F);
               GLint jG = (GLint) (rgba[i][GCOMP] * scale + 0.5F);
               GLint jB = (GLint) (rgba[i][BCOMP] * scale + 0.5F);
               GLint jA = (GLint) (rgba[i][ACOMP] * scale + 0.5F);
               jR = CLAMP(jR, 0, max);
               jG = CLAMP(jG, 0, max);
               jB = CLAMP(jB, 0, max);
               jA = CLAMP(jA, 0, max);
               rgba[i][RCOMP] = lut[jR * 4 + 0] * (1.0F / 255.0F);
               rgba[i][GCOMP] = lut[jG * 4 + 1] * (1.0F / 255.0F);
               rgba[i][BCOMP] = lut[jB * 4 + 2] * (1.0F / 255.0F);
               rgba[i][ACOMP] = lut[jA * 4 + 3] * (1.0F / 255.0F);
            }
         }
         else {
            const GLint max = table->Size - 1;
            const GLfloat scale = (GLfloat) max;
            const GLfloat *lut = (const GLfloat *) table->Table;
            GLuint i;
            for (i = 0; i < n; i++) {
               GLint jR = (GLint) (rgba[i][RCOMP] * scale + 0.5F);
               GLint jG = (GLint) (rgba[i][GCOMP] * scale + 0.5F);
               GLint jB = (GLint) (rgba[i][BCOMP] * scale + 0.5F);
               GLint jA = (GLint) (rgba[i][ACOMP] * scale + 0.5F);
               jR = CLAMP(jR, 0, max);
               jG = CLAMP(jG, 0, max);
               jB = CLAMP(jB, 0, max);
               jA = CLAMP(jA, 0, max);
               rgba[i][RCOMP] = lut[jR * 4 + 0];
               rgba[i][GCOMP] = lut[jG * 4 + 1];
               rgba[i][BCOMP] = lut[jB * 4 + 2];
               rgba[i][ACOMP] = lut[jA * 4 + 3];
            }
         }
         break;
      default:
         gl_problem(NULL, "Bad format in _mesa_lookup_rgba");
         return;
   }
}



/*
 * Apply color index shift and offset to an array of pixels.
 */
void
_mesa_shift_and_offset_ci( const GLcontext *ctx, GLuint n, GLuint indexes[] )
{
   GLint shift = ctx->Pixel.IndexShift;
   GLint offset = ctx->Pixel.IndexOffset;
   GLuint i;
   if (shift > 0) {
      for (i=0;i<n;i++) {
         indexes[i] = (indexes[i] << shift) + offset;
      }
   }
   else if (shift < 0) {
      shift = -shift;
      for (i=0;i<n;i++) {
         indexes[i] = (indexes[i] >> shift) + offset;
      }
   }
   else {
      for (i=0;i<n;i++) {
         indexes[i] = indexes[i] + offset;
      }
   }
}


/*
 * Apply color index mapping to color indexes.
 */
void
_mesa_map_ci( const GLcontext *ctx, GLuint n, GLuint index[] )
{
   GLuint mask = ctx->Pixel.MapItoIsize - 1;
   GLuint i;
   for (i=0;i<n;i++) {
      index[i] = ctx->Pixel.MapItoI[ index[i] & mask ];
   }
}


/*
 * Map color indexes to rgba values.
 */
void
_mesa_map_ci_to_rgba_ubyte( const GLcontext *ctx, GLuint n,
                            const GLuint index[], GLubyte rgba[][4] )
{
   GLuint rmask = ctx->Pixel.MapItoRsize - 1;
   GLuint gmask = ctx->Pixel.MapItoGsize - 1;
   GLuint bmask = ctx->Pixel.MapItoBsize - 1;
   GLuint amask = ctx->Pixel.MapItoAsize - 1;
   const GLubyte *rMap = ctx->Pixel.MapItoR8;
   const GLubyte *gMap = ctx->Pixel.MapItoG8;
   const GLubyte *bMap = ctx->Pixel.MapItoB8;
   const GLubyte *aMap = ctx->Pixel.MapItoA8;
   GLuint i;
   for (i=0;i<n;i++) {
      rgba[i][RCOMP] = rMap[index[i] & rmask];
      rgba[i][GCOMP] = gMap[index[i] & gmask];
      rgba[i][BCOMP] = bMap[index[i] & bmask];
      rgba[i][ACOMP] = aMap[index[i] & amask];
   }
}


/*
 * Map color indexes to float rgba values.
 */
void
_mesa_map_ci_to_rgba( const GLcontext *ctx, GLuint n,
                      const GLuint index[], GLfloat rgba[][4] )
{
   GLuint rmask = ctx->Pixel.MapItoRsize - 1;
   GLuint gmask = ctx->Pixel.MapItoGsize - 1;
   GLuint bmask = ctx->Pixel.MapItoBsize - 1;
   GLuint amask = ctx->Pixel.MapItoAsize - 1;
   const GLfloat *rMap = ctx->Pixel.MapItoR;
   const GLfloat *gMap = ctx->Pixel.MapItoG;
   const GLfloat *bMap = ctx->Pixel.MapItoB;
   const GLfloat *aMap = ctx->Pixel.MapItoA;
   GLuint i;
   for (i=0;i<n;i++) {
      rgba[i][RCOMP] = rMap[index[i] & rmask];
      rgba[i][GCOMP] = gMap[index[i] & gmask];
      rgba[i][BCOMP] = bMap[index[i] & bmask];
      rgba[i][ACOMP] = aMap[index[i] & amask];
   }
}


/*
 * Map 8-bit color indexes to rgb values.
 */
void
_mesa_map_ci8_to_rgba( const GLcontext *ctx, GLuint n, const GLubyte index[],
                       GLubyte rgba[][4] )
{
   GLuint rmask = ctx->Pixel.MapItoRsize - 1;
   GLuint gmask = ctx->Pixel.MapItoGsize - 1;
   GLuint bmask = ctx->Pixel.MapItoBsize - 1;
   GLuint amask = ctx->Pixel.MapItoAsize - 1;
   const GLubyte *rMap = ctx->Pixel.MapItoR8;
   const GLubyte *gMap = ctx->Pixel.MapItoG8;
   const GLubyte *bMap = ctx->Pixel.MapItoB8;
   const GLubyte *aMap = ctx->Pixel.MapItoA8;
   GLuint i;
   for (i=0;i<n;i++) {
      rgba[i][RCOMP] = rMap[index[i] & rmask];
      rgba[i][GCOMP] = gMap[index[i] & gmask];
      rgba[i][BCOMP] = bMap[index[i] & bmask];
      rgba[i][ACOMP] = aMap[index[i] & amask];
   }
}


void
_mesa_shift_and_offset_stencil( const GLcontext *ctx, GLuint n,
                                GLstencil stencil[] )
{
   GLuint i;
   GLint shift = ctx->Pixel.IndexShift;
   GLint offset = ctx->Pixel.IndexOffset;
   if (shift > 0) {
      for (i=0;i<n;i++) {
         stencil[i] = (stencil[i] << shift) + offset;
      }
   }
   else if (shift < 0) {
      shift = -shift;
      for (i=0;i<n;i++) {
         stencil[i] = (stencil[i] >> shift) + offset;
      }
   }
   else {
      for (i=0;i<n;i++) {
         stencil[i] = stencil[i] + offset;
      }
   }

}


void
_mesa_map_stencil( const GLcontext *ctx, GLuint n, GLstencil stencil[] )
{
   GLuint mask = ctx->Pixel.MapStoSsize - 1;
   GLuint i;
   for (i=0;i<n;i++) {
      stencil[i] = ctx->Pixel.MapStoS[ stencil[i] & mask ];
   }
}
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d4 4
a7 4
 * Version:  5.0.1
 *
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
 *
d14 1
a14 1
 *
d17 1
a17 1
 *
d26 4
a30 2
#include "imports.h"
#include "colormac.h"
d33 1
d35 3
a37 1
#include "mtypes.h"
d50 1
a51 5
   if (ctx->Pixel.ZoomX == xfactor &&
       ctx->Pixel.ZoomY == yfactor)
      return;

   FLUSH_VERTICES(ctx, _NEW_PIXEL);
d68 1
a68 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a71 3
	 if (param == (GLint)ctx->Pack.SwapBytes)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
a74 3
	 if (param == (GLint)ctx->Pack.LsbFirst)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
d79 4
a82 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a83 4
	 if (ctx->Pack.RowLength == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.RowLength = param;
d86 4
a89 8
         if (param<0) {
            _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Pack.ImageHeight == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.ImageHeight = param;
d93 4
a96 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a97 4
	 if (ctx->Pack.SkipPixels == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.SkipPixels = param;
d101 4
a104 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a105 4
	 if (ctx->Pack.SkipRows == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.SkipRows = param;
d109 4
a112 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a113 4
	 if (ctx->Pack.SkipImages == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.SkipImages = param;
d116 7
a122 20
         if (param!=1 && param!=2 && param!=4 && param!=8) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Pack.Alignment == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.Alignment = param;
	 break;
      case GL_PACK_INVERT_MESA:
         if (!ctx->Extensions.MESA_pack_invert) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glPixelstore(pname)" );
            return;
         }
         if (ctx->Pack.Invert == param)
            return;
         FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
         ctx->Pack.Invert = param;
         break;

a123 5
	 if (param == (GLint)ctx->Unpack.SwapBytes)
	    return;
	 if ((GLint)ctx->Unpack.SwapBytes == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
a126 5
	 if (param == (GLint)ctx->Unpack.LsbFirst)
	    return;
	 if ((GLint)ctx->Unpack.LsbFirst == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
d131 4
a134 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a135 4
	 if (ctx->Unpack.RowLength == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.RowLength = param;
d138 4
a141 9
         if (param<0) {
            _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Unpack.ImageHeight == param)
	    return;

	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.ImageHeight = param;
d145 4
a148 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a149 4
	 if (ctx->Unpack.SkipPixels == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.SkipPixels = param;
d153 4
a156 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a157 4
	 if (ctx->Unpack.SkipRows == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.SkipRows = param;
d161 4
a164 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a165 4
	 if (ctx->Unpack.SkipImages == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.SkipImages = param;
d168 7
a174 15
         if (param!=1 && param!=2 && param!=4 && param!=8) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore" );
	    return;
	 }
	 if (ctx->Unpack.Alignment == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.Alignment = param;
	 break;
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         if (param == (GLint)ctx->Unpack.ClientStorage)
            return;
         FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
         ctx->Unpack.ClientStorage = param ? GL_TRUE : GL_FALSE;
         break;
d176 1
a176 2
	 _mesa_error( ctx, GL_INVALID_ENUM, "glPixelStore" );
	 return;
d200 1
a200 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d202 3
a204 2
   if (mapsize < 1 || mapsize > MAX_PIXEL_MAP_TABLE) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glPixelMapfv(mapsize)" );
d208 1
a208 1
   if (map >= GL_PIXEL_MAP_S_TO_S && map <= GL_PIXEL_MAP_I_TO_A) {
d210 10
a219 2
      if (_mesa_bitcount((GLuint) mapsize) != 1) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glPixelMapfv(mapsize)" );
a223 2
   FLUSH_VERTICES(ctx, _NEW_PIXEL);

d240 1
a240 1
            GLfloat val = CLAMP( values[i], 0.0F, 1.0F );
d248 1
a248 1
            GLfloat val = CLAMP( values[i], 0.0F, 1.0F );
d256 1
a256 1
            GLfloat val = CLAMP( values[i], 0.0F, 1.0F );
d264 1
a264 1
            GLfloat val = CLAMP( values[i], 0.0F, 1.0F );
d272 1
a272 1
	    ctx->Pixel.MapRtoR[i] = CLAMP( values[i], 0.0F, 1.0F );
d278 1
a278 1
	    ctx->Pixel.MapGtoG[i] = CLAMP( values[i], 0.0F, 1.0F );
d284 1
a284 1
	    ctx->Pixel.MapBtoB[i] = CLAMP( values[i], 0.0F, 1.0F );
d290 1
a290 1
	    ctx->Pixel.MapAtoA[i] = CLAMP( values[i], 0.0F, 1.0F );
d294 1
a294 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glPixelMapfv(map)" );
a302 1
   const GLint n = MIN2(mapsize, MAX_PIXEL_MAP_TABLE);
d306 1
a306 1
      for (i=0;i<n;i++) {
d311 1
a311 1
      for (i=0;i<n;i++) {
a322 1
   const GLint n = MIN2(mapsize, MAX_PIXEL_MAP_TABLE);
d326 1
a326 1
      for (i=0;i<n;i++) {
d331 1
a331 1
      for (i=0;i<n;i++) {
d345 2
a346 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d384 1
a384 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
d394 2
a395 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d445 1
a445 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
d455 2
a456 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d510 1
a510 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
d529 2
a530 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a533 3
         if (ctx->Pixel.MapColorFlag == (param ? GL_TRUE : GL_FALSE))
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a536 3
         if (ctx->Pixel.MapStencilFlag == (param ? GL_TRUE : GL_FALSE))
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a539 3
         if (ctx->Pixel.IndexShift == (GLint) param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a542 3
         if (ctx->Pixel.IndexOffset == (GLint) param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a545 3
         if (ctx->Pixel.RedScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a548 3
         if (ctx->Pixel.RedBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a551 3
         if (ctx->Pixel.GreenScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a554 3
         if (ctx->Pixel.GreenBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a557 3
         if (ctx->Pixel.BlueScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a560 3
         if (ctx->Pixel.BlueBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a563 3
         if (ctx->Pixel.AlphaScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a566 3
         if (ctx->Pixel.AlphaBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a569 3
         if (ctx->Pixel.DepthScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a572 3
         if (ctx->Pixel.DepthBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a575 3
         if (ctx->Pixel.PostColorMatrixScale[0] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a578 3
         if (ctx->Pixel.PostColorMatrixBias[0] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a581 3
         if (ctx->Pixel.PostColorMatrixScale[1] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a584 3
         if (ctx->Pixel.PostColorMatrixBias[1] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a587 3
         if (ctx->Pixel.PostColorMatrixScale[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a590 3
         if (ctx->Pixel.PostColorMatrixBias[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a593 3
         if (ctx->Pixel.PostColorMatrixScale[3] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a596 3
         if (ctx->Pixel.PostColorMatrixBias[3] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a599 3
         if (ctx->Pixel.PostConvolutionScale[0] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a602 3
         if (ctx->Pixel.PostConvolutionBias[0] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a605 3
         if (ctx->Pixel.PostConvolutionScale[1] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a608 3
         if (ctx->Pixel.PostConvolutionBias[1] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a611 3
         if (ctx->Pixel.PostConvolutionScale[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a614 3
         if (ctx->Pixel.PostConvolutionBias[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a617 3
         if (ctx->Pixel.PostConvolutionScale[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a620 3
         if (ctx->Pixel.PostConvolutionBias[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
d624 1
a624 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glPixelTransfer(pname)" );
d627 24
d671 1
a671 5
_mesa_scale_and_bias_rgba(const GLcontext *ctx, GLuint n, GLfloat rgba[][4],
                          GLfloat rScale, GLfloat gScale,
                          GLfloat bScale, GLfloat aScale,
                          GLfloat rBias, GLfloat gBias,
                          GLfloat bBias, GLfloat aBias)
d673 3
a675 1
   if (rScale != 1.0 || rBias != 0.0) {
d678 1
a678 1
         rgba[i][RCOMP] = rgba[i][RCOMP] * rScale + rBias;
d681 3
a683 1
   if (gScale != 1.0 || gBias != 0.0) {
d686 1
a686 1
         rgba[i][GCOMP] = rgba[i][GCOMP] * gScale + gBias;
d689 3
a691 1
   if (bScale != 1.0 || bBias != 0.0) {
d694 1
a694 1
         rgba[i][BCOMP] = rgba[i][BCOMP] * bScale + bBias;
d697 3
a699 1
   if (aScale != 1.0 || aBias != 0.0) {
d702 1
a702 1
         rgba[i][ACOMP] = rgba[i][ACOMP] * aScale + aBias;
d714 4
a717 4
   const GLfloat rscale = (GLfloat) (ctx->Pixel.MapRtoRsize - 1);
   const GLfloat gscale = (GLfloat) (ctx->Pixel.MapGtoGsize - 1);
   const GLfloat bscale = (GLfloat) (ctx->Pixel.MapBtoBsize - 1);
   const GLfloat ascale = (GLfloat) (ctx->Pixel.MapAtoAsize - 1);
d728 4
a731 4
      rgba[i][RCOMP] = rMap[IROUND(r * rscale)];
      rgba[i][GCOMP] = gMap[IROUND(g * gscale)];
      rgba[i][BCOMP] = bMap[IROUND(b * bscale)];
      rgba[i][ACOMP] = aMap[IROUND(a * ascale)];
d750 1
a750 1
   const GLfloat *m = ctx->ColorMatrixStack.Top->m;
d772 2
a773 2
   ASSERT(table->FloatTable);
   if (!table->Table || table->Size == 0)
d779 1
a779 1
         if (!table->FloatTable) {
d782 1
a782 1
            const GLchan *lut = (const GLchan *) table->Table;
d785 2
a786 2
               GLint j = IROUND(rgba[i][RCOMP] * scale);
               GLfloat c = CHAN_TO_FLOAT(lut[CLAMP(j, 0, max)]);
d790 1
d798 1
a798 1
               GLint j = IROUND(rgba[i][RCOMP] * scale);
d807 1
a807 1
         if (!table->FloatTable) {
d810 1
a810 1
            const GLchan *lut = (const GLchan *) table->Table;
d813 2
a814 2
               GLint j = IROUND(rgba[i][RCOMP] * scale);
               GLfloat c = CHAN_TO_FLOAT(lut[CLAMP(j, 0, max)]);
d824 1
a824 1
               GLint j = IROUND(rgba[i][RCOMP] * scale);
d832 1
a832 1
         if (!table->FloatTable) {
d835 1
a835 1
            const GLchan *lut = (const GLchan *) table->Table;
d838 2
a839 2
               GLint j = IROUND(rgba[i][ACOMP] * scale);
               rgba[i][ACOMP] = CHAN_TO_FLOAT(lut[CLAMP(j, 0, max)]);
d848 1
a848 1
               GLint j = IROUND(rgba[i][ACOMP] * scale);
d855 1
a855 1
         if (!table->FloatTable) {
d858 1
a858 1
            const GLchan *lut = (const GLchan *) table->Table;
d861 2
a862 2
               GLint jL = IROUND(rgba[i][RCOMP] * scale);
               GLint jA = IROUND(rgba[i][ACOMP] * scale);
d866 2
a867 2
               luminance = CHAN_TO_FLOAT(lut[jL * 2 + 0]);
               alpha     = CHAN_TO_FLOAT(lut[jA * 2 + 1]);
d878 2
a879 2
               GLint jL = IROUND(rgba[i][RCOMP] * scale);
               GLint jA = IROUND(rgba[i][ACOMP] * scale);
d892 1
a892 1
         if (!table->FloatTable) {
d895 1
a895 1
            const GLchan *lut = (const GLchan *) table->Table;
d898 3
a900 3
               GLint jR = IROUND(rgba[i][RCOMP] * scale);
               GLint jG = IROUND(rgba[i][GCOMP] * scale);
               GLint jB = IROUND(rgba[i][BCOMP] * scale);
d904 3
a906 3
               rgba[i][RCOMP] = CHAN_TO_FLOAT(lut[jR * 3 + 0]);
               rgba[i][GCOMP] = CHAN_TO_FLOAT(lut[jG * 3 + 1]);
               rgba[i][BCOMP] = CHAN_TO_FLOAT(lut[jB * 3 + 2]);
d915 3
a917 3
               GLint jR = IROUND(rgba[i][RCOMP] * scale);
               GLint jG = IROUND(rgba[i][GCOMP] * scale);
               GLint jB = IROUND(rgba[i][BCOMP] * scale);
d929 1
a929 1
         if (!table->FloatTable) {
d932 1
a932 1
            const GLchan *lut = (const GLchan *) table->Table;
d935 4
a938 4
               GLint jR = IROUND(rgba[i][RCOMP] * scale);
               GLint jG = IROUND(rgba[i][GCOMP] * scale);
               GLint jB = IROUND(rgba[i][BCOMP] * scale);
               GLint jA = IROUND(rgba[i][ACOMP] * scale);
d943 4
a946 4
               rgba[i][RCOMP] = CHAN_TO_FLOAT(lut[jR * 4 + 0]);
               rgba[i][GCOMP] = CHAN_TO_FLOAT(lut[jG * 4 + 1]);
               rgba[i][BCOMP] = CHAN_TO_FLOAT(lut[jB * 4 + 2]);
               rgba[i][ACOMP] = CHAN_TO_FLOAT(lut[jA * 4 + 3]);
d955 4
a958 4
               GLint jR = IROUND(rgba[i][RCOMP] * scale);
               GLint jG = IROUND(rgba[i][GCOMP] * scale);
               GLint jB = IROUND(rgba[i][BCOMP] * scale);
               GLint jA = IROUND(rgba[i][ACOMP] * scale);
d971 1
a971 1
         _mesa_problem(NULL, "Bad format in _mesa_lookup_rgba");
d1024 2
a1025 2
_mesa_map_ci_to_rgba_chan( const GLcontext *ctx, GLuint n,
                           const GLuint index[], GLchan rgba[][4] )
a1026 1
#if CHAN_BITS == 8
a1041 17
#else
   GLuint rmask = ctx->Pixel.MapItoRsize - 1;
   GLuint gmask = ctx->Pixel.MapItoGsize - 1;
   GLuint bmask = ctx->Pixel.MapItoBsize - 1;
   GLuint amask = ctx->Pixel.MapItoAsize - 1;
   const GLfloat *rMap = ctx->Pixel.MapItoR;
   const GLfloat *gMap = ctx->Pixel.MapItoG;
   const GLfloat *bMap = ctx->Pixel.MapItoB;
   const GLfloat *aMap = ctx->Pixel.MapItoA;
   GLuint i;
   for (i=0;i<n;i++) {
      CLAMPED_FLOAT_TO_CHAN(rgba[i][RCOMP], rMap[index[i] & rmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][GCOMP], gMap[index[i] & gmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][BCOMP], bMap[index[i] & bmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][ACOMP], aMap[index[i] & amask]);
   }
#endif
d1075 1
a1075 1
                       GLchan rgba[][4] )
a1076 1
#if CHAN_BITS == 8
a1091 17
#else
   GLuint rmask = ctx->Pixel.MapItoRsize - 1;
   GLuint gmask = ctx->Pixel.MapItoGsize - 1;
   GLuint bmask = ctx->Pixel.MapItoBsize - 1;
   GLuint amask = ctx->Pixel.MapItoAsize - 1;
   const GLfloat *rMap = ctx->Pixel.MapItoR;
   const GLfloat *gMap = ctx->Pixel.MapItoG;
   const GLfloat *bMap = ctx->Pixel.MapItoB;
   const GLfloat *aMap = ctx->Pixel.MapItoA;
   GLuint i;
   for (i=0;i<n;i++) {
      CLAMPED_FLOAT_TO_CHAN(rgba[i][RCOMP], rMap[index[i] & rmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][GCOMP], gMap[index[i] & gmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][BCOMP], bMap[index[i] & bmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][ACOMP], aMap[index[i] & amask]);
   }
#endif
a1129 49
}



/*
 * This function converts an array of GLchan colors to GLfloat colors.
 * Most importantly, it undoes the non-uniform quantization of pixel
 * values introduced when we convert shallow (< 8 bit) pixel values
 * to GLubytes in the ctx->Driver.ReadRGBASpan() functions.
 * This fixes a number of OpenGL conformance failures when running on
 * 16bpp displays, for example.
 */
void
_mesa_chan_to_float_span(const GLcontext *ctx, GLuint n,
                         CONST GLchan rgba[][4], GLfloat rgbaf[][4])
{
#if CHAN_TYPE == GL_FLOAT
   MEMCPY(rgbaf, rgba, n * 4 * sizeof(GLfloat));
#else
   const GLuint rShift = CHAN_BITS - ctx->Visual.redBits;
   const GLuint gShift = CHAN_BITS - ctx->Visual.greenBits;
   const GLuint bShift = CHAN_BITS - ctx->Visual.blueBits;
   GLuint aShift;
   const GLfloat rScale = 1.0F / (GLfloat) ((1 << ctx->Visual.redBits  ) - 1);
   const GLfloat gScale = 1.0F / (GLfloat) ((1 << ctx->Visual.greenBits) - 1);
   const GLfloat bScale = 1.0F / (GLfloat) ((1 << ctx->Visual.blueBits ) - 1);
   GLfloat aScale;
   GLuint i;

   if (ctx->Visual.alphaBits > 0) {
      aShift = CHAN_BITS - ctx->Visual.alphaBits;
      aScale = 1.0F / (GLfloat) ((1 << ctx->Visual.alphaBits) - 1);
   }
   else {
      aShift = 0;
      aScale = 1.0F / CHAN_MAXF;
   }

   for (i = 0; i < n; i++) {
      const GLint r = rgba[i][RCOMP] >> rShift;
      const GLint g = rgba[i][GCOMP] >> gShift;
      const GLint b = rgba[i][BCOMP] >> bShift;
      const GLint a = rgba[i][ACOMP] >> aShift;
      rgbaf[i][RCOMP] = (GLfloat) r * rScale;
      rgbaf[i][GCOMP] = (GLfloat) g * gScale;
      rgbaf[i][BCOMP] = (GLfloat) b * bScale;
      rgbaf[i][ACOMP] = (GLfloat) a * aScale;
   }
#endif
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d4 4
a7 4
 * Version:  4.0.4
 *
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
 *
d14 1
a14 1
 *
d17 1
a17 1
 *
a30 1
#include "colormac.h"
d35 1
a35 1
#include "mtypes.h"
d50 1
a51 5
   if (ctx->Pixel.ZoomX == xfactor &&
       ctx->Pixel.ZoomY == yfactor)
      return;

   FLUSH_VERTICES(ctx, _NEW_PIXEL);
d68 1
a68 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a71 3
	 if (param == (GLint)ctx->Pack.SwapBytes)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
a74 3
	 if (param == (GLint)ctx->Pack.LsbFirst)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
d79 4
a82 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a83 4
	 if (ctx->Pack.RowLength == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.RowLength = param;
d86 4
a89 8
         if (param<0) {
            _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Pack.ImageHeight == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.ImageHeight = param;
d93 4
a96 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a97 4
	 if (ctx->Pack.SkipPixels == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.SkipPixels = param;
d101 4
a104 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a105 4
	 if (ctx->Pack.SkipRows == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.SkipRows = param;
d109 4
a112 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a113 4
	 if (ctx->Pack.SkipImages == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.SkipImages = param;
d116 7
a122 20
         if (param!=1 && param!=2 && param!=4 && param!=8) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Pack.Alignment == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Pack.Alignment = param;
	 break;
      case GL_PACK_INVERT_MESA:
         if (!ctx->Extensions.MESA_pack_invert) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glPixelstore(pname)" );
            return;
         }
         if (ctx->Pack.Invert == param)
            return;
         FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
         ctx->Pack.Invert = param;
         break;

a123 5
	 if (param == (GLint)ctx->Unpack.SwapBytes)
	    return;
	 if ((GLint)ctx->Unpack.SwapBytes == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
a126 5
	 if (param == (GLint)ctx->Unpack.LsbFirst)
	    return;
	 if ((GLint)ctx->Unpack.LsbFirst == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
d131 4
a134 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a135 4
	 if (ctx->Unpack.RowLength == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.RowLength = param;
d138 4
a141 9
         if (param<0) {
            _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
	 }
	 if (ctx->Unpack.ImageHeight == param)
	    return;

	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.ImageHeight = param;
d145 4
a148 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a149 4
	 if (ctx->Unpack.SkipPixels == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.SkipPixels = param;
d153 4
a156 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a157 4
	 if (ctx->Unpack.SkipRows == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.SkipRows = param;
d161 4
a164 2
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	    return;
a165 4
	 if (ctx->Unpack.SkipImages == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.SkipImages = param;
d168 7
a174 16
         if (param!=1 && param!=2 && param!=4 && param!=8) {
	    _mesa_error( ctx, GL_INVALID_VALUE, "glPixelStore" );
	    return;
	 }
	 if (ctx->Unpack.Alignment == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
	 ctx->Unpack.Alignment = param;
	 break;
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         if (param == (GLint)ctx->Unpack.ClientStorage)
            return;
         FLUSH_VERTICES(ctx, _NEW_PACKUNPACK);
         ctx->Unpack.ClientStorage = param ? GL_TRUE : GL_FALSE;
         break;

d176 1
a176 2
	 _mesa_error( ctx, GL_INVALID_ENUM, "glPixelStore" );
	 return;
d200 2
a201 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d203 2
a204 2
   if (mapsize < 1 || mapsize > MAX_PIXEL_MAP_TABLE) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glPixelMapfv(mapsize)" );
d208 1
a208 1
   if (map >= GL_PIXEL_MAP_S_TO_S && map <= GL_PIXEL_MAP_I_TO_A) {
d210 10
a219 2
      if (_mesa_bitcount((GLuint) mapsize) != 1) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glPixelMapfv(mapsize)" );
a223 2
   FLUSH_VERTICES(ctx, _NEW_PIXEL);

d240 1
a240 1
            GLfloat val = CLAMP( values[i], 0.0F, 1.0F );
d248 1
a248 1
            GLfloat val = CLAMP( values[i], 0.0F, 1.0F );
d256 1
a256 1
            GLfloat val = CLAMP( values[i], 0.0F, 1.0F );
d264 1
a264 1
            GLfloat val = CLAMP( values[i], 0.0F, 1.0F );
d272 1
a272 1
	    ctx->Pixel.MapRtoR[i] = CLAMP( values[i], 0.0F, 1.0F );
d278 1
a278 1
	    ctx->Pixel.MapGtoG[i] = CLAMP( values[i], 0.0F, 1.0F );
d284 1
a284 1
	    ctx->Pixel.MapBtoB[i] = CLAMP( values[i], 0.0F, 1.0F );
d290 1
a290 1
	    ctx->Pixel.MapAtoA[i] = CLAMP( values[i], 0.0F, 1.0F );
d294 1
a294 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glPixelMapfv(map)" );
a302 1
   const GLint n = MIN2(mapsize, MAX_PIXEL_MAP_TABLE);
d306 1
a306 1
      for (i=0;i<n;i++) {
d311 1
a311 1
      for (i=0;i<n;i++) {
a322 1
   const GLint n = MIN2(mapsize, MAX_PIXEL_MAP_TABLE);
d326 1
a326 1
      for (i=0;i<n;i++) {
d331 1
a331 1
      for (i=0;i<n;i++) {
d345 2
a346 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d384 1
a384 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
d394 2
a395 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d445 1
a445 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
d455 2
a456 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d510 1
a510 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
d529 2
a530 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a533 3
         if (ctx->Pixel.MapColorFlag == (param ? GL_TRUE : GL_FALSE))
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a536 3
         if (ctx->Pixel.MapStencilFlag == (param ? GL_TRUE : GL_FALSE))
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a539 3
         if (ctx->Pixel.IndexShift == (GLint) param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a542 3
         if (ctx->Pixel.IndexOffset == (GLint) param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a545 3
         if (ctx->Pixel.RedScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a548 3
         if (ctx->Pixel.RedBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a551 3
         if (ctx->Pixel.GreenScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a554 3
         if (ctx->Pixel.GreenBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a557 3
         if (ctx->Pixel.BlueScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a560 3
         if (ctx->Pixel.BlueBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a563 3
         if (ctx->Pixel.AlphaScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a566 3
         if (ctx->Pixel.AlphaBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a569 3
         if (ctx->Pixel.DepthScale == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a572 3
         if (ctx->Pixel.DepthBias == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a575 3
         if (ctx->Pixel.PostColorMatrixScale[0] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a578 3
         if (ctx->Pixel.PostColorMatrixBias[0] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a581 3
         if (ctx->Pixel.PostColorMatrixScale[1] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a584 3
         if (ctx->Pixel.PostColorMatrixBias[1] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a587 3
         if (ctx->Pixel.PostColorMatrixScale[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a590 3
         if (ctx->Pixel.PostColorMatrixBias[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a593 3
         if (ctx->Pixel.PostColorMatrixScale[3] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a596 3
         if (ctx->Pixel.PostColorMatrixBias[3] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a599 3
         if (ctx->Pixel.PostConvolutionScale[0] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a602 3
         if (ctx->Pixel.PostConvolutionBias[0] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a605 3
         if (ctx->Pixel.PostConvolutionScale[1] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a608 3
         if (ctx->Pixel.PostConvolutionBias[1] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a611 3
         if (ctx->Pixel.PostConvolutionScale[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a614 3
         if (ctx->Pixel.PostConvolutionBias[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a617 3
         if (ctx->Pixel.PostConvolutionScale[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
a620 3
         if (ctx->Pixel.PostConvolutionBias[2] == param)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_PIXEL);
d624 1
a624 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glPixelTransfer(pname)" );
d627 24
d671 1
a671 5
_mesa_scale_and_bias_rgba(const GLcontext *ctx, GLuint n, GLfloat rgba[][4],
                          GLfloat rScale, GLfloat gScale,
                          GLfloat bScale, GLfloat aScale,
                          GLfloat rBias, GLfloat gBias,
                          GLfloat bBias, GLfloat aBias)
d673 3
a675 1
   if (rScale != 1.0 || rBias != 0.0) {
d678 1
a678 1
         rgba[i][RCOMP] = rgba[i][RCOMP] * rScale + rBias;
d681 3
a683 1
   if (gScale != 1.0 || gBias != 0.0) {
d686 1
a686 1
         rgba[i][GCOMP] = rgba[i][GCOMP] * gScale + gBias;
d689 3
a691 1
   if (bScale != 1.0 || bBias != 0.0) {
d694 1
a694 1
         rgba[i][BCOMP] = rgba[i][BCOMP] * bScale + bBias;
d697 3
a699 1
   if (aScale != 1.0 || aBias != 0.0) {
d702 1
a702 1
         rgba[i][ACOMP] = rgba[i][ACOMP] * aScale + aBias;
d714 4
a717 4
   const GLfloat rscale = (GLfloat) (ctx->Pixel.MapRtoRsize - 1);
   const GLfloat gscale = (GLfloat) (ctx->Pixel.MapGtoGsize - 1);
   const GLfloat bscale = (GLfloat) (ctx->Pixel.MapBtoBsize - 1);
   const GLfloat ascale = (GLfloat) (ctx->Pixel.MapAtoAsize - 1);
d728 4
a731 4
      rgba[i][RCOMP] = rMap[IROUND(r * rscale)];
      rgba[i][GCOMP] = gMap[IROUND(g * gscale)];
      rgba[i][BCOMP] = bMap[IROUND(b * bscale)];
      rgba[i][ACOMP] = aMap[IROUND(a * ascale)];
d772 2
a773 2
   ASSERT(table->FloatTable);
   if (!table->Table || table->Size == 0)
d779 1
a779 1
         if (!table->FloatTable) {
d782 1
a782 1
            const GLchan *lut = (const GLchan *) table->Table;
d785 2
a786 2
               GLint j = IROUND(rgba[i][RCOMP] * scale);
               GLfloat c = CHAN_TO_FLOAT(lut[CLAMP(j, 0, 1)]);
d798 1
a798 1
               GLint j = IROUND(rgba[i][RCOMP] * scale);
d807 1
a807 1
         if (!table->FloatTable) {
d810 1
a810 1
            const GLchan *lut = (const GLchan *) table->Table;
d813 2
a814 2
               GLint j = IROUND(rgba[i][RCOMP] * scale);
               GLfloat c = CHAN_TO_FLOAT(lut[CLAMP(j, 0, max)]);
d824 1
a824 1
               GLint j = IROUND(rgba[i][RCOMP] * scale);
d832 1
a832 1
         if (!table->FloatTable) {
d835 1
a835 1
            const GLchan *lut = (const GLchan *) table->Table;
d838 2
a839 2
               GLint j = IROUND(rgba[i][ACOMP] * scale);
               rgba[i][ACOMP] = CHAN_TO_FLOAT(lut[CLAMP(j, 0, max)]);
d848 1
a848 1
               GLint j = IROUND(rgba[i][ACOMP] * scale);
d855 1
a855 1
         if (!table->FloatTable) {
d858 1
a858 1
            const GLchan *lut = (const GLchan *) table->Table;
d861 2
a862 2
               GLint jL = IROUND(rgba[i][RCOMP] * scale);
               GLint jA = IROUND(rgba[i][ACOMP] * scale);
d866 2
a867 2
               luminance = CHAN_TO_FLOAT(lut[jL * 2 + 0]);
               alpha     = CHAN_TO_FLOAT(lut[jA * 2 + 1]);
d878 2
a879 2
               GLint jL = IROUND(rgba[i][RCOMP] * scale);
               GLint jA = IROUND(rgba[i][ACOMP] * scale);
d892 1
a892 1
         if (!table->FloatTable) {
d895 1
a895 1
            const GLchan *lut = (const GLchan *) table->Table;
d898 3
a900 3
               GLint jR = IROUND(rgba[i][RCOMP] * scale);
               GLint jG = IROUND(rgba[i][GCOMP] * scale);
               GLint jB = IROUND(rgba[i][BCOMP] * scale);
d904 3
a906 3
               rgba[i][RCOMP] = CHAN_TO_FLOAT(lut[jR * 3 + 0]);
               rgba[i][GCOMP] = CHAN_TO_FLOAT(lut[jG * 3 + 1]);
               rgba[i][BCOMP] = CHAN_TO_FLOAT(lut[jB * 3 + 2]);
d915 3
a917 3
               GLint jR = IROUND(rgba[i][RCOMP] * scale);
               GLint jG = IROUND(rgba[i][GCOMP] * scale);
               GLint jB = IROUND(rgba[i][BCOMP] * scale);
d929 1
a929 1
         if (!table->FloatTable) {
d932 1
a932 1
            const GLchan *lut = (const GLchan *) table->Table;
d935 4
a938 4
               GLint jR = IROUND(rgba[i][RCOMP] * scale);
               GLint jG = IROUND(rgba[i][GCOMP] * scale);
               GLint jB = IROUND(rgba[i][BCOMP] * scale);
               GLint jA = IROUND(rgba[i][ACOMP] * scale);
d943 4
a946 4
               rgba[i][RCOMP] = CHAN_TO_FLOAT(lut[jR * 4 + 0]);
               rgba[i][GCOMP] = CHAN_TO_FLOAT(lut[jG * 4 + 1]);
               rgba[i][BCOMP] = CHAN_TO_FLOAT(lut[jB * 4 + 2]);
               rgba[i][ACOMP] = CHAN_TO_FLOAT(lut[jA * 4 + 3]);
d955 4
a958 4
               GLint jR = IROUND(rgba[i][RCOMP] * scale);
               GLint jG = IROUND(rgba[i][GCOMP] * scale);
               GLint jB = IROUND(rgba[i][BCOMP] * scale);
               GLint jA = IROUND(rgba[i][ACOMP] * scale);
d971 1
a971 1
         _mesa_problem(NULL, "Bad format in _mesa_lookup_rgba");
d1024 2
a1025 2
_mesa_map_ci_to_rgba_chan( const GLcontext *ctx, GLuint n,
                           const GLuint index[], GLchan rgba[][4] )
a1026 1
#if CHAN_BITS == 8
a1041 17
#else
   GLuint rmask = ctx->Pixel.MapItoRsize - 1;
   GLuint gmask = ctx->Pixel.MapItoGsize - 1;
   GLuint bmask = ctx->Pixel.MapItoBsize - 1;
   GLuint amask = ctx->Pixel.MapItoAsize - 1;
   const GLfloat *rMap = ctx->Pixel.MapItoR;
   const GLfloat *gMap = ctx->Pixel.MapItoG;
   const GLfloat *bMap = ctx->Pixel.MapItoB;
   const GLfloat *aMap = ctx->Pixel.MapItoA;
   GLuint i;
   for (i=0;i<n;i++) {
      CLAMPED_FLOAT_TO_CHAN(rgba[i][RCOMP], rMap[index[i] & rmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][GCOMP], gMap[index[i] & gmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][BCOMP], bMap[index[i] & bmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][ACOMP], aMap[index[i] & amask]);
   }
#endif
d1075 1
a1075 1
                       GLchan rgba[][4] )
a1076 1
#if CHAN_BITS == 8
a1091 17
#else
   GLuint rmask = ctx->Pixel.MapItoRsize - 1;
   GLuint gmask = ctx->Pixel.MapItoGsize - 1;
   GLuint bmask = ctx->Pixel.MapItoBsize - 1;
   GLuint amask = ctx->Pixel.MapItoAsize - 1;
   const GLfloat *rMap = ctx->Pixel.MapItoR;
   const GLfloat *gMap = ctx->Pixel.MapItoG;
   const GLfloat *bMap = ctx->Pixel.MapItoB;
   const GLfloat *aMap = ctx->Pixel.MapItoA;
   GLuint i;
   for (i=0;i<n;i++) {
      CLAMPED_FLOAT_TO_CHAN(rgba[i][RCOMP], rMap[index[i] & rmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][GCOMP], gMap[index[i] & gmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][BCOMP], bMap[index[i] & bmask]);
      CLAMPED_FLOAT_TO_CHAN(rgba[i][ACOMP], aMap[index[i] & amask]);
   }
#endif
a1129 49
}



/*
 * This function converts an array of GLchan colors to GLfloat colors.
 * Most importantly, it undoes the non-uniform quantization of pixel
 * values introduced when we convert shallow (< 8 bit) pixel values
 * to GLubytes in the ctx->Driver.ReadRGBASpan() functions.
 * This fixes a number of OpenGL conformance failures when running on
 * 16bpp displays, for example.
 */
void
_mesa_chan_to_float_span(const GLcontext *ctx, GLuint n,
                         CONST GLchan rgba[][4], GLfloat rgbaf[][4])
{
#if CHAN_TYPE == GL_FLOAT
   MEMCPY(rgbaf, rgba, n * 4 * sizeof(GLfloat));
#else
   const GLuint rShift = CHAN_BITS - ctx->Visual.redBits;
   const GLuint gShift = CHAN_BITS - ctx->Visual.greenBits;
   const GLuint bShift = CHAN_BITS - ctx->Visual.blueBits;
   GLuint aShift;
   const GLfloat rScale = 1.0F / (GLfloat) ((1 << ctx->Visual.redBits  ) - 1);
   const GLfloat gScale = 1.0F / (GLfloat) ((1 << ctx->Visual.greenBits) - 1);
   const GLfloat bScale = 1.0F / (GLfloat) ((1 << ctx->Visual.blueBits ) - 1);
   GLfloat aScale;
   GLuint i;

   if (ctx->Visual.alphaBits > 0) {
      aShift = CHAN_BITS - ctx->Visual.alphaBits;
      aScale = 1.0F / (GLfloat) ((1 << ctx->Visual.alphaBits) - 1);
   }
   else {
      aShift = 0;
      aScale = 1.0F / CHAN_MAXF;
   }

   for (i = 0; i < n; i++) {
      const GLint r = rgba[i][RCOMP] >> rShift;
      const GLint g = rgba[i][GCOMP] >> gShift;
      const GLint b = rgba[i][BCOMP] >> bShift;
      const GLint a = rgba[i][ACOMP] >> aShift;
      rgbaf[i][RCOMP] = (GLfloat) r * rScale;
      rgbaf[i][GCOMP] = (GLfloat) g * gScale;
      rgbaf[i][BCOMP] = (GLfloat) b * bScale;
      rgbaf[i][ACOMP] = (GLfloat) a * aScale;
   }
#endif
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d4 1
a4 1
 * Version:  5.0.1
d6 1
a6 1
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
d26 4
a30 1
#include "imports.h"
d34 1
d37 2
d242 1
d872 1
a872 1
   const GLfloat *m = ctx->ColorMatrixStack.Top->m;
d908 1
a908 1
               GLfloat c = CHAN_TO_FLOAT(lut[CLAMP(j, 0, max)]);
d912 1
@


